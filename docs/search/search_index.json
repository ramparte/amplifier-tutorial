{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"Welcome to the Amplifier Tutorial \u00b6 Learn Amplifier , the modular AI agent framework from Microsoft. What You'll Learn \u00b6 This tutorial takes you from zero to productive with Amplifier: Getting Started - Install, configure, and run your first conversation Core Concepts - Understand bundles, modules, agents, and recipes Tools Reference - Deep dives into every available tool Developer Setup - Professional workflows for serious development Advanced Topics - Build your own bundles, tools, and agents Who This Is For \u00b6 Developers who want an AI coding assistant they can customize Teams who need multi-provider flexibility (not locked to one vendor) Power users frustrated with black-box AI tools Anyone curious about how modern AI agents actually work Quick Start (90 Seconds) \u00b6 # Install UV (Python package manager) curl -LsSf https://astral.sh/uv/install.sh | sh # Install Amplifier uv tool install git+https://github.com/microsoft/amplifier # Configure your AI provider amplifier init # Start chatting amplifier That's it. You're now running a modular AI agent framework. Why Amplifier? \u00b6 Traditional AI Tools Amplifier One AI provider Switch between 7+ providers Limited customization Full module system Black box Transparent event logging Ad-hoc prompts Declarative workflows (recipes) Single agent Multi-agent orchestration Next Steps \u00b6 New to Amplifier? Start with What is Amplifier? Ready to install? Jump to Installation Want to explore? Browse the Tools Reference This tutorial is generated using Amplifier itself. The source is modular markdown that can be updated incrementally.","title":"Home"},{"location":"index.html#welcome-to-the-amplifier-tutorial","text":"Learn Amplifier , the modular AI agent framework from Microsoft.","title":"Welcome to the Amplifier Tutorial"},{"location":"index.html#what-youll-learn","text":"This tutorial takes you from zero to productive with Amplifier: Getting Started - Install, configure, and run your first conversation Core Concepts - Understand bundles, modules, agents, and recipes Tools Reference - Deep dives into every available tool Developer Setup - Professional workflows for serious development Advanced Topics - Build your own bundles, tools, and agents","title":"What You'll Learn"},{"location":"index.html#who-this-is-for","text":"Developers who want an AI coding assistant they can customize Teams who need multi-provider flexibility (not locked to one vendor) Power users frustrated with black-box AI tools Anyone curious about how modern AI agents actually work","title":"Who This Is For"},{"location":"index.html#quick-start-90-seconds","text":"# Install UV (Python package manager) curl -LsSf https://astral.sh/uv/install.sh | sh # Install Amplifier uv tool install git+https://github.com/microsoft/amplifier # Configure your AI provider amplifier init # Start chatting amplifier That's it. You're now running a modular AI agent framework.","title":"Quick Start (90 Seconds)"},{"location":"index.html#why-amplifier","text":"Traditional AI Tools Amplifier One AI provider Switch between 7+ providers Limited customization Full module system Black box Transparent event logging Ad-hoc prompts Declarative workflows (recipes) Single agent Multi-agent orchestration","title":"Why Amplifier?"},{"location":"index.html#next-steps","text":"New to Amplifier? Start with What is Amplifier? Ready to install? Jump to Installation Want to explore? Browse the Tools Reference This tutorial is generated using Amplifier itself. The source is modular markdown that can be updated incrementally.","title":"Next Steps"},{"location":"advanced/index.html","text":"Advanced Topics \u00b6 This section covers advanced Amplifier concepts for users who want to go deeper. Topics here assume familiarity with core concepts, bundles, and basic agent development. These guides help you build sophisticated AI applications, customize the kernel, and optimize performance. Section Contents \u00b6 Page Description Kernel Internals How the Amplifier kernel works Custom Tools Building your own tool modules Hook Development Creating custom hooks Provider Integration Adding new LLM providers Multi-Agent Systems Complex agent orchestration Recipes Declarative multi-step workflows Performance Optimization and scaling Security Security model and best practices Quick Tips \u00b6 Understand modules first \u2014 All advanced features build on the module system Read the source \u2014 Amplifier is open; the code is the best documentation Test in isolation \u2014 Advanced features can have subtle interactions Use typed interfaces \u2014 TypedDict and Protocol classes catch errors early Profile before optimizing \u2014 Measure actual bottlenecks, don't guess Architecture Deep Dive \u00b6 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 Application Layer \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 Recipes \u2502 Multi-Agent \u2502 Custom Behaviors \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 Modules: Providers \u2502 Tools \u2502 Hooks \u2502 Custom \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 Event System \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 Kernel: Session Manager \u2502 Module Registry \u2502 Router \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 Module Types \u00b6 Type Purpose Interface Provider LLM backends ProviderProtocol Tool Agent capabilities ToolProtocol Hook Event interception HookProtocol Context Knowledge injection ContextProtocol Where to Start \u00b6 Want to extend Amplifier? Start with Custom Tools \u2014it's the most common extension point. Building complex workflows? Read Recipes for declarative multi-step orchestration. Optimizing performance? Check Performance for profiling and optimization strategies. Security concerns? Review Security before deploying to production. Advanced Patterns \u00b6 Pattern Use Case Guide Tool composition Combine tools for complex ops Custom Tools Event sourcing Audit and replay Kernel Internals Agent delegation Hierarchical task distribution Multi-Agent Systems Staged execution Human-in-loop workflows Recipes Prerequisites \u00b6 Before diving into advanced topics, ensure you understand: [ ] Core concepts (sessions, agents, modules) [ ] Bundle composition and structure [ ] Basic tool usage patterns [ ] Hook event lifecycle Related Sections \u00b6 Concepts: Core Architecture Dev Setup: Contributing Bundles: Creating Bundles","title":"Overview"},{"location":"advanced/index.html#advanced-topics","text":"This section covers advanced Amplifier concepts for users who want to go deeper. Topics here assume familiarity with core concepts, bundles, and basic agent development. These guides help you build sophisticated AI applications, customize the kernel, and optimize performance.","title":"Advanced Topics"},{"location":"advanced/index.html#section-contents","text":"Page Description Kernel Internals How the Amplifier kernel works Custom Tools Building your own tool modules Hook Development Creating custom hooks Provider Integration Adding new LLM providers Multi-Agent Systems Complex agent orchestration Recipes Declarative multi-step workflows Performance Optimization and scaling Security Security model and best practices","title":"Section Contents"},{"location":"advanced/index.html#quick-tips","text":"Understand modules first \u2014 All advanced features build on the module system Read the source \u2014 Amplifier is open; the code is the best documentation Test in isolation \u2014 Advanced features can have subtle interactions Use typed interfaces \u2014 TypedDict and Protocol classes catch errors early Profile before optimizing \u2014 Measure actual bottlenecks, don't guess","title":"Quick Tips"},{"location":"advanced/index.html#architecture-deep-dive","text":"\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 Application Layer \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 Recipes \u2502 Multi-Agent \u2502 Custom Behaviors \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 Modules: Providers \u2502 Tools \u2502 Hooks \u2502 Custom \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 Event System \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 Kernel: Session Manager \u2502 Module Registry \u2502 Router \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Architecture Deep Dive"},{"location":"advanced/index.html#module-types","text":"Type Purpose Interface Provider LLM backends ProviderProtocol Tool Agent capabilities ToolProtocol Hook Event interception HookProtocol Context Knowledge injection ContextProtocol","title":"Module Types"},{"location":"advanced/index.html#where-to-start","text":"Want to extend Amplifier? Start with Custom Tools \u2014it's the most common extension point. Building complex workflows? Read Recipes for declarative multi-step orchestration. Optimizing performance? Check Performance for profiling and optimization strategies. Security concerns? Review Security before deploying to production.","title":"Where to Start"},{"location":"advanced/index.html#advanced-patterns","text":"Pattern Use Case Guide Tool composition Combine tools for complex ops Custom Tools Event sourcing Audit and replay Kernel Internals Agent delegation Hierarchical task distribution Multi-Agent Systems Staged execution Human-in-loop workflows Recipes","title":"Advanced Patterns"},{"location":"advanced/index.html#prerequisites","text":"Before diving into advanced topics, ensure you understand: [ ] Core concepts (sessions, agents, modules) [ ] Bundle composition and structure [ ] Basic tool usage patterns [ ] Hook event lifecycle","title":"Prerequisites"},{"location":"advanced/index.html#related-sections","text":"Concepts: Core Architecture Dev Setup: Contributing Bundles: Creating Bundles","title":"Related Sections"},{"location":"advanced/custom-bundle.html","text":"Creating Custom Bundles \u00b6 Build your own bundle to customize Amplifier for your workflow. Overview \u00b6 A custom bundle lets you: Combine existing bundles - Mix and match capabilities Add custom agents - Specialists for your domain Include context - Project-specific knowledge Set defaults - Provider, model, instructions Bundle Structure \u00b6 my-bundle/ \u251c\u2500\u2500 bundle.yaml # Main configuration \u251c\u2500\u2500 agents/ # Custom agents \u2502 \u2514\u2500\u2500 my-agent.yaml \u251c\u2500\u2500 behaviors/ # Reusable capabilities \u2502 \u2514\u2500\u2500 my-behavior.yaml \u251c\u2500\u2500 context/ # Knowledge files \u2502 \u2514\u2500\u2500 project-info.md \u2514\u2500\u2500 modules/ # Custom tools (optional) \u2514\u2500\u2500 my-tool/ Basic Bundle \u00b6 Minimal Example \u00b6 # my-bundle/bundle.yaml bundle : name : my-custom version : 1.0.0 description : My custom Amplifier configuration includes : - bundle : foundation instructions : | You are a helpful assistant for my project. Always be concise and direct. Use It \u00b6 amp --bundle ./my-bundle Including Other Bundles \u00b6 Stack Multiple Bundles \u00b6 includes : - bundle : foundation # Core tools and agents - bundle : recipes # Workflow orchestration - bundle : lsp-python # Python code intelligence From GitHub \u00b6 includes : - bundle : git+https://github.com/microsoft/amplifier-bundle-recipes@main - bundle : git+https://github.com/robotdad/amplifier-bundle-lsp-typescript@main From Local Path \u00b6 includes : - bundle : ../shared-bundle - bundle : ~/my-bundles/common Custom Agents \u00b6 Define an Agent \u00b6 # agents/api-expert.yaml meta : name : api-expert description : \"REST API design and review specialist\" # Which tools this agent can use tools : - read_file - grep - web_search # Agent's specialized knowledge instructions : | You are a REST API expert. When reviewing APIs: - Check resource naming conventions - Verify HTTP method usage - Ensure consistent error responses - Look for proper versioning Reference OpenAPI spec and REST best practices. # Optional: load additional context context : include : - ../context/api-guidelines.md Register in Bundle \u00b6 # bundle.yaml agents : - path : ./agents/api-expert.yaml - path : ./agents/db-expert.yaml Use Your Agent \u00b6 > Use api-expert to review our user endpoints Custom Context \u00b6 Add Knowledge Files \u00b6 # bundle.yaml context : include : - ./context/project-overview.md - ./context/coding-standards.md - ./context/architecture.md Context File Example \u00b6 # context/project-overview.md ## Project: Acme API This is a REST API for the Acme product catalog. ### Key Components - **Products Service** - CRUD for products - **Orders Service** - Order processing - **Auth Service** - JWT authentication ### Coding Standards - Python 3.12+ - Type hints required - Docstrings in Google style - Tests required for new code Custom Instructions \u00b6 Bundle-Level Instructions \u00b6 # bundle.yaml instructions : | You are an assistant for the Acme project. Key guidelines: - Follow our coding standards in context/coding-standards.md - Always suggest type hints - Recommend tests for new code - Use our error handling patterns Layer with Includes \u00b6 Your instructions add to included bundles: Foundation instructions (base) \u2193 Your bundle instructions (added) \u2193 Final combined instructions Behaviors \u00b6 Behaviors are reusable agent + context combinations: Define a Behavior \u00b6 # behaviors/code-review.yaml meta : name : code-review description : \"Thorough code review process\" # What this behavior adds context : include : - ./review-checklist.md # Specialized agent config agent : instructions : | When reviewing code: 1. Check for bugs and logic errors 2. Review naming and readability 3. Assess test coverage 4. Look for security issues Use in Bundle \u00b6 behaviors : - path : ./behaviors/code-review.yaml - path : ./behaviors/security-audit.yaml Provider Configuration \u00b6 Set Default Provider \u00b6 # bundle.yaml providers : - module : provider-anthropic config : model : claude-sonnet-4-20250514 max_tokens : 8192 Multiple Providers \u00b6 providers : - module : provider-anthropic config : model : claude-sonnet-4-20250514 default : true # Use this by default - module : provider-ollama config : model : llama3.1 Tools Configuration \u00b6 Add Tools \u00b6 tools : - module : tool-filesystem - module : tool-bash config : allowed_commands : [ \"ls\" , \"cat\" , \"grep\" , \"git\" ] Custom Tool Module \u00b6 tools : - module : jira-tool source : ./modules/jira-tool config : api_url : https://acme.atlassian.net Complete Example \u00b6 # bundle.yaml bundle : name : acme-dev version : 1.0.0 description : Acme project development bundle # Build on existing bundles includes : - bundle : foundation - bundle : recipes - bundle : lsp-python # Default provider providers : - module : provider-anthropic config : model : claude-sonnet-4-20250514 # Custom agents agents : - path : ./agents/api-expert.yaml - path : ./agents/db-expert.yaml # Behaviors behaviors : - path : ./behaviors/code-review.yaml # Project knowledge context : include : - ./context/project-overview.md - ./context/coding-standards.md # Custom instructions instructions : | You are an Acme project assistant. Guidelines: - Follow our coding standards - Always suggest type hints - Write tests for new code - Use project patterns from context Try It Yourself \u00b6 Exercise 1: Create Minimal Bundle \u00b6 mkdir my-bundle cat > my-bundle/bundle.yaml << 'EOF' bundle: name: my-test version: 1.0.0 includes: - bundle: foundation instructions: | Be concise. Use bullet points. EOF amp --bundle ./my-bundle Exercise 2: Add an Agent \u00b6 Create my-bundle/agents/reviewer.yaml : meta : name : reviewer description : \"Code reviewer\" instructions : | Review code for bugs and improvements. Be specific and actionable. Update bundle.yaml: agents : - path : ./agents/reviewer.yaml Test: > Use reviewer to check src/main.py Exercise 3: Add Context \u00b6 Create my-bundle/context/standards.md with your coding standards. Update bundle.yaml: context : include : - ./context/standards.md Sharing Bundles \u00b6 Via Git \u00b6 # Push to GitHub cd my-bundle git init git add . git commit -m \"Initial bundle\" gh repo create my-bundle --public git push -u origin main Others can use: amp bundle add git+https://github.com/yourusername/my-bundle@main Via Zip \u00b6 zip -r my-bundle.zip my-bundle/ # Share the zip file","title":"Custom Bundles"},{"location":"advanced/custom-bundle.html#creating-custom-bundles","text":"Build your own bundle to customize Amplifier for your workflow.","title":"Creating Custom Bundles"},{"location":"advanced/custom-bundle.html#overview","text":"A custom bundle lets you: Combine existing bundles - Mix and match capabilities Add custom agents - Specialists for your domain Include context - Project-specific knowledge Set defaults - Provider, model, instructions","title":"Overview"},{"location":"advanced/custom-bundle.html#bundle-structure","text":"my-bundle/ \u251c\u2500\u2500 bundle.yaml # Main configuration \u251c\u2500\u2500 agents/ # Custom agents \u2502 \u2514\u2500\u2500 my-agent.yaml \u251c\u2500\u2500 behaviors/ # Reusable capabilities \u2502 \u2514\u2500\u2500 my-behavior.yaml \u251c\u2500\u2500 context/ # Knowledge files \u2502 \u2514\u2500\u2500 project-info.md \u2514\u2500\u2500 modules/ # Custom tools (optional) \u2514\u2500\u2500 my-tool/","title":"Bundle Structure"},{"location":"advanced/custom-bundle.html#basic-bundle","text":"","title":"Basic Bundle"},{"location":"advanced/custom-bundle.html#minimal-example","text":"# my-bundle/bundle.yaml bundle : name : my-custom version : 1.0.0 description : My custom Amplifier configuration includes : - bundle : foundation instructions : | You are a helpful assistant for my project. Always be concise and direct.","title":"Minimal Example"},{"location":"advanced/custom-bundle.html#use-it","text":"amp --bundle ./my-bundle","title":"Use It"},{"location":"advanced/custom-bundle.html#including-other-bundles","text":"","title":"Including Other Bundles"},{"location":"advanced/custom-bundle.html#stack-multiple-bundles","text":"includes : - bundle : foundation # Core tools and agents - bundle : recipes # Workflow orchestration - bundle : lsp-python # Python code intelligence","title":"Stack Multiple Bundles"},{"location":"advanced/custom-bundle.html#from-github","text":"includes : - bundle : git+https://github.com/microsoft/amplifier-bundle-recipes@main - bundle : git+https://github.com/robotdad/amplifier-bundle-lsp-typescript@main","title":"From GitHub"},{"location":"advanced/custom-bundle.html#from-local-path","text":"includes : - bundle : ../shared-bundle - bundle : ~/my-bundles/common","title":"From Local Path"},{"location":"advanced/custom-bundle.html#custom-agents","text":"","title":"Custom Agents"},{"location":"advanced/custom-bundle.html#define-an-agent","text":"# agents/api-expert.yaml meta : name : api-expert description : \"REST API design and review specialist\" # Which tools this agent can use tools : - read_file - grep - web_search # Agent's specialized knowledge instructions : | You are a REST API expert. When reviewing APIs: - Check resource naming conventions - Verify HTTP method usage - Ensure consistent error responses - Look for proper versioning Reference OpenAPI spec and REST best practices. # Optional: load additional context context : include : - ../context/api-guidelines.md","title":"Define an Agent"},{"location":"advanced/custom-bundle.html#register-in-bundle","text":"# bundle.yaml agents : - path : ./agents/api-expert.yaml - path : ./agents/db-expert.yaml","title":"Register in Bundle"},{"location":"advanced/custom-bundle.html#use-your-agent","text":"> Use api-expert to review our user endpoints","title":"Use Your Agent"},{"location":"advanced/custom-bundle.html#custom-context","text":"","title":"Custom Context"},{"location":"advanced/custom-bundle.html#add-knowledge-files","text":"# bundle.yaml context : include : - ./context/project-overview.md - ./context/coding-standards.md - ./context/architecture.md","title":"Add Knowledge Files"},{"location":"advanced/custom-bundle.html#context-file-example","text":"# context/project-overview.md ## Project: Acme API This is a REST API for the Acme product catalog. ### Key Components - **Products Service** - CRUD for products - **Orders Service** - Order processing - **Auth Service** - JWT authentication ### Coding Standards - Python 3.12+ - Type hints required - Docstrings in Google style - Tests required for new code","title":"Context File Example"},{"location":"advanced/custom-bundle.html#custom-instructions","text":"","title":"Custom Instructions"},{"location":"advanced/custom-bundle.html#bundle-level-instructions","text":"# bundle.yaml instructions : | You are an assistant for the Acme project. Key guidelines: - Follow our coding standards in context/coding-standards.md - Always suggest type hints - Recommend tests for new code - Use our error handling patterns","title":"Bundle-Level Instructions"},{"location":"advanced/custom-bundle.html#layer-with-includes","text":"Your instructions add to included bundles: Foundation instructions (base) \u2193 Your bundle instructions (added) \u2193 Final combined instructions","title":"Layer with Includes"},{"location":"advanced/custom-bundle.html#behaviors","text":"Behaviors are reusable agent + context combinations:","title":"Behaviors"},{"location":"advanced/custom-bundle.html#define-a-behavior","text":"# behaviors/code-review.yaml meta : name : code-review description : \"Thorough code review process\" # What this behavior adds context : include : - ./review-checklist.md # Specialized agent config agent : instructions : | When reviewing code: 1. Check for bugs and logic errors 2. Review naming and readability 3. Assess test coverage 4. Look for security issues","title":"Define a Behavior"},{"location":"advanced/custom-bundle.html#use-in-bundle","text":"behaviors : - path : ./behaviors/code-review.yaml - path : ./behaviors/security-audit.yaml","title":"Use in Bundle"},{"location":"advanced/custom-bundle.html#provider-configuration","text":"","title":"Provider Configuration"},{"location":"advanced/custom-bundle.html#set-default-provider","text":"# bundle.yaml providers : - module : provider-anthropic config : model : claude-sonnet-4-20250514 max_tokens : 8192","title":"Set Default Provider"},{"location":"advanced/custom-bundle.html#multiple-providers","text":"providers : - module : provider-anthropic config : model : claude-sonnet-4-20250514 default : true # Use this by default - module : provider-ollama config : model : llama3.1","title":"Multiple Providers"},{"location":"advanced/custom-bundle.html#tools-configuration","text":"","title":"Tools Configuration"},{"location":"advanced/custom-bundle.html#add-tools","text":"tools : - module : tool-filesystem - module : tool-bash config : allowed_commands : [ \"ls\" , \"cat\" , \"grep\" , \"git\" ]","title":"Add Tools"},{"location":"advanced/custom-bundle.html#custom-tool-module","text":"tools : - module : jira-tool source : ./modules/jira-tool config : api_url : https://acme.atlassian.net","title":"Custom Tool Module"},{"location":"advanced/custom-bundle.html#complete-example","text":"# bundle.yaml bundle : name : acme-dev version : 1.0.0 description : Acme project development bundle # Build on existing bundles includes : - bundle : foundation - bundle : recipes - bundle : lsp-python # Default provider providers : - module : provider-anthropic config : model : claude-sonnet-4-20250514 # Custom agents agents : - path : ./agents/api-expert.yaml - path : ./agents/db-expert.yaml # Behaviors behaviors : - path : ./behaviors/code-review.yaml # Project knowledge context : include : - ./context/project-overview.md - ./context/coding-standards.md # Custom instructions instructions : | You are an Acme project assistant. Guidelines: - Follow our coding standards - Always suggest type hints - Write tests for new code - Use project patterns from context","title":"Complete Example"},{"location":"advanced/custom-bundle.html#try-it-yourself","text":"","title":"Try It Yourself"},{"location":"advanced/custom-bundle.html#exercise-1-create-minimal-bundle","text":"mkdir my-bundle cat > my-bundle/bundle.yaml << 'EOF' bundle: name: my-test version: 1.0.0 includes: - bundle: foundation instructions: | Be concise. Use bullet points. EOF amp --bundle ./my-bundle","title":"Exercise 1: Create Minimal Bundle"},{"location":"advanced/custom-bundle.html#exercise-2-add-an-agent","text":"Create my-bundle/agents/reviewer.yaml : meta : name : reviewer description : \"Code reviewer\" instructions : | Review code for bugs and improvements. Be specific and actionable. Update bundle.yaml: agents : - path : ./agents/reviewer.yaml Test: > Use reviewer to check src/main.py","title":"Exercise 2: Add an Agent"},{"location":"advanced/custom-bundle.html#exercise-3-add-context","text":"Create my-bundle/context/standards.md with your coding standards. Update bundle.yaml: context : include : - ./context/standards.md","title":"Exercise 3: Add Context"},{"location":"advanced/custom-bundle.html#sharing-bundles","text":"","title":"Sharing Bundles"},{"location":"advanced/custom-bundle.html#via-git","text":"# Push to GitHub cd my-bundle git init git add . git commit -m \"Initial bundle\" gh repo create my-bundle --public git push -u origin main Others can use: amp bundle add git+https://github.com/yourusername/my-bundle@main","title":"Via Git"},{"location":"advanced/custom-bundle.html#via-zip","text":"zip -r my-bundle.zip my-bundle/ # Share the zip file","title":"Via Zip"},{"location":"advanced/custom-recipe.html","text":"Creating Custom Recipes \u00b6 Build multi-step workflows that orchestrate agents. Overview \u00b6 Recipes let you: Orchestrate agents - Chain specialists together Create repeatable workflows - Run the same process consistently Add approval gates - Human-in-the-loop checkpoints Handle complex flows - Loops, conditions, parallel execution Recipe Structure \u00b6 # my-recipe.yaml name : my-workflow description : What this recipe does # Input variables context : input_var : \"\" # Required (no default) optional_var : \"default\" # Optional (has default) # Workflow steps steps : - id : step-one instruction : \"Do the first thing with {{input_var}}\" - id : step-two agent : foundation:zen-architect instruction : | Based on: {{step-one.result}} Do the second thing. Basic Recipe \u00b6 Simple Two-Step Recipe \u00b6 name : explain-and-improve description : Explain code then suggest improvements context : file : \"\" steps : - id : explain instruction : \"Explain what {{file}} does in plain language\" - id : improve instruction : | Based on this understanding: {{explain.result}} Suggest 3 improvements for {{file}} Run It \u00b6 amp recipes execute explain-and-improve.yaml \\ --context '{\"file\": \"src/auth.py\"}' Using Agents \u00b6 Specify Agent for Step \u00b6 steps : - id : design agent : foundation:zen-architect instruction : \"Design a solution for {{problem}}\" - id : implement agent : foundation:modular-builder instruction : | Implement the design: {{design.result}} - id : review agent : foundation:security-guardian instruction : \"Review the implementation for security issues\" Context Variables \u00b6 Input Variables \u00b6 context : # Required - must be provided target_file : \"\" # Optional - has default value depth : \"standard\" include_tests : true Access Variables \u00b6 instruction : | Review {{target_file}} with {{depth}} depth. {{#if include_tests}}Include test analysis.{{/if}} Step Results \u00b6 Each step's output is available to later steps: steps : - id : analyze instruction : \"Analyze the code\" - id : report instruction : | Previous analysis: {{analyze.result}} Create a summary report. Approval Gates \u00b6 Require Human Approval \u00b6 steps : - id : plan instruction : \"Create a migration plan\" - id : confirm requires_approval : true instruction : \"Review the plan before proceeding\" - id : execute instruction : \"Execute the migration: {{plan.result}}\" Approval Commands \u00b6 # Check pending approvals amp recipes approvals # Approve amp recipes approve [ session-id ] [ step-id ] # Deny amp recipes deny [ session-id ] [ step-id ] --reason \"Need changes\" Advanced Features \u00b6 Loops (foreach) \u00b6 steps : - id : get-files instruction : \"List all Python files in src/\" parse_json : true - id : review-each foreach : \"{{get-files.result.files}}\" instruction : \"Review {{item}} for issues\" Parallel Execution \u00b6 steps : - id : parallel-reviews foreach : \"{{files}}\" parallel : 3 # Run 3 at a time instruction : \"Review {{item}}\" Conditional Steps \u00b6 steps : - id : check instruction : \"Does {{file}} have tests?\" parse_json : true - id : write-tests condition : \"{{check.result.has_tests}} == false\" instruction : \"Write tests for {{file}}\" Error Handling \u00b6 steps : - id : risky-step instruction : \"Try something that might fail\" on_error : continue # Don't stop on failure - id : handle-error condition : \"{{risky-step.status}} == 'error'\" instruction : \"Handle the error: {{risky-step.error}}\" Complete Examples \u00b6 Code Review Recipe \u00b6 name : code-review description : Comprehensive code review with multiple specialists context : file_path : \"\" review_depth : \"standard\" steps : - id : design-review agent : foundation:zen-architect instruction : | Review {{file_path}} for design issues: - Architecture patterns - Code organization - Complexity Depth: {{review_depth}} - id : security-review agent : foundation:security-guardian instruction : | Review {{file_path}} for security issues: - Input validation - Authentication/authorization - Data handling - id : test-review agent : foundation:test-coverage instruction : | Analyze test coverage for {{file_path}}: - Existing tests - Missing coverage - Test quality - id : final-report instruction : | Create a code review report combining: ## Design Review {{design-review.result}} ## Security Review {{security-review.result}} ## Test Coverage {{test-review.result}} Include: - Summary of findings - Priority-ordered action items - Overall assessment Deployment Recipe with Approval \u00b6 name : deploy description : Deploy to staging with approval gate context : environment : \"staging\" version : \"\" steps : - id : build instruction : \"Build version {{version}}\" - id : test instruction : \"Run full test suite\" - id : pre-deploy-check instruction : | Verify deployment readiness: - Build: {{build.result}} - Tests: {{test.result}} List any blockers. - id : approve-deploy requires_approval : true instruction : | Ready to deploy {{version}} to {{environment}}. Pre-check results: {{pre-deploy-check.result}} - id : deploy instruction : \"Deploy {{version}} to {{environment}}\" - id : verify instruction : \"Verify deployment health\" Recipe Validation \u00b6 Check your recipe before running: amp recipes validate my-recipe.yaml Common validation errors: Error Solution Invalid YAML syntax Check indentation, quotes Unknown agent Verify agent name Missing context var Add to context section Circular reference Check step dependencies Recipe Author Agent \u00b6 Get help creating recipes: > Help me create a recipe for database migration The recipe-author agent will: - Ask clarifying questions - Suggest best structure - Generate valid YAML - Add error handling Try It Yourself \u00b6 Exercise 1: Simple Recipe \u00b6 # hello-recipe.yaml name : hello description : Simple greeting recipe context : name : \"\" steps : - id : greet instruction : \"Say hello to {{name}}\" amp recipes execute hello-recipe.yaml --context '{\"name\": \"World\"}' Exercise 2: Multi-Step Recipe \u00b6 Create a recipe that: 1. Reads a file 2. Explains it 3. Suggests improvements Exercise 3: Add Approval Gate \u00b6 Add an approval step before making changes. Best Practices \u00b6 Clear step IDs - Use descriptive names like analyze-deps not step1 One responsibility per step - Keep steps focused Use appropriate agents - Match agent specialty to task Add approval gates - For destructive or important operations Handle errors - Use on_error for steps that might fail Document context - Make required inputs clear","title":"Custom Recipes"},{"location":"advanced/custom-recipe.html#creating-custom-recipes","text":"Build multi-step workflows that orchestrate agents.","title":"Creating Custom Recipes"},{"location":"advanced/custom-recipe.html#overview","text":"Recipes let you: Orchestrate agents - Chain specialists together Create repeatable workflows - Run the same process consistently Add approval gates - Human-in-the-loop checkpoints Handle complex flows - Loops, conditions, parallel execution","title":"Overview"},{"location":"advanced/custom-recipe.html#recipe-structure","text":"# my-recipe.yaml name : my-workflow description : What this recipe does # Input variables context : input_var : \"\" # Required (no default) optional_var : \"default\" # Optional (has default) # Workflow steps steps : - id : step-one instruction : \"Do the first thing with {{input_var}}\" - id : step-two agent : foundation:zen-architect instruction : | Based on: {{step-one.result}} Do the second thing.","title":"Recipe Structure"},{"location":"advanced/custom-recipe.html#basic-recipe","text":"","title":"Basic Recipe"},{"location":"advanced/custom-recipe.html#simple-two-step-recipe","text":"name : explain-and-improve description : Explain code then suggest improvements context : file : \"\" steps : - id : explain instruction : \"Explain what {{file}} does in plain language\" - id : improve instruction : | Based on this understanding: {{explain.result}} Suggest 3 improvements for {{file}}","title":"Simple Two-Step Recipe"},{"location":"advanced/custom-recipe.html#run-it","text":"amp recipes execute explain-and-improve.yaml \\ --context '{\"file\": \"src/auth.py\"}'","title":"Run It"},{"location":"advanced/custom-recipe.html#using-agents","text":"","title":"Using Agents"},{"location":"advanced/custom-recipe.html#specify-agent-for-step","text":"steps : - id : design agent : foundation:zen-architect instruction : \"Design a solution for {{problem}}\" - id : implement agent : foundation:modular-builder instruction : | Implement the design: {{design.result}} - id : review agent : foundation:security-guardian instruction : \"Review the implementation for security issues\"","title":"Specify Agent for Step"},{"location":"advanced/custom-recipe.html#context-variables","text":"","title":"Context Variables"},{"location":"advanced/custom-recipe.html#input-variables","text":"context : # Required - must be provided target_file : \"\" # Optional - has default value depth : \"standard\" include_tests : true","title":"Input Variables"},{"location":"advanced/custom-recipe.html#access-variables","text":"instruction : | Review {{target_file}} with {{depth}} depth. {{#if include_tests}}Include test analysis.{{/if}}","title":"Access Variables"},{"location":"advanced/custom-recipe.html#step-results","text":"Each step's output is available to later steps: steps : - id : analyze instruction : \"Analyze the code\" - id : report instruction : | Previous analysis: {{analyze.result}} Create a summary report.","title":"Step Results"},{"location":"advanced/custom-recipe.html#approval-gates","text":"","title":"Approval Gates"},{"location":"advanced/custom-recipe.html#require-human-approval","text":"steps : - id : plan instruction : \"Create a migration plan\" - id : confirm requires_approval : true instruction : \"Review the plan before proceeding\" - id : execute instruction : \"Execute the migration: {{plan.result}}\"","title":"Require Human Approval"},{"location":"advanced/custom-recipe.html#approval-commands","text":"# Check pending approvals amp recipes approvals # Approve amp recipes approve [ session-id ] [ step-id ] # Deny amp recipes deny [ session-id ] [ step-id ] --reason \"Need changes\"","title":"Approval Commands"},{"location":"advanced/custom-recipe.html#advanced-features","text":"","title":"Advanced Features"},{"location":"advanced/custom-recipe.html#loops-foreach","text":"steps : - id : get-files instruction : \"List all Python files in src/\" parse_json : true - id : review-each foreach : \"{{get-files.result.files}}\" instruction : \"Review {{item}} for issues\"","title":"Loops (foreach)"},{"location":"advanced/custom-recipe.html#parallel-execution","text":"steps : - id : parallel-reviews foreach : \"{{files}}\" parallel : 3 # Run 3 at a time instruction : \"Review {{item}}\"","title":"Parallel Execution"},{"location":"advanced/custom-recipe.html#conditional-steps","text":"steps : - id : check instruction : \"Does {{file}} have tests?\" parse_json : true - id : write-tests condition : \"{{check.result.has_tests}} == false\" instruction : \"Write tests for {{file}}\"","title":"Conditional Steps"},{"location":"advanced/custom-recipe.html#error-handling","text":"steps : - id : risky-step instruction : \"Try something that might fail\" on_error : continue # Don't stop on failure - id : handle-error condition : \"{{risky-step.status}} == 'error'\" instruction : \"Handle the error: {{risky-step.error}}\"","title":"Error Handling"},{"location":"advanced/custom-recipe.html#complete-examples","text":"","title":"Complete Examples"},{"location":"advanced/custom-recipe.html#code-review-recipe","text":"name : code-review description : Comprehensive code review with multiple specialists context : file_path : \"\" review_depth : \"standard\" steps : - id : design-review agent : foundation:zen-architect instruction : | Review {{file_path}} for design issues: - Architecture patterns - Code organization - Complexity Depth: {{review_depth}} - id : security-review agent : foundation:security-guardian instruction : | Review {{file_path}} for security issues: - Input validation - Authentication/authorization - Data handling - id : test-review agent : foundation:test-coverage instruction : | Analyze test coverage for {{file_path}}: - Existing tests - Missing coverage - Test quality - id : final-report instruction : | Create a code review report combining: ## Design Review {{design-review.result}} ## Security Review {{security-review.result}} ## Test Coverage {{test-review.result}} Include: - Summary of findings - Priority-ordered action items - Overall assessment","title":"Code Review Recipe"},{"location":"advanced/custom-recipe.html#deployment-recipe-with-approval","text":"name : deploy description : Deploy to staging with approval gate context : environment : \"staging\" version : \"\" steps : - id : build instruction : \"Build version {{version}}\" - id : test instruction : \"Run full test suite\" - id : pre-deploy-check instruction : | Verify deployment readiness: - Build: {{build.result}} - Tests: {{test.result}} List any blockers. - id : approve-deploy requires_approval : true instruction : | Ready to deploy {{version}} to {{environment}}. Pre-check results: {{pre-deploy-check.result}} - id : deploy instruction : \"Deploy {{version}} to {{environment}}\" - id : verify instruction : \"Verify deployment health\"","title":"Deployment Recipe with Approval"},{"location":"advanced/custom-recipe.html#recipe-validation","text":"Check your recipe before running: amp recipes validate my-recipe.yaml Common validation errors: Error Solution Invalid YAML syntax Check indentation, quotes Unknown agent Verify agent name Missing context var Add to context section Circular reference Check step dependencies","title":"Recipe Validation"},{"location":"advanced/custom-recipe.html#recipe-author-agent","text":"Get help creating recipes: > Help me create a recipe for database migration The recipe-author agent will: - Ask clarifying questions - Suggest best structure - Generate valid YAML - Add error handling","title":"Recipe Author Agent"},{"location":"advanced/custom-recipe.html#try-it-yourself","text":"","title":"Try It Yourself"},{"location":"advanced/custom-recipe.html#exercise-1-simple-recipe","text":"# hello-recipe.yaml name : hello description : Simple greeting recipe context : name : \"\" steps : - id : greet instruction : \"Say hello to {{name}}\" amp recipes execute hello-recipe.yaml --context '{\"name\": \"World\"}'","title":"Exercise 1: Simple Recipe"},{"location":"advanced/custom-recipe.html#exercise-2-multi-step-recipe","text":"Create a recipe that: 1. Reads a file 2. Explains it 3. Suggests improvements","title":"Exercise 2: Multi-Step Recipe"},{"location":"advanced/custom-recipe.html#exercise-3-add-approval-gate","text":"Add an approval step before making changes.","title":"Exercise 3: Add Approval Gate"},{"location":"advanced/custom-recipe.html#best-practices","text":"Clear step IDs - Use descriptive names like analyze-deps not step1 One responsibility per step - Keep steps focused Use appropriate agents - Match agent specialty to task Add approval gates - For destructive or important operations Handle errors - Use on_error for steps that might fail Document context - Make required inputs clear","title":"Best Practices"},{"location":"advanced/custom-tool.html","text":"Creating Custom Tools \u00b6 Extend Amplifier with your own tools. Overview \u00b6 Custom tools let you: Add new capabilities - Integrate with any system Wrap existing CLIs - Make tools AI-friendly Connect to APIs - Custom integrations Automate workflows - Complex operations as single tools Tool Structure \u00b6 A tool is a Python module that implements the Tool protocol: # my_tool.py from amplifier_core import Tool class MyTool ( Tool ): name = \"my-tool\" description = \"What this tool does (shown to AI)\" input_schema = { \"type\" : \"object\" , \"properties\" : { \"param1\" : { \"type\" : \"string\" , \"description\" : \"First parameter\" } }, \"required\" : [ \"param1\" ] } async def execute ( self , input : dict ) -> str : param1 = input [ \"param1\" ] # Do something return f \"Result: { param1 } \" Basic Example: Timestamp Tool \u00b6 # modules/timestamp_tool/tool.py from datetime import datetime from amplifier_core import Tool class TimestampTool ( Tool ): name = \"timestamp\" description = \"Get the current timestamp in various formats\" input_schema = { \"type\" : \"object\" , \"properties\" : { \"format\" : { \"type\" : \"string\" , \"description\" : \"Output format: iso, unix, or human\" , \"enum\" : [ \"iso\" , \"unix\" , \"human\" ], \"default\" : \"iso\" } } } async def execute ( self , input : dict ) -> str : fmt = input . get ( \"format\" , \"iso\" ) now = datetime . now () if fmt == \"iso\" : return now . isoformat () elif fmt == \"unix\" : return str ( int ( now . timestamp ())) else : return now . strftime ( \"%B %d , %Y at %I:%M %p\" ) Register in Bundle \u00b6 # bundle.yaml tools : - module : timestamp-tool source : ./modules/timestamp_tool API Integration Example \u00b6 # modules/weather_tool/tool.py import httpx from amplifier_core import Tool class WeatherTool ( Tool ): name = \"weather\" description = \"Get current weather for a location\" input_schema = { \"type\" : \"object\" , \"properties\" : { \"city\" : { \"type\" : \"string\" , \"description\" : \"City name\" } }, \"required\" : [ \"city\" ] } def __init__ ( self , config : dict = None ): self . api_key = config . get ( \"api_key\" ) if config else None async def execute ( self , input : dict ) -> str : city = input [ \"city\" ] async with httpx . AsyncClient () as client : response = await client . get ( f \"https://api.weather.example.com/current\" , params = { \"city\" : city , \"key\" : self . api_key } ) data = response . json () return f \"Weather in { city } : { data [ 'temp' ] } \u00b0F, { data [ 'condition' ] } \" Configure with API key: tools : - module : weather-tool source : ./modules/weather_tool config : api_key : ${WEATHER_API_KEY} CLI Wrapper Example \u00b6 Wrap an existing CLI tool: # modules/docker_tool/tool.py import subprocess import json from amplifier_core import Tool class DockerTool ( Tool ): name = \"docker\" description = \"Manage Docker containers\" input_schema = { \"type\" : \"object\" , \"properties\" : { \"action\" : { \"type\" : \"string\" , \"enum\" : [ \"list\" , \"start\" , \"stop\" , \"logs\" ], \"description\" : \"Action to perform\" }, \"container\" : { \"type\" : \"string\" , \"description\" : \"Container name/ID (for start/stop/logs)\" } }, \"required\" : [ \"action\" ] } async def execute ( self , input : dict ) -> str : action = input [ \"action\" ] container = input . get ( \"container\" ) if action == \"list\" : result = subprocess . run ( [ \"docker\" , \"ps\" , \"--format\" , \"json\" ], capture_output = True , text = True ) return result . stdout elif action == \"start\" : result = subprocess . run ( [ \"docker\" , \"start\" , container ], capture_output = True , text = True ) return f \"Started { container } \" if result . returncode == 0 else result . stderr elif action == \"stop\" : result = subprocess . run ( [ \"docker\" , \"stop\" , container ], capture_output = True , text = True ) return f \"Stopped { container } \" if result . returncode == 0 else result . stderr elif action == \"logs\" : result = subprocess . run ( [ \"docker\" , \"logs\" , \"--tail\" , \"50\" , container ], capture_output = True , text = True ) return result . stdout or result . stderr Input Schema \u00b6 Define what the AI can pass to your tool: input_schema = { \"type\" : \"object\" , \"properties\" : { # Required string \"name\" : { \"type\" : \"string\" , \"description\" : \"User's name\" }, # Optional with default \"count\" : { \"type\" : \"integer\" , \"description\" : \"Number of items\" , \"default\" : 10 }, # Enum (limited choices) \"format\" : { \"type\" : \"string\" , \"enum\" : [ \"json\" , \"csv\" , \"xml\" ], \"description\" : \"Output format\" }, # Boolean \"verbose\" : { \"type\" : \"boolean\" , \"description\" : \"Show detailed output\" , \"default\" : False }, # Array \"tags\" : { \"type\" : \"array\" , \"items\" : { \"type\" : \"string\" }, \"description\" : \"List of tags\" } }, \"required\" : [ \"name\" ] # Which params are required } Error Handling \u00b6 Return clear error messages: async def execute ( self , input : dict ) -> str : try : result = self . do_something ( input ) return result except FileNotFoundError as e : return f \"Error: File not found - { e } \" except PermissionError as e : return f \"Error: Permission denied - { e } \" except Exception as e : return f \"Error: { type ( e ) . __name__ } - { e } \" Async Operations \u00b6 For I/O-bound operations, use async: import httpx async def execute ( self , input : dict ) -> str : async with httpx . AsyncClient () as client : response = await client . get ( input [ \"url\" ]) return response . text Configuration \u00b6 Tools can accept configuration: class MyTool ( Tool ): def __init__ ( self , config : dict = None ): config = config or {} self . api_key = config . get ( \"api_key\" ) self . base_url = config . get ( \"base_url\" , \"https://api.example.com\" ) tools : - module : my-tool source : ./modules/my_tool config : api_key : ${API_KEY} base_url : https://api.custom.com Module Structure \u00b6 modules/my_tool/ \u251c\u2500\u2500 __init__.py # Export the tool class \u251c\u2500\u2500 tool.py # Tool implementation \u2514\u2500\u2500 pyproject.toml # Dependencies (optional) __init__.py : from .tool import MyTool __all__ = [ \"MyTool\" ] Try It Yourself \u00b6 Exercise 1: Simple Tool \u00b6 Create modules/greet/tool.py : from amplifier_core import Tool class GreetTool ( Tool ): name = \"greet\" description = \"Generate a greeting\" input_schema = { \"type\" : \"object\" , \"properties\" : { \"name\" : { \"type\" : \"string\" , \"description\" : \"Name to greet\" } }, \"required\" : [ \"name\" ] } async def execute ( self , input : dict ) -> str : return f \"Hello, { input [ 'name' ] } ! Welcome to Amplifier.\" Add to bundle and test: > Use the greet tool to greet Alice Exercise 2: CLI Wrapper \u00b6 Wrap a CLI tool you use frequently (git, kubectl, etc.). Exercise 3: API Integration \u00b6 Create a tool that calls an API you work with. Best Practices \u00b6 Clear descriptions - Help the AI know when to use your tool Specific schemas - Use enums and defaults where appropriate Good error messages - Return actionable error info Async when possible - Don't block on I/O Minimal dependencies - Keep tools lightweight","title":"Custom Tools"},{"location":"advanced/custom-tool.html#creating-custom-tools","text":"Extend Amplifier with your own tools.","title":"Creating Custom Tools"},{"location":"advanced/custom-tool.html#overview","text":"Custom tools let you: Add new capabilities - Integrate with any system Wrap existing CLIs - Make tools AI-friendly Connect to APIs - Custom integrations Automate workflows - Complex operations as single tools","title":"Overview"},{"location":"advanced/custom-tool.html#tool-structure","text":"A tool is a Python module that implements the Tool protocol: # my_tool.py from amplifier_core import Tool class MyTool ( Tool ): name = \"my-tool\" description = \"What this tool does (shown to AI)\" input_schema = { \"type\" : \"object\" , \"properties\" : { \"param1\" : { \"type\" : \"string\" , \"description\" : \"First parameter\" } }, \"required\" : [ \"param1\" ] } async def execute ( self , input : dict ) -> str : param1 = input [ \"param1\" ] # Do something return f \"Result: { param1 } \"","title":"Tool Structure"},{"location":"advanced/custom-tool.html#basic-example-timestamp-tool","text":"# modules/timestamp_tool/tool.py from datetime import datetime from amplifier_core import Tool class TimestampTool ( Tool ): name = \"timestamp\" description = \"Get the current timestamp in various formats\" input_schema = { \"type\" : \"object\" , \"properties\" : { \"format\" : { \"type\" : \"string\" , \"description\" : \"Output format: iso, unix, or human\" , \"enum\" : [ \"iso\" , \"unix\" , \"human\" ], \"default\" : \"iso\" } } } async def execute ( self , input : dict ) -> str : fmt = input . get ( \"format\" , \"iso\" ) now = datetime . now () if fmt == \"iso\" : return now . isoformat () elif fmt == \"unix\" : return str ( int ( now . timestamp ())) else : return now . strftime ( \"%B %d , %Y at %I:%M %p\" )","title":"Basic Example: Timestamp Tool"},{"location":"advanced/custom-tool.html#register-in-bundle","text":"# bundle.yaml tools : - module : timestamp-tool source : ./modules/timestamp_tool","title":"Register in Bundle"},{"location":"advanced/custom-tool.html#api-integration-example","text":"# modules/weather_tool/tool.py import httpx from amplifier_core import Tool class WeatherTool ( Tool ): name = \"weather\" description = \"Get current weather for a location\" input_schema = { \"type\" : \"object\" , \"properties\" : { \"city\" : { \"type\" : \"string\" , \"description\" : \"City name\" } }, \"required\" : [ \"city\" ] } def __init__ ( self , config : dict = None ): self . api_key = config . get ( \"api_key\" ) if config else None async def execute ( self , input : dict ) -> str : city = input [ \"city\" ] async with httpx . AsyncClient () as client : response = await client . get ( f \"https://api.weather.example.com/current\" , params = { \"city\" : city , \"key\" : self . api_key } ) data = response . json () return f \"Weather in { city } : { data [ 'temp' ] } \u00b0F, { data [ 'condition' ] } \" Configure with API key: tools : - module : weather-tool source : ./modules/weather_tool config : api_key : ${WEATHER_API_KEY}","title":"API Integration Example"},{"location":"advanced/custom-tool.html#cli-wrapper-example","text":"Wrap an existing CLI tool: # modules/docker_tool/tool.py import subprocess import json from amplifier_core import Tool class DockerTool ( Tool ): name = \"docker\" description = \"Manage Docker containers\" input_schema = { \"type\" : \"object\" , \"properties\" : { \"action\" : { \"type\" : \"string\" , \"enum\" : [ \"list\" , \"start\" , \"stop\" , \"logs\" ], \"description\" : \"Action to perform\" }, \"container\" : { \"type\" : \"string\" , \"description\" : \"Container name/ID (for start/stop/logs)\" } }, \"required\" : [ \"action\" ] } async def execute ( self , input : dict ) -> str : action = input [ \"action\" ] container = input . get ( \"container\" ) if action == \"list\" : result = subprocess . run ( [ \"docker\" , \"ps\" , \"--format\" , \"json\" ], capture_output = True , text = True ) return result . stdout elif action == \"start\" : result = subprocess . run ( [ \"docker\" , \"start\" , container ], capture_output = True , text = True ) return f \"Started { container } \" if result . returncode == 0 else result . stderr elif action == \"stop\" : result = subprocess . run ( [ \"docker\" , \"stop\" , container ], capture_output = True , text = True ) return f \"Stopped { container } \" if result . returncode == 0 else result . stderr elif action == \"logs\" : result = subprocess . run ( [ \"docker\" , \"logs\" , \"--tail\" , \"50\" , container ], capture_output = True , text = True ) return result . stdout or result . stderr","title":"CLI Wrapper Example"},{"location":"advanced/custom-tool.html#input-schema","text":"Define what the AI can pass to your tool: input_schema = { \"type\" : \"object\" , \"properties\" : { # Required string \"name\" : { \"type\" : \"string\" , \"description\" : \"User's name\" }, # Optional with default \"count\" : { \"type\" : \"integer\" , \"description\" : \"Number of items\" , \"default\" : 10 }, # Enum (limited choices) \"format\" : { \"type\" : \"string\" , \"enum\" : [ \"json\" , \"csv\" , \"xml\" ], \"description\" : \"Output format\" }, # Boolean \"verbose\" : { \"type\" : \"boolean\" , \"description\" : \"Show detailed output\" , \"default\" : False }, # Array \"tags\" : { \"type\" : \"array\" , \"items\" : { \"type\" : \"string\" }, \"description\" : \"List of tags\" } }, \"required\" : [ \"name\" ] # Which params are required }","title":"Input Schema"},{"location":"advanced/custom-tool.html#error-handling","text":"Return clear error messages: async def execute ( self , input : dict ) -> str : try : result = self . do_something ( input ) return result except FileNotFoundError as e : return f \"Error: File not found - { e } \" except PermissionError as e : return f \"Error: Permission denied - { e } \" except Exception as e : return f \"Error: { type ( e ) . __name__ } - { e } \"","title":"Error Handling"},{"location":"advanced/custom-tool.html#async-operations","text":"For I/O-bound operations, use async: import httpx async def execute ( self , input : dict ) -> str : async with httpx . AsyncClient () as client : response = await client . get ( input [ \"url\" ]) return response . text","title":"Async Operations"},{"location":"advanced/custom-tool.html#configuration","text":"Tools can accept configuration: class MyTool ( Tool ): def __init__ ( self , config : dict = None ): config = config or {} self . api_key = config . get ( \"api_key\" ) self . base_url = config . get ( \"base_url\" , \"https://api.example.com\" ) tools : - module : my-tool source : ./modules/my_tool config : api_key : ${API_KEY} base_url : https://api.custom.com","title":"Configuration"},{"location":"advanced/custom-tool.html#module-structure","text":"modules/my_tool/ \u251c\u2500\u2500 __init__.py # Export the tool class \u251c\u2500\u2500 tool.py # Tool implementation \u2514\u2500\u2500 pyproject.toml # Dependencies (optional) __init__.py : from .tool import MyTool __all__ = [ \"MyTool\" ]","title":"Module Structure"},{"location":"advanced/custom-tool.html#try-it-yourself","text":"","title":"Try It Yourself"},{"location":"advanced/custom-tool.html#exercise-1-simple-tool","text":"Create modules/greet/tool.py : from amplifier_core import Tool class GreetTool ( Tool ): name = \"greet\" description = \"Generate a greeting\" input_schema = { \"type\" : \"object\" , \"properties\" : { \"name\" : { \"type\" : \"string\" , \"description\" : \"Name to greet\" } }, \"required\" : [ \"name\" ] } async def execute ( self , input : dict ) -> str : return f \"Hello, { input [ 'name' ] } ! Welcome to Amplifier.\" Add to bundle and test: > Use the greet tool to greet Alice","title":"Exercise 1: Simple Tool"},{"location":"advanced/custom-tool.html#exercise-2-cli-wrapper","text":"Wrap a CLI tool you use frequently (git, kubectl, etc.).","title":"Exercise 2: CLI Wrapper"},{"location":"advanced/custom-tool.html#exercise-3-api-integration","text":"Create a tool that calls an API you work with.","title":"Exercise 3: API Integration"},{"location":"advanced/custom-tool.html#best-practices","text":"Clear descriptions - Help the AI know when to use your tool Specific schemas - Use enums and defaults where appropriate Good error messages - Return actionable error info Async when possible - Don't block on I/O Minimal dependencies - Keep tools lightweight","title":"Best Practices"},{"location":"advanced/mcp-integration.html","text":"MCP Integration \u00b6 Connect Amplifier to Model Context Protocol servers. Overview \u00b6 MCP (Model Context Protocol) is a standard for connecting AI assistants to external tools and data sources. Amplifier supports MCP servers, letting you: Connect to databases - Query and modify data Access APIs - Any service with MCP support Use external tools - Capabilities from MCP ecosystem Share tools - Same server works with multiple clients What is MCP? \u00b6 MCP separates: - Client - The AI assistant (Amplifier) - Server - Provider of tools/resources Amplifier (Client) \u2190\u2192 MCP Server \u2190\u2192 External System Benefits: - Standard protocol - Reusable servers - Ecosystem of tools - Works with multiple AI clients Configuring MCP Servers \u00b6 In Settings \u00b6 # ~/.amplifier/settings.yaml mcp : servers : - name : filesystem command : npx @modelcontextprotocol/server-filesystem args : [ \"/allowed/path\" ] - name : postgres command : npx @modelcontextprotocol/server-postgres env : DATABASE_URL : \"postgresql://user:pass@localhost/db\" In Bundle \u00b6 # bundle.yaml mcp : servers : - name : my-server command : python my_server.py Available MCP Servers \u00b6 Official Servers \u00b6 Server Purpose @modelcontextprotocol/server-filesystem File operations @modelcontextprotocol/server-postgres PostgreSQL queries @modelcontextprotocol/server-sqlite SQLite databases @modelcontextprotocol/server-github GitHub API Installing Servers \u00b6 # Via npm npm install -g @modelcontextprotocol/server-filesystem npm install -g @modelcontextprotocol/server-postgres # Via pip pip install mcp-server-fetch Example: Filesystem Server \u00b6 Configure \u00b6 mcp : servers : - name : files command : npx @modelcontextprotocol/server-filesystem args : [ \"/home/user/projects\" ] Use \u00b6 The server adds tools that Amplifier can use: > List files in /home/user/projects > Read the contents of package.json Example: Database Server \u00b6 Configure \u00b6 mcp : servers : - name : database command : npx @modelcontextprotocol/server-postgres env : DATABASE_URL : \"postgresql://localhost/mydb\" Use \u00b6 > Show all tables in the database > Query the users table for active users > Count orders from last week Example: GitHub Server \u00b6 Configure \u00b6 mcp : servers : - name : github command : npx @modelcontextprotocol/server-github env : GITHUB_TOKEN : ${GITHUB_TOKEN} Use \u00b6 > List open PRs in microsoft/amplifier > Get details of issue #123 > Show my recent commits Creating MCP Servers \u00b6 Python Server \u00b6 # my_server.py from mcp.server import Server from mcp.types import Tool , TextContent server = Server ( \"my-server\" ) @server . tool () async def get_weather ( city : str ) -> str : \"\"\"Get weather for a city\"\"\" # Implementation return f \"Weather in { city } : Sunny, 72\u00b0F\" @server . tool () async def search_docs ( query : str ) -> str : \"\"\"Search internal documentation\"\"\" # Implementation return f \"Found 5 results for: { query } \" if __name__ == \"__main__\" : server . run () Register \u00b6 mcp : servers : - name : my-tools command : python my_server.py MCP Resources \u00b6 MCP servers can also provide resources (data): @server . resource ( \"docs:// {path} \" ) async def get_doc ( path : str ) -> str : \"\"\"Get documentation by path\"\"\" with open ( f \"/docs/ { path } \" ) as f : return f . read () Access in Amplifier: > Get the resource docs://api/auth.md Debugging MCP \u00b6 Test Server Directly \u00b6 # Run server npx @modelcontextprotocol/server-filesystem /tmp # In another terminal, test with mcp CLI mcp test-server filesystem Check Logs \u00b6 # Amplifier logs MCP communication export AMPLIFIER_LOG_LEVEL = debug amp Common Issues \u00b6 Server not starting: - Check command path - Verify dependencies installed - Check environment variables Tools not appearing: - Restart Amplifier - Verify server is running - Check server logs Permission errors: - Check allowed paths - Verify credentials - Check environment setup Security Considerations \u00b6 Principle of Least Privilege \u00b6 mcp : servers : # Good - limited scope - name : project-files command : npx @modelcontextprotocol/server-filesystem args : [ \"/home/user/current-project\" ] # Avoid - too broad - name : all-files command : npx @modelcontextprotocol/server-filesystem args : [ \"/\" ] # Don't do this! Credential Management \u00b6 mcp : servers : - name : database command : npx @modelcontextprotocol/server-postgres env : # Use environment variable, not hardcoded DATABASE_URL : ${DATABASE_URL} Audit MCP Actions \u00b6 MCP tool calls appear in session logs: cat events.jsonl | jq 'select(.tool_name | startswith(\"mcp:\"))' Try It Yourself \u00b6 Exercise 1: Filesystem Server \u00b6 # Add to ~/.amplifier/settings.yaml mcp : servers : - name : files command : npx @modelcontextprotocol/server-filesystem args : [ \"./\" ] npm install -g @modelcontextprotocol/server-filesystem amp > What files are in this directory? Exercise 2: SQLite Server \u00b6 mcp : servers : - name : db command : npx @modelcontextprotocol/server-sqlite args : [ \"./test.db\" ] > Create a users table > Insert some test data > Query all users Resources \u00b6 MCP Specification Official Servers Python SDK TypeScript SDK","title":"MCP Integration"},{"location":"advanced/mcp-integration.html#mcp-integration","text":"Connect Amplifier to Model Context Protocol servers.","title":"MCP Integration"},{"location":"advanced/mcp-integration.html#overview","text":"MCP (Model Context Protocol) is a standard for connecting AI assistants to external tools and data sources. Amplifier supports MCP servers, letting you: Connect to databases - Query and modify data Access APIs - Any service with MCP support Use external tools - Capabilities from MCP ecosystem Share tools - Same server works with multiple clients","title":"Overview"},{"location":"advanced/mcp-integration.html#what-is-mcp","text":"MCP separates: - Client - The AI assistant (Amplifier) - Server - Provider of tools/resources Amplifier (Client) \u2190\u2192 MCP Server \u2190\u2192 External System Benefits: - Standard protocol - Reusable servers - Ecosystem of tools - Works with multiple AI clients","title":"What is MCP?"},{"location":"advanced/mcp-integration.html#configuring-mcp-servers","text":"","title":"Configuring MCP Servers"},{"location":"advanced/mcp-integration.html#in-settings","text":"# ~/.amplifier/settings.yaml mcp : servers : - name : filesystem command : npx @modelcontextprotocol/server-filesystem args : [ \"/allowed/path\" ] - name : postgres command : npx @modelcontextprotocol/server-postgres env : DATABASE_URL : \"postgresql://user:pass@localhost/db\"","title":"In Settings"},{"location":"advanced/mcp-integration.html#in-bundle","text":"# bundle.yaml mcp : servers : - name : my-server command : python my_server.py","title":"In Bundle"},{"location":"advanced/mcp-integration.html#available-mcp-servers","text":"","title":"Available MCP Servers"},{"location":"advanced/mcp-integration.html#official-servers","text":"Server Purpose @modelcontextprotocol/server-filesystem File operations @modelcontextprotocol/server-postgres PostgreSQL queries @modelcontextprotocol/server-sqlite SQLite databases @modelcontextprotocol/server-github GitHub API","title":"Official Servers"},{"location":"advanced/mcp-integration.html#installing-servers","text":"# Via npm npm install -g @modelcontextprotocol/server-filesystem npm install -g @modelcontextprotocol/server-postgres # Via pip pip install mcp-server-fetch","title":"Installing Servers"},{"location":"advanced/mcp-integration.html#example-filesystem-server","text":"","title":"Example: Filesystem Server"},{"location":"advanced/mcp-integration.html#configure","text":"mcp : servers : - name : files command : npx @modelcontextprotocol/server-filesystem args : [ \"/home/user/projects\" ]","title":"Configure"},{"location":"advanced/mcp-integration.html#use","text":"The server adds tools that Amplifier can use: > List files in /home/user/projects > Read the contents of package.json","title":"Use"},{"location":"advanced/mcp-integration.html#example-database-server","text":"","title":"Example: Database Server"},{"location":"advanced/mcp-integration.html#configure_1","text":"mcp : servers : - name : database command : npx @modelcontextprotocol/server-postgres env : DATABASE_URL : \"postgresql://localhost/mydb\"","title":"Configure"},{"location":"advanced/mcp-integration.html#use_1","text":"> Show all tables in the database > Query the users table for active users > Count orders from last week","title":"Use"},{"location":"advanced/mcp-integration.html#example-github-server","text":"","title":"Example: GitHub Server"},{"location":"advanced/mcp-integration.html#configure_2","text":"mcp : servers : - name : github command : npx @modelcontextprotocol/server-github env : GITHUB_TOKEN : ${GITHUB_TOKEN}","title":"Configure"},{"location":"advanced/mcp-integration.html#use_2","text":"> List open PRs in microsoft/amplifier > Get details of issue #123 > Show my recent commits","title":"Use"},{"location":"advanced/mcp-integration.html#creating-mcp-servers","text":"","title":"Creating MCP Servers"},{"location":"advanced/mcp-integration.html#python-server","text":"# my_server.py from mcp.server import Server from mcp.types import Tool , TextContent server = Server ( \"my-server\" ) @server . tool () async def get_weather ( city : str ) -> str : \"\"\"Get weather for a city\"\"\" # Implementation return f \"Weather in { city } : Sunny, 72\u00b0F\" @server . tool () async def search_docs ( query : str ) -> str : \"\"\"Search internal documentation\"\"\" # Implementation return f \"Found 5 results for: { query } \" if __name__ == \"__main__\" : server . run ()","title":"Python Server"},{"location":"advanced/mcp-integration.html#register","text":"mcp : servers : - name : my-tools command : python my_server.py","title":"Register"},{"location":"advanced/mcp-integration.html#mcp-resources","text":"MCP servers can also provide resources (data): @server . resource ( \"docs:// {path} \" ) async def get_doc ( path : str ) -> str : \"\"\"Get documentation by path\"\"\" with open ( f \"/docs/ { path } \" ) as f : return f . read () Access in Amplifier: > Get the resource docs://api/auth.md","title":"MCP Resources"},{"location":"advanced/mcp-integration.html#debugging-mcp","text":"","title":"Debugging MCP"},{"location":"advanced/mcp-integration.html#test-server-directly","text":"# Run server npx @modelcontextprotocol/server-filesystem /tmp # In another terminal, test with mcp CLI mcp test-server filesystem","title":"Test Server Directly"},{"location":"advanced/mcp-integration.html#check-logs","text":"# Amplifier logs MCP communication export AMPLIFIER_LOG_LEVEL = debug amp","title":"Check Logs"},{"location":"advanced/mcp-integration.html#common-issues","text":"Server not starting: - Check command path - Verify dependencies installed - Check environment variables Tools not appearing: - Restart Amplifier - Verify server is running - Check server logs Permission errors: - Check allowed paths - Verify credentials - Check environment setup","title":"Common Issues"},{"location":"advanced/mcp-integration.html#security-considerations","text":"","title":"Security Considerations"},{"location":"advanced/mcp-integration.html#principle-of-least-privilege","text":"mcp : servers : # Good - limited scope - name : project-files command : npx @modelcontextprotocol/server-filesystem args : [ \"/home/user/current-project\" ] # Avoid - too broad - name : all-files command : npx @modelcontextprotocol/server-filesystem args : [ \"/\" ] # Don't do this!","title":"Principle of Least Privilege"},{"location":"advanced/mcp-integration.html#credential-management","text":"mcp : servers : - name : database command : npx @modelcontextprotocol/server-postgres env : # Use environment variable, not hardcoded DATABASE_URL : ${DATABASE_URL}","title":"Credential Management"},{"location":"advanced/mcp-integration.html#audit-mcp-actions","text":"MCP tool calls appear in session logs: cat events.jsonl | jq 'select(.tool_name | startswith(\"mcp:\"))'","title":"Audit MCP Actions"},{"location":"advanced/mcp-integration.html#try-it-yourself","text":"","title":"Try It Yourself"},{"location":"advanced/mcp-integration.html#exercise-1-filesystem-server","text":"# Add to ~/.amplifier/settings.yaml mcp : servers : - name : files command : npx @modelcontextprotocol/server-filesystem args : [ \"./\" ] npm install -g @modelcontextprotocol/server-filesystem amp > What files are in this directory?","title":"Exercise 1: Filesystem Server"},{"location":"advanced/mcp-integration.html#exercise-2-sqlite-server","text":"mcp : servers : - name : db command : npx @modelcontextprotocol/server-sqlite args : [ \"./test.db\" ] > Create a users table > Insert some test data > Query all users","title":"Exercise 2: SQLite Server"},{"location":"advanced/mcp-integration.html#resources","text":"MCP Specification Official Servers Python SDK TypeScript SDK","title":"Resources"},{"location":"bundles/index.html","text":"Bundles Guide \u00b6 Bundles are the primary way to configure and customize Amplifier. A bundle composes modules, tools, context, and settings into a coherent package that defines an agent's capabilities. This section covers bundle structure, composition patterns, and how to create your own bundles. Section Contents \u00b6 Page Description Bundle Basics What bundles are and how they work Built-in Bundles Foundation, dev, and other standard bundles Bundle Structure Anatomy of a bundle directory Composition Combining multiple bundles Creating Bundles Build your own custom bundles Context Files Adding knowledge to bundles Tool Bundles Bundles that provide tools Publishing Sharing bundles with others Quick Tips \u00b6 Thin bundles \u2014 Bundles should compose, not implement; keep logic in modules Layered composition \u2014 Bundles can extend other bundles for customization Context is cheap \u2014 Add relevant context files liberally; they help agents One purpose \u2014 Each bundle should have a clear, focused purpose Test composition \u2014 Verify bundles work together before deploying Bundle Architecture \u00b6 bundle/ \u251c\u2500\u2500 bundle.yaml # Bundle manifest \u251c\u2500\u2500 context/ # Context files (.md) \u2502 \u251c\u2500\u2500 instructions.md \u2502 \u2514\u2500\u2500 domain-knowledge.md \u251c\u2500\u2500 skills/ # Packaged skills \u251c\u2500\u2500 agents/ # Agent definitions \u2514\u2500\u2500 tools/ # Custom tools (optional) Built-in Bundles \u00b6 Bundle Purpose Key Features foundation General development Full toolset, explorer, git-ops dev Lightweight coding Essential tools, minimal context core Minimal base Kernel only, for custom builds lsp-python Python intelligence LSP integration, Pyright Where to Start \u00b6 New to bundles? Begin with Bundle Basics to understand what bundles are and why they matter. Want to customize? Read Creating Bundles for a step-by-step guide to building your own. Using multiple bundles? Check Composition to learn how bundles layer and interact. Common Patterns \u00b6 # Extend an existing bundle extends : foundation # Add custom context context : - ./context/my-domain.md # Include specific modules modules : - tool-web - hook-memory Bundle Selection Guide \u00b6 Use Case Recommended Bundle General development foundation Quick coding tasks dev Python projects foundation + lsp-python Custom applications Create your own Minimal footprint core + specific modules Related Sections \u00b6 Concepts: Modules Skills: Using Skills Advanced: Bundle Internals","title":"Overview"},{"location":"bundles/index.html#bundles-guide","text":"Bundles are the primary way to configure and customize Amplifier. A bundle composes modules, tools, context, and settings into a coherent package that defines an agent's capabilities. This section covers bundle structure, composition patterns, and how to create your own bundles.","title":"Bundles Guide"},{"location":"bundles/index.html#section-contents","text":"Page Description Bundle Basics What bundles are and how they work Built-in Bundles Foundation, dev, and other standard bundles Bundle Structure Anatomy of a bundle directory Composition Combining multiple bundles Creating Bundles Build your own custom bundles Context Files Adding knowledge to bundles Tool Bundles Bundles that provide tools Publishing Sharing bundles with others","title":"Section Contents"},{"location":"bundles/index.html#quick-tips","text":"Thin bundles \u2014 Bundles should compose, not implement; keep logic in modules Layered composition \u2014 Bundles can extend other bundles for customization Context is cheap \u2014 Add relevant context files liberally; they help agents One purpose \u2014 Each bundle should have a clear, focused purpose Test composition \u2014 Verify bundles work together before deploying","title":"Quick Tips"},{"location":"bundles/index.html#bundle-architecture","text":"bundle/ \u251c\u2500\u2500 bundle.yaml # Bundle manifest \u251c\u2500\u2500 context/ # Context files (.md) \u2502 \u251c\u2500\u2500 instructions.md \u2502 \u2514\u2500\u2500 domain-knowledge.md \u251c\u2500\u2500 skills/ # Packaged skills \u251c\u2500\u2500 agents/ # Agent definitions \u2514\u2500\u2500 tools/ # Custom tools (optional)","title":"Bundle Architecture"},{"location":"bundles/index.html#built-in-bundles","text":"Bundle Purpose Key Features foundation General development Full toolset, explorer, git-ops dev Lightweight coding Essential tools, minimal context core Minimal base Kernel only, for custom builds lsp-python Python intelligence LSP integration, Pyright","title":"Built-in Bundles"},{"location":"bundles/index.html#where-to-start","text":"New to bundles? Begin with Bundle Basics to understand what bundles are and why they matter. Want to customize? Read Creating Bundles for a step-by-step guide to building your own. Using multiple bundles? Check Composition to learn how bundles layer and interact.","title":"Where to Start"},{"location":"bundles/index.html#common-patterns","text":"# Extend an existing bundle extends : foundation # Add custom context context : - ./context/my-domain.md # Include specific modules modules : - tool-web - hook-memory","title":"Common Patterns"},{"location":"bundles/index.html#bundle-selection-guide","text":"Use Case Recommended Bundle General development foundation Quick coding tasks dev Python projects foundation + lsp-python Custom applications Create your own Minimal footprint core + specific modules","title":"Bundle Selection Guide"},{"location":"bundles/index.html#related-sections","text":"Concepts: Modules Skills: Using Skills Advanced: Bundle Internals","title":"Related Sections"},{"location":"bundles/design-intelligence.html","text":"Design Intelligence Bundle \u00b6 Overview \u00b6 The Design Intelligence bundle provides a suite of specialized AI agents for UI/UX design work. These agents embody the Nine Dimensions philosophy and Five Pillars framework, ensuring consistent, high-quality design decisions across your entire system. Each agent operates at a specific level of the design hierarchy\u2014from strategic aesthetic direction down to individual component refinement\u2014allowing you to engage the right expertise for each design challenge. Agents Included \u00b6 Agent Purpose Scope art-director Visual strategy and aesthetic direction System-wide design-system-architect Design tokens, foundations, architecture System-wide layout-architect Page structure and information architecture Page/View level component-designer Individual UI component design Component level animation-choreographer Motion, transitions, micro-interactions Element level responsive-strategist Multi-device adaptation and breakpoints Cross-device voice-strategist UX writing, tone, and microcopy Content layer Agent Deep Dive \u00b6 art-director \u00b6 The strategic leader for visual expression. Transforms vague aesthetic visions (\"make it feel premium\", \"we want a modern vibe\") into systematic design principles. Use for: - Defining aesthetic direction and visual strategy - Creating and maintaining .design/AESTHETIC-GUIDE.md - Ensuring visual coherence across the system - Translating feelings and \"vibes\" into actionable design principles - Brand expression decisions Output artifacts: - Aesthetic guidelines - Visual direction documents - Style dimension specifications design-system-architect \u00b6 The foundation builder. Works at the system level to establish scalable design infrastructure that supports all other design work. Use for: - Design system architecture and token design - Establishing foundations (color, typography, spacing, motion) - Evaluating decisions against the Nine Dimensions - Validating Five Pillars alignment - Cross-cutting design concerns Output artifacts: - Design token specifications - Foundation documentation - System-level design decisions layout-architect \u00b6 The spatial organizer. Handles page-level structure and how information flows through your application. Use for: - Page/view layout structure (header, sidebar, main, footer) - Information architecture and navigation hierarchy - Grid systems and spatial composition - Content flow and reading patterns - Screen-level structural decisions Owns: Space dimension (Nine Dimensions #4) at the page/view level component-designer \u00b6 The craftsman. Focuses on individual UI elements, ensuring each component embodies the design system while maintaining the 9.5/10 quality baseline. Use for: - Designing new UI components - Refining existing components - Component-level design decisions - Component documentation and examples - Variant design and props API specification Output artifacts: - Component specifications - Variant matrices - Props API documentation animation-choreographer \u00b6 The motion director. Transforms movement from decoration into communication, using motion to convey system state and provide feedback. Use for: - Icon animations and micro-interactions - Page transitions and choreography - Loading states and progress indicators - State change animations - Motion timing and easing decisions - Accessibility considerations for motion Principle: Animation is communication, not decoration. responsive-strategist \u00b6 The multi-device expert. Ensures your design works across all viewport sizes and input methods. Use for: - Responsive design strategy and breakpoint definitions - Mobile-first vs desktop-first approach decisions - Touch vs mouse interaction patterns - Device-specific optimizations (phone, tablet, desktop) - Fluid typography and spacing systems Handles: Web modalities across desktop, tablet, and mobile. voice-strategist \u00b6 The content architect. Ensures language throughout your application is clear, helpful, and consistent with brand personality. Use for: - Voice & tone strategy and framework - UX writing and microcopy (buttons, labels, placeholders) - Error message patterns - Empty state messaging - Content guidelines for developers Owns: Voice dimension (Nine Dimensions #3) The Nine Dimensions \u00b6 The Design Intelligence agents evaluate and create designs using the Nine Dimensions framework: # Dimension Description Primary Owner 1 Style Visual aesthetic and brand expression art-director 2 Color Palette, contrast, accessibility design-system-architect 3 Voice Tone, language, personality voice-strategist 4 Space Layout, hierarchy, breathing room layout-architect 5 Motion Animation, transitions, feedback animation-choreographer 6 Touch Interaction patterns, affordances component-designer 7 Scale Responsive behavior, adaptation responsive-strategist 8 State Loading, error, empty, success component-designer 9 Flow User journeys, navigation layout-architect Each agent considers all dimensions but takes primary ownership of specific ones. The Five Pillars \u00b6 All design decisions are validated against the Five Pillars: Clarity - Is the design immediately understandable? Consistency - Does it align with established patterns? Efficiency - Does it respect user time and attention? Delight - Does it create positive emotional response? Accessibility - Is it usable by everyone? When to Use \u00b6 Starting a New Project \u00b6 1. art-director \u2192 Establish aesthetic direction 2. design-system-architect \u2192 Define tokens and foundations 3. layout-architect \u2192 Create page structure patterns 4. component-designer \u2192 Design core UI components 5. voice-strategist \u2192 Define content guidelines Adding a New Feature \u00b6 1. layout-architect \u2192 Determine where it fits 2. component-designer \u2192 Design the components 3. animation-choreographer \u2192 Add appropriate motion 4. responsive-strategist \u2192 Ensure multi-device support Refining Existing Design \u00b6 1. art-director \u2192 Validate aesthetic alignment 2. component-designer \u2192 Refine individual elements 3. animation-choreographer \u2192 Polish interactions Design System Maintenance \u00b6 1. design-system-architect \u2192 Token updates, pattern additions 2. component-designer \u2192 Component updates 3. voice-strategist \u2192 Content pattern updates Agent Collaboration Patterns \u00b6 Sequential Handoff \u00b6 For comprehensive design work, agents hand off to each other: art-director (strategy) \u2193 design-system-architect (foundations) \u2193 layout-architect (structure) \u2193 component-designer (components) \u2193 animation-choreographer (motion) Parallel Consultation \u00b6 For specific design questions, consult multiple agents simultaneously: \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 Design Question \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u250c\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2510 \u2193 \u2193 \u2193 [A1] [A2] [A3] (parallel consultation) \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2518 \u2193 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 Synthesized Answer \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 Try It Yourself \u00b6 Define an Aesthetic Direction \u00b6 Task: \"We're building a developer tools platform. We want it to feel professional but approachable, technical but not intimidating.\" Agent: art-director Expected output: Aesthetic guide with: - Core visual principles - Color direction - Typography recommendations - Imagery style Design a Component \u00b6 Task: \"Design a notification toast component with success, warning, error, and info variants.\" Agent: component-designer Expected output: - Component specification - Variant matrix - Props API - Accessibility notes - Usage guidelines Create Motion Guidelines \u00b6 Task: \"Define animation standards for our application, including page transitions and micro-interactions.\" Agent: animation-choreographer Expected output: - Motion timing protocol - Easing function recommendations - Transition patterns - Accessibility considerations (reduced motion) Responsive Strategy \u00b6 Task: \"Our app needs to work on desktop, tablet, and mobile. Define our responsive approach.\" Agent: responsive-strategist Expected output: - Breakpoint definitions - Mobile-first vs desktop-first recommendation - Touch target specifications - Fluid scaling approach Integration with Development \u00b6 Design-to-Code Workflow \u00b6 Design agents produce specifications Specifications feed into implementation agents Component specifications become React/Vue/etc. components Token specifications become CSS custom properties or theme files Artifact Locations \u00b6 Design Intelligence agents create and maintain files in: .design/ \u251c\u2500\u2500 AESTHETIC-GUIDE.md # art-director \u251c\u2500\u2500 tokens/ \u2502 \u251c\u2500\u2500 colors.json # design-system-architect \u2502 \u251c\u2500\u2500 typography.json # design-system-architect \u2502 \u2514\u2500\u2500 spacing.json # design-system-architect \u251c\u2500\u2500 components/ \u2502 \u2514\u2500\u2500 [component].md # component-designer \u251c\u2500\u2500 motion/ \u2502 \u2514\u2500\u2500 guidelines.md # animation-choreographer \u2514\u2500\u2500 content/ \u2514\u2500\u2500 voice-guide.md # voice-strategist Best Practices \u00b6 Start strategic, then tactical - Begin with art-director for vision, then work down to components Let agents own their dimensions - Trust each agent's expertise in their domain Cross-reference the Nine Dimensions - Ensure all dimensions are addressed Validate against Five Pillars - Use pillars as a quality checklist Iterate with specificity - Give agents concrete context for better outputs Quality Baseline \u00b6 All Design Intelligence agents maintain a 9.5/10 quality baseline . This means: No placeholder content or \"lorem ipsum\" in specifications Accessibility is always considered Edge cases are documented Rationale is provided for design decisions Specifications are implementation-ready","title":"Design Intelligence"},{"location":"bundles/design-intelligence.html#design-intelligence-bundle","text":"","title":"Design Intelligence Bundle"},{"location":"bundles/design-intelligence.html#overview","text":"The Design Intelligence bundle provides a suite of specialized AI agents for UI/UX design work. These agents embody the Nine Dimensions philosophy and Five Pillars framework, ensuring consistent, high-quality design decisions across your entire system. Each agent operates at a specific level of the design hierarchy\u2014from strategic aesthetic direction down to individual component refinement\u2014allowing you to engage the right expertise for each design challenge.","title":"Overview"},{"location":"bundles/design-intelligence.html#agents-included","text":"Agent Purpose Scope art-director Visual strategy and aesthetic direction System-wide design-system-architect Design tokens, foundations, architecture System-wide layout-architect Page structure and information architecture Page/View level component-designer Individual UI component design Component level animation-choreographer Motion, transitions, micro-interactions Element level responsive-strategist Multi-device adaptation and breakpoints Cross-device voice-strategist UX writing, tone, and microcopy Content layer","title":"Agents Included"},{"location":"bundles/design-intelligence.html#agent-deep-dive","text":"","title":"Agent Deep Dive"},{"location":"bundles/design-intelligence.html#art-director","text":"The strategic leader for visual expression. Transforms vague aesthetic visions (\"make it feel premium\", \"we want a modern vibe\") into systematic design principles. Use for: - Defining aesthetic direction and visual strategy - Creating and maintaining .design/AESTHETIC-GUIDE.md - Ensuring visual coherence across the system - Translating feelings and \"vibes\" into actionable design principles - Brand expression decisions Output artifacts: - Aesthetic guidelines - Visual direction documents - Style dimension specifications","title":"art-director"},{"location":"bundles/design-intelligence.html#design-system-architect","text":"The foundation builder. Works at the system level to establish scalable design infrastructure that supports all other design work. Use for: - Design system architecture and token design - Establishing foundations (color, typography, spacing, motion) - Evaluating decisions against the Nine Dimensions - Validating Five Pillars alignment - Cross-cutting design concerns Output artifacts: - Design token specifications - Foundation documentation - System-level design decisions","title":"design-system-architect"},{"location":"bundles/design-intelligence.html#layout-architect","text":"The spatial organizer. Handles page-level structure and how information flows through your application. Use for: - Page/view layout structure (header, sidebar, main, footer) - Information architecture and navigation hierarchy - Grid systems and spatial composition - Content flow and reading patterns - Screen-level structural decisions Owns: Space dimension (Nine Dimensions #4) at the page/view level","title":"layout-architect"},{"location":"bundles/design-intelligence.html#component-designer","text":"The craftsman. Focuses on individual UI elements, ensuring each component embodies the design system while maintaining the 9.5/10 quality baseline. Use for: - Designing new UI components - Refining existing components - Component-level design decisions - Component documentation and examples - Variant design and props API specification Output artifacts: - Component specifications - Variant matrices - Props API documentation","title":"component-designer"},{"location":"bundles/design-intelligence.html#animation-choreographer","text":"The motion director. Transforms movement from decoration into communication, using motion to convey system state and provide feedback. Use for: - Icon animations and micro-interactions - Page transitions and choreography - Loading states and progress indicators - State change animations - Motion timing and easing decisions - Accessibility considerations for motion Principle: Animation is communication, not decoration.","title":"animation-choreographer"},{"location":"bundles/design-intelligence.html#responsive-strategist","text":"The multi-device expert. Ensures your design works across all viewport sizes and input methods. Use for: - Responsive design strategy and breakpoint definitions - Mobile-first vs desktop-first approach decisions - Touch vs mouse interaction patterns - Device-specific optimizations (phone, tablet, desktop) - Fluid typography and spacing systems Handles: Web modalities across desktop, tablet, and mobile.","title":"responsive-strategist"},{"location":"bundles/design-intelligence.html#voice-strategist","text":"The content architect. Ensures language throughout your application is clear, helpful, and consistent with brand personality. Use for: - Voice & tone strategy and framework - UX writing and microcopy (buttons, labels, placeholders) - Error message patterns - Empty state messaging - Content guidelines for developers Owns: Voice dimension (Nine Dimensions #3)","title":"voice-strategist"},{"location":"bundles/design-intelligence.html#the-nine-dimensions","text":"The Design Intelligence agents evaluate and create designs using the Nine Dimensions framework: # Dimension Description Primary Owner 1 Style Visual aesthetic and brand expression art-director 2 Color Palette, contrast, accessibility design-system-architect 3 Voice Tone, language, personality voice-strategist 4 Space Layout, hierarchy, breathing room layout-architect 5 Motion Animation, transitions, feedback animation-choreographer 6 Touch Interaction patterns, affordances component-designer 7 Scale Responsive behavior, adaptation responsive-strategist 8 State Loading, error, empty, success component-designer 9 Flow User journeys, navigation layout-architect Each agent considers all dimensions but takes primary ownership of specific ones.","title":"The Nine Dimensions"},{"location":"bundles/design-intelligence.html#the-five-pillars","text":"All design decisions are validated against the Five Pillars: Clarity - Is the design immediately understandable? Consistency - Does it align with established patterns? Efficiency - Does it respect user time and attention? Delight - Does it create positive emotional response? Accessibility - Is it usable by everyone?","title":"The Five Pillars"},{"location":"bundles/design-intelligence.html#when-to-use","text":"","title":"When to Use"},{"location":"bundles/design-intelligence.html#starting-a-new-project","text":"1. art-director \u2192 Establish aesthetic direction 2. design-system-architect \u2192 Define tokens and foundations 3. layout-architect \u2192 Create page structure patterns 4. component-designer \u2192 Design core UI components 5. voice-strategist \u2192 Define content guidelines","title":"Starting a New Project"},{"location":"bundles/design-intelligence.html#adding-a-new-feature","text":"1. layout-architect \u2192 Determine where it fits 2. component-designer \u2192 Design the components 3. animation-choreographer \u2192 Add appropriate motion 4. responsive-strategist \u2192 Ensure multi-device support","title":"Adding a New Feature"},{"location":"bundles/design-intelligence.html#refining-existing-design","text":"1. art-director \u2192 Validate aesthetic alignment 2. component-designer \u2192 Refine individual elements 3. animation-choreographer \u2192 Polish interactions","title":"Refining Existing Design"},{"location":"bundles/design-intelligence.html#design-system-maintenance","text":"1. design-system-architect \u2192 Token updates, pattern additions 2. component-designer \u2192 Component updates 3. voice-strategist \u2192 Content pattern updates","title":"Design System Maintenance"},{"location":"bundles/design-intelligence.html#agent-collaboration-patterns","text":"","title":"Agent Collaboration Patterns"},{"location":"bundles/design-intelligence.html#sequential-handoff","text":"For comprehensive design work, agents hand off to each other: art-director (strategy) \u2193 design-system-architect (foundations) \u2193 layout-architect (structure) \u2193 component-designer (components) \u2193 animation-choreographer (motion)","title":"Sequential Handoff"},{"location":"bundles/design-intelligence.html#parallel-consultation","text":"For specific design questions, consult multiple agents simultaneously: \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 Design Question \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u250c\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2510 \u2193 \u2193 \u2193 [A1] [A2] [A3] (parallel consultation) \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2518 \u2193 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 Synthesized Answer \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Parallel Consultation"},{"location":"bundles/design-intelligence.html#try-it-yourself","text":"","title":"Try It Yourself"},{"location":"bundles/design-intelligence.html#define-an-aesthetic-direction","text":"Task: \"We're building a developer tools platform. We want it to feel professional but approachable, technical but not intimidating.\" Agent: art-director Expected output: Aesthetic guide with: - Core visual principles - Color direction - Typography recommendations - Imagery style","title":"Define an Aesthetic Direction"},{"location":"bundles/design-intelligence.html#design-a-component","text":"Task: \"Design a notification toast component with success, warning, error, and info variants.\" Agent: component-designer Expected output: - Component specification - Variant matrix - Props API - Accessibility notes - Usage guidelines","title":"Design a Component"},{"location":"bundles/design-intelligence.html#create-motion-guidelines","text":"Task: \"Define animation standards for our application, including page transitions and micro-interactions.\" Agent: animation-choreographer Expected output: - Motion timing protocol - Easing function recommendations - Transition patterns - Accessibility considerations (reduced motion)","title":"Create Motion Guidelines"},{"location":"bundles/design-intelligence.html#responsive-strategy","text":"Task: \"Our app needs to work on desktop, tablet, and mobile. Define our responsive approach.\" Agent: responsive-strategist Expected output: - Breakpoint definitions - Mobile-first vs desktop-first recommendation - Touch target specifications - Fluid scaling approach","title":"Responsive Strategy"},{"location":"bundles/design-intelligence.html#integration-with-development","text":"","title":"Integration with Development"},{"location":"bundles/design-intelligence.html#design-to-code-workflow","text":"Design agents produce specifications Specifications feed into implementation agents Component specifications become React/Vue/etc. components Token specifications become CSS custom properties or theme files","title":"Design-to-Code Workflow"},{"location":"bundles/design-intelligence.html#artifact-locations","text":"Design Intelligence agents create and maintain files in: .design/ \u251c\u2500\u2500 AESTHETIC-GUIDE.md # art-director \u251c\u2500\u2500 tokens/ \u2502 \u251c\u2500\u2500 colors.json # design-system-architect \u2502 \u251c\u2500\u2500 typography.json # design-system-architect \u2502 \u2514\u2500\u2500 spacing.json # design-system-architect \u251c\u2500\u2500 components/ \u2502 \u2514\u2500\u2500 [component].md # component-designer \u251c\u2500\u2500 motion/ \u2502 \u2514\u2500\u2500 guidelines.md # animation-choreographer \u2514\u2500\u2500 content/ \u2514\u2500\u2500 voice-guide.md # voice-strategist","title":"Artifact Locations"},{"location":"bundles/design-intelligence.html#best-practices","text":"Start strategic, then tactical - Begin with art-director for vision, then work down to components Let agents own their dimensions - Trust each agent's expertise in their domain Cross-reference the Nine Dimensions - Ensure all dimensions are addressed Validate against Five Pillars - Use pillars as a quality checklist Iterate with specificity - Give agents concrete context for better outputs","title":"Best Practices"},{"location":"bundles/design-intelligence.html#quality-baseline","text":"All Design Intelligence agents maintain a 9.5/10 quality baseline . This means: No placeholder content or \"lorem ipsum\" in specifications Accessibility is always considered Edge cases are documented Rationale is provided for design decisions Specifications are implementation-ready","title":"Quality Baseline"},{"location":"bundles/foundation.html","text":"Foundation Bundle \u00b6 Overview \u00b6 The Foundation bundle is the default, batteries-included bundle for Amplifier. It provides a comprehensive set of tools and specialized agents that cover the most common software development workflows. When you run Amplifier without specifying a bundle, you get Foundation. Foundation follows the \"thin bundle\" pattern\u2014it composes behaviors from smaller, focused modules rather than implementing everything itself. This means you get a powerful, well-integrated experience out of the box while maintaining the flexibility to customize or extend as needed. Design Philosophy \u00b6 Foundation embodies several key principles: Completeness without bloat : Everything you need for day-to-day development, nothing you don't Specialized agents : Each agent does one thing exceptionally well Composable workflows : Agents can delegate to each other for complex tasks Sensible defaults : Works great out of the box, customizable when needed Tools Included \u00b6 Foundation provides access to core tools that enable file operations, search, shell access, and more. Tool Purpose When to Use bash Shell command execution Running builds, tests, git commands, system utilities read_file Read file contents Viewing source code, configs, documentation write_file Create or overwrite files Creating new files when necessary edit_file Surgical file edits Making precise changes to existing files glob Find files by pattern Locating files matching **/*.py , src/**/*.ts grep Search file contents Finding code patterns, function definitions web_search Search the internet Looking up documentation, APIs, solutions web_fetch Fetch URL content Reading documentation pages, API specs task Launch sub-agents Delegating specialized work to expert agents LSP Language Server Protocol Code intelligence, go-to-definition, find references todo Task tracking Managing multi-step workflows load_skill Load domain knowledge Accessing specialized skills and patterns Tool Usage Patterns \u00b6 File Operations : Always prefer edit_file over write_file for existing files. The edit tool makes surgical changes while preserving the rest of the file. # Good: Precise edit edit_file(file_path=\"src/auth.py\", old_string=\"timeout=30\", new_string=\"timeout=60\") # Avoid: Rewriting entire file for small changes write_file(file_path=\"src/auth.py\", content=\"...\") Search Operations : Use grep for content search, glob for file discovery. # Find all Python files glob(pattern=\"**/*.py\") # Find function definitions grep(pattern=\"def authenticate\", type=\"py\") Agents Included \u00b6 Foundation includes a roster of specialized agents, each designed for specific development tasks. Agent Purpose Key Capabilities explorer Codebase reconnaissance Deep code exploration, architecture mapping zen-architect Design and planning Architecture decisions, module specifications modular-builder Implementation Building code from specifications bug-hunter Debugging Systematic bug investigation and fixes git-ops Git operations Commits, PRs, branch management test-coverage Testing strategy Coverage analysis, test case suggestions web-research Internet research Documentation lookup, API research security-guardian Security review Vulnerability assessment, security audits integration-specialist External integrations APIs, MCP servers, dependencies post-task-cleanup Codebase hygiene Removing artifacts, ensuring simplicity session-analyst Session debugging Analyzing and repairing Amplifier sessions Agent Descriptions \u00b6 explorer \u00b6 The explorer agent performs deep reconnaissance of codebases. Use it when you need a comprehensive survey of code structure, documentation, or configuration. Best for: - Understanding unfamiliar codebases - Mapping module dependencies - Finding relevant files for a task Example: task(agent=\"foundation:explorer\", instruction=\"Map the authentication flow in this codebase\") zen-architect \u00b6 The zen-architect embodies ruthless simplicity. It designs solutions that are as simple as possible but no simpler. Best for: - Planning new features - Designing system architecture - Reviewing code for unnecessary complexity Modes: - ANALYZE: Break down problems, design solutions - ARCHITECT: System design, module specification - REVIEW: Code quality assessment modular-builder \u00b6 The modular-builder implements code from specifications. It works hand-in-hand with zen-architect\u2014architect designs, builder implements. Best for: - Implementing new features - Building modules from specs - Creating self-contained components bug-hunter \u00b6 Bug-hunter uses hypothesis-driven debugging to systematically track down issues. Best for: - Investigating errors and exceptions - Debugging test failures - Tracing unexpected behavior Example: task(agent=\"foundation:bug-hunter\", instruction=\"The API returns 500 on /users endpoint. Find and fix the cause.\") git-ops \u00b6 Git-ops handles all version control operations with safety protocols and proper formatting. Best for: - Creating commits with proper messages - Managing branches - Creating and managing PRs - GitHub API operations Important: Always delegate git operations to this agent rather than using bash directly. Getting Started \u00b6 Basic Usage \u00b6 Foundation is the default bundle. Simply run Amplifier: amp You're immediately working with Foundation's full toolkit. Explicit Bundle Selection \u00b6 To explicitly use Foundation (useful in configurations): # .amplifier/config.yaml bundle : foundation First Steps \u00b6 Explore a codebase : Ask about the project structure Make changes : Request file edits or new features Run commands : Execute tests, builds, or other shell commands Search : Find files or code patterns Example Session \u00b6 User: What does this project do? [Amplifier explores the codebase using explorer agent] User: Add input validation to the login endpoint [Amplifier uses zen-architect to plan, then modular-builder to implement] User: Run the tests [Amplifier executes pytest via bash tool] User: Commit the changes [Amplifier delegates to git-ops for proper commit formatting] When to Use \u00b6 Foundation is Ideal For \u00b6 General development work : Day-to-day coding, debugging, refactoring Learning new codebases : Explorer agent excels at reconnaissance Full-stack projects : Web, backend, CLI\u2014Foundation handles it all Projects without specialized needs : When you don't need domain-specific agents Consider Alternatives When \u00b6 Design-heavy work : Add the design-intelligence bundle for UI/UX Python-specific LSP needs : Add lsp-python for enhanced Python intelligence Recipe-based workflows : Add recipes for multi-step automation Memory persistence : Add dev-memory for cross-session recall Bundle Composition \u00b6 Foundation composes well with other bundles: # .amplifier/config.yaml bundles : - foundation - lsp-python - dev-memory This gives you Foundation's core capabilities plus Python LSP and persistent memory. Agent Workflows \u00b6 The Architect-Builder Pattern \u00b6 For significant features, Foundation encourages a two-phase approach: Design Phase : zen-architect analyzes requirements and creates specifications Build Phase : modular-builder implements from those specifications This separation ensures thoughtful design before implementation. The Debug Workflow \u00b6 When encountering bugs: bug-hunter investigates systematically Uses hypothesis-driven debugging Proposes and implements fixes Validates the fix works The Cleanup Pattern \u00b6 After completing major work: post-task-cleanup reviews changes Removes temporary artifacts Ensures adherence to simplicity principles Validates codebase hygiene Configuration Options \u00b6 Provider Settings \u00b6 Foundation works with any configured LLM provider: # .amplifier/config.yaml provider : anthropic model : claude-sonnet-4-20250514 Tool Restrictions \u00b6 Disable specific tools if needed: # .amplifier/config.yaml disabled_tools : - web_search - web_fetch Agent Customization \u00b6 Override agent behavior with custom instructions: # .amplifier/config.yaml agent_instructions : zen-architect : \"Always prefer functional programming patterns\" Try It Yourself \u00b6 Exercise 1: Codebase Exploration \u00b6 Open a project you're unfamiliar with and ask: Explore this codebase and explain its architecture. What are the main components and how do they interact? Watch how Foundation's explorer agent systematically maps the project. Exercise 2: Feature Implementation \u00b6 In a project, request a new feature: Add a rate limiting middleware to the API. Limit requests to 100 per minute per IP. Observe the architect-builder workflow in action. Exercise 3: Bug Investigation \u00b6 If you have failing tests: The authentication tests are failing. Investigate and fix the issue. See bug-hunter's hypothesis-driven approach. Exercise 4: Git Workflow \u00b6 After making changes: Create a commit for these changes with a proper message. Then create a PR with a description of what was changed. Notice how git-ops handles formatting and safety. Exercise 5: Security Review \u00b6 Before deploying: Review the authentication module for security vulnerabilities. Check for OWASP Top 10 issues. Watch security-guardian perform a systematic audit. Best Practices \u00b6 Let Agents Specialize \u00b6 Don't try to do everything in one prompt. Leverage specialized agents: Design questions \u2192 zen-architect Implementation \u2192 modular-builder Bugs \u2192 bug-hunter Git \u2192 git-ops Trust the Workflow \u00b6 Foundation's agents coordinate effectively. Let zen-architect plan before modular-builder implements. This produces better results than rushing to code. Use Task Tracking \u00b6 For complex work, the todo tool helps track progress: Create a todo list for implementing user authentication. This keeps multi-step work organized and visible. Embrace Simplicity \u00b6 Foundation's philosophy is ruthless simplicity. When solutions seem complex, ask: Is there a simpler way to achieve this? The zen-architect excels at finding minimal solutions. Summary \u00b6 Foundation is your everyday development companion. It provides: Complete tooling : File ops, search, shell, web, LSP Expert agents : Specialized for design, implementation, debugging, and more Sensible workflows : Architect-builder pattern, systematic debugging Extensibility : Composes with other bundles for specialized needs Start with Foundation. Extend when you need more. That's the Amplifier way.","title":"Foundation"},{"location":"bundles/foundation.html#foundation-bundle","text":"","title":"Foundation Bundle"},{"location":"bundles/foundation.html#overview","text":"The Foundation bundle is the default, batteries-included bundle for Amplifier. It provides a comprehensive set of tools and specialized agents that cover the most common software development workflows. When you run Amplifier without specifying a bundle, you get Foundation. Foundation follows the \"thin bundle\" pattern\u2014it composes behaviors from smaller, focused modules rather than implementing everything itself. This means you get a powerful, well-integrated experience out of the box while maintaining the flexibility to customize or extend as needed.","title":"Overview"},{"location":"bundles/foundation.html#design-philosophy","text":"Foundation embodies several key principles: Completeness without bloat : Everything you need for day-to-day development, nothing you don't Specialized agents : Each agent does one thing exceptionally well Composable workflows : Agents can delegate to each other for complex tasks Sensible defaults : Works great out of the box, customizable when needed","title":"Design Philosophy"},{"location":"bundles/foundation.html#tools-included","text":"Foundation provides access to core tools that enable file operations, search, shell access, and more. Tool Purpose When to Use bash Shell command execution Running builds, tests, git commands, system utilities read_file Read file contents Viewing source code, configs, documentation write_file Create or overwrite files Creating new files when necessary edit_file Surgical file edits Making precise changes to existing files glob Find files by pattern Locating files matching **/*.py , src/**/*.ts grep Search file contents Finding code patterns, function definitions web_search Search the internet Looking up documentation, APIs, solutions web_fetch Fetch URL content Reading documentation pages, API specs task Launch sub-agents Delegating specialized work to expert agents LSP Language Server Protocol Code intelligence, go-to-definition, find references todo Task tracking Managing multi-step workflows load_skill Load domain knowledge Accessing specialized skills and patterns","title":"Tools Included"},{"location":"bundles/foundation.html#tool-usage-patterns","text":"File Operations : Always prefer edit_file over write_file for existing files. The edit tool makes surgical changes while preserving the rest of the file. # Good: Precise edit edit_file(file_path=\"src/auth.py\", old_string=\"timeout=30\", new_string=\"timeout=60\") # Avoid: Rewriting entire file for small changes write_file(file_path=\"src/auth.py\", content=\"...\") Search Operations : Use grep for content search, glob for file discovery. # Find all Python files glob(pattern=\"**/*.py\") # Find function definitions grep(pattern=\"def authenticate\", type=\"py\")","title":"Tool Usage Patterns"},{"location":"bundles/foundation.html#agents-included","text":"Foundation includes a roster of specialized agents, each designed for specific development tasks. Agent Purpose Key Capabilities explorer Codebase reconnaissance Deep code exploration, architecture mapping zen-architect Design and planning Architecture decisions, module specifications modular-builder Implementation Building code from specifications bug-hunter Debugging Systematic bug investigation and fixes git-ops Git operations Commits, PRs, branch management test-coverage Testing strategy Coverage analysis, test case suggestions web-research Internet research Documentation lookup, API research security-guardian Security review Vulnerability assessment, security audits integration-specialist External integrations APIs, MCP servers, dependencies post-task-cleanup Codebase hygiene Removing artifacts, ensuring simplicity session-analyst Session debugging Analyzing and repairing Amplifier sessions","title":"Agents Included"},{"location":"bundles/foundation.html#agent-descriptions","text":"","title":"Agent Descriptions"},{"location":"bundles/foundation.html#explorer","text":"The explorer agent performs deep reconnaissance of codebases. Use it when you need a comprehensive survey of code structure, documentation, or configuration. Best for: - Understanding unfamiliar codebases - Mapping module dependencies - Finding relevant files for a task Example: task(agent=\"foundation:explorer\", instruction=\"Map the authentication flow in this codebase\")","title":"explorer"},{"location":"bundles/foundation.html#zen-architect","text":"The zen-architect embodies ruthless simplicity. It designs solutions that are as simple as possible but no simpler. Best for: - Planning new features - Designing system architecture - Reviewing code for unnecessary complexity Modes: - ANALYZE: Break down problems, design solutions - ARCHITECT: System design, module specification - REVIEW: Code quality assessment","title":"zen-architect"},{"location":"bundles/foundation.html#modular-builder","text":"The modular-builder implements code from specifications. It works hand-in-hand with zen-architect\u2014architect designs, builder implements. Best for: - Implementing new features - Building modules from specs - Creating self-contained components","title":"modular-builder"},{"location":"bundles/foundation.html#bug-hunter","text":"Bug-hunter uses hypothesis-driven debugging to systematically track down issues. Best for: - Investigating errors and exceptions - Debugging test failures - Tracing unexpected behavior Example: task(agent=\"foundation:bug-hunter\", instruction=\"The API returns 500 on /users endpoint. Find and fix the cause.\")","title":"bug-hunter"},{"location":"bundles/foundation.html#git-ops","text":"Git-ops handles all version control operations with safety protocols and proper formatting. Best for: - Creating commits with proper messages - Managing branches - Creating and managing PRs - GitHub API operations Important: Always delegate git operations to this agent rather than using bash directly.","title":"git-ops"},{"location":"bundles/foundation.html#getting-started","text":"","title":"Getting Started"},{"location":"bundles/foundation.html#basic-usage","text":"Foundation is the default bundle. Simply run Amplifier: amp You're immediately working with Foundation's full toolkit.","title":"Basic Usage"},{"location":"bundles/foundation.html#explicit-bundle-selection","text":"To explicitly use Foundation (useful in configurations): # .amplifier/config.yaml bundle : foundation","title":"Explicit Bundle Selection"},{"location":"bundles/foundation.html#first-steps","text":"Explore a codebase : Ask about the project structure Make changes : Request file edits or new features Run commands : Execute tests, builds, or other shell commands Search : Find files or code patterns","title":"First Steps"},{"location":"bundles/foundation.html#example-session","text":"User: What does this project do? [Amplifier explores the codebase using explorer agent] User: Add input validation to the login endpoint [Amplifier uses zen-architect to plan, then modular-builder to implement] User: Run the tests [Amplifier executes pytest via bash tool] User: Commit the changes [Amplifier delegates to git-ops for proper commit formatting]","title":"Example Session"},{"location":"bundles/foundation.html#when-to-use","text":"","title":"When to Use"},{"location":"bundles/foundation.html#foundation-is-ideal-for","text":"General development work : Day-to-day coding, debugging, refactoring Learning new codebases : Explorer agent excels at reconnaissance Full-stack projects : Web, backend, CLI\u2014Foundation handles it all Projects without specialized needs : When you don't need domain-specific agents","title":"Foundation is Ideal For"},{"location":"bundles/foundation.html#consider-alternatives-when","text":"Design-heavy work : Add the design-intelligence bundle for UI/UX Python-specific LSP needs : Add lsp-python for enhanced Python intelligence Recipe-based workflows : Add recipes for multi-step automation Memory persistence : Add dev-memory for cross-session recall","title":"Consider Alternatives When"},{"location":"bundles/foundation.html#bundle-composition","text":"Foundation composes well with other bundles: # .amplifier/config.yaml bundles : - foundation - lsp-python - dev-memory This gives you Foundation's core capabilities plus Python LSP and persistent memory.","title":"Bundle Composition"},{"location":"bundles/foundation.html#agent-workflows","text":"","title":"Agent Workflows"},{"location":"bundles/foundation.html#the-architect-builder-pattern","text":"For significant features, Foundation encourages a two-phase approach: Design Phase : zen-architect analyzes requirements and creates specifications Build Phase : modular-builder implements from those specifications This separation ensures thoughtful design before implementation.","title":"The Architect-Builder Pattern"},{"location":"bundles/foundation.html#the-debug-workflow","text":"When encountering bugs: bug-hunter investigates systematically Uses hypothesis-driven debugging Proposes and implements fixes Validates the fix works","title":"The Debug Workflow"},{"location":"bundles/foundation.html#the-cleanup-pattern","text":"After completing major work: post-task-cleanup reviews changes Removes temporary artifacts Ensures adherence to simplicity principles Validates codebase hygiene","title":"The Cleanup Pattern"},{"location":"bundles/foundation.html#configuration-options","text":"","title":"Configuration Options"},{"location":"bundles/foundation.html#provider-settings","text":"Foundation works with any configured LLM provider: # .amplifier/config.yaml provider : anthropic model : claude-sonnet-4-20250514","title":"Provider Settings"},{"location":"bundles/foundation.html#tool-restrictions","text":"Disable specific tools if needed: # .amplifier/config.yaml disabled_tools : - web_search - web_fetch","title":"Tool Restrictions"},{"location":"bundles/foundation.html#agent-customization","text":"Override agent behavior with custom instructions: # .amplifier/config.yaml agent_instructions : zen-architect : \"Always prefer functional programming patterns\"","title":"Agent Customization"},{"location":"bundles/foundation.html#try-it-yourself","text":"","title":"Try It Yourself"},{"location":"bundles/foundation.html#exercise-1-codebase-exploration","text":"Open a project you're unfamiliar with and ask: Explore this codebase and explain its architecture. What are the main components and how do they interact? Watch how Foundation's explorer agent systematically maps the project.","title":"Exercise 1: Codebase Exploration"},{"location":"bundles/foundation.html#exercise-2-feature-implementation","text":"In a project, request a new feature: Add a rate limiting middleware to the API. Limit requests to 100 per minute per IP. Observe the architect-builder workflow in action.","title":"Exercise 2: Feature Implementation"},{"location":"bundles/foundation.html#exercise-3-bug-investigation","text":"If you have failing tests: The authentication tests are failing. Investigate and fix the issue. See bug-hunter's hypothesis-driven approach.","title":"Exercise 3: Bug Investigation"},{"location":"bundles/foundation.html#exercise-4-git-workflow","text":"After making changes: Create a commit for these changes with a proper message. Then create a PR with a description of what was changed. Notice how git-ops handles formatting and safety.","title":"Exercise 4: Git Workflow"},{"location":"bundles/foundation.html#exercise-5-security-review","text":"Before deploying: Review the authentication module for security vulnerabilities. Check for OWASP Top 10 issues. Watch security-guardian perform a systematic audit.","title":"Exercise 5: Security Review"},{"location":"bundles/foundation.html#best-practices","text":"","title":"Best Practices"},{"location":"bundles/foundation.html#let-agents-specialize","text":"Don't try to do everything in one prompt. Leverage specialized agents: Design questions \u2192 zen-architect Implementation \u2192 modular-builder Bugs \u2192 bug-hunter Git \u2192 git-ops","title":"Let Agents Specialize"},{"location":"bundles/foundation.html#trust-the-workflow","text":"Foundation's agents coordinate effectively. Let zen-architect plan before modular-builder implements. This produces better results than rushing to code.","title":"Trust the Workflow"},{"location":"bundles/foundation.html#use-task-tracking","text":"For complex work, the todo tool helps track progress: Create a todo list for implementing user authentication. This keeps multi-step work organized and visible.","title":"Use Task Tracking"},{"location":"bundles/foundation.html#embrace-simplicity","text":"Foundation's philosophy is ruthless simplicity. When solutions seem complex, ask: Is there a simpler way to achieve this? The zen-architect excels at finding minimal solutions.","title":"Embrace Simplicity"},{"location":"bundles/foundation.html#summary","text":"Foundation is your everyday development companion. It provides: Complete tooling : File ops, search, shell, web, LSP Expert agents : Specialized for design, implementation, debugging, and more Sensible workflows : Architect-builder pattern, systematic debugging Extensibility : Composes with other bundles for specialized needs Start with Foundation. Extend when you need more. That's the Amplifier way.","title":"Summary"},{"location":"bundles/lsp-python.html","text":"LSP Python Bundle \u00b6 Overview \u00b6 The LSP Python bundle provides semantic code intelligence for Python projects using the Language Server Protocol (LSP) with Pyright as the backend. Unlike text-based search tools like grep, LSP understands your code semantically\u2014it knows the difference between a function definition, a function call, and a comment mentioning that function. This bundle transforms how you navigate and understand Python codebases by providing: Precise symbol resolution - Find where functions, classes, and variables are actually defined Type inference - Get inferred types even in codebases without type hints Call hierarchy tracing - Understand what calls what and map dependencies Semantic references - Find all usages of a symbol (not just text matches) What's Included \u00b6 LSP Tool (Pyright) \u00b6 The bundle configures the LSP tool with Pyright, a fast static type checker for Python. Available operations: Operation Description goToDefinition Jump to where a symbol is defined findReferences Find all usages of a symbol hover Get type information and documentation documentSymbol List all symbols in a file workspaceSymbol Search for symbols across the workspace goToImplementation Find implementations of abstract methods prepareCallHierarchy Prepare for call hierarchy queries incomingCalls Find what calls a function outgoingCalls Find what a function calls python-code-intel Agent \u00b6 A specialized agent for complex, multi-step Python code navigation tasks. While the LSP tool handles single operations, this agent orchestrates multiple LSP calls to answer higher-level questions like: \"Trace the inheritance chain for this class\" \"Map all dependencies of this module\" \"Show me the complete call graph for this function\" When to Use \u00b6 Use LSP Python When You Need \u00b6 Semantic Understanding Over Text Matching # Finding where authenticate() is defined # grep: matches comments, strings, and actual definitions # LSP goToDefinition: finds the exact definition location Type Information # What type does get_connection() return? # Even without type hints, Pyright infers types from implementation def get_connection (): return DatabaseConnection ( host = \"localhost\" ) # LSP hover reveals: () -> DatabaseConnection Call Hierarchy Analysis # Who calls process_payment()? # LSP incomingCalls gives you the complete call graph # grep would match \"process_payment\" in comments and strings too Refactoring Preparation # Before renaming a class, find ALL usages # LSP findReferences catches: # - Direct instantiations # - Type hints # - Inheritance relationships # - Import statements LSP vs Grep: Decision Guide \u00b6 Task Use LSP Use Grep Find function definition goToDefinition Pattern matching Find all callers incomingCalls Text search Get type signature hover Not possible Search across many files Limited Faster Find text in comments Not possible Pattern matching Understand inheritance goToImplementation Manual tracing Rule of thumb: Use LSP for understanding code relationships. Use grep for finding text patterns. Configuration \u00b6 The bundle is pre-configured for Python. To use it, ensure your workspace has Python files and Pyright can resolve your imports. Requirements \u00b6 Python project with standard structure Virtual environment recommended (helps Pyright resolve imports) pyproject.toml or pyrightconfig.json for custom configuration (optional) Pyright Configuration \u00b6 For complex projects, create a pyrightconfig.json : { \"include\" : [ \"src\" ], \"exclude\" : [ \"**/node_modules\" , \"**/__pycache__\" ], \"venvPath\" : \".\" , \"venv\" : \".venv\" , \"pythonVersion\" : \"3.11\" } Try It Yourself \u00b6 Example 1: Find a Definition \u00b6 Navigate to where a function is defined: User: Where is the authenticate function defined? Amplifier uses LSP goToDefinition to find: src/auth/handlers.py:45 - def authenticate(credentials: dict) -> User Example 2: Trace Callers \u00b6 Find all code that calls a specific function: User: What calls the validate_token function? Amplifier uses LSP incomingCalls to map: - src/middleware/auth.py:23 - check_auth() - src/api/routes.py:89 - protected_endpoint() - src/websocket/handlers.py:34 - ws_authenticate() Example 3: Get Type Information \u00b6 Understand types even without annotations: User: What type does create_session return? Amplifier uses LSP hover: def create_session(user_id: str) -> Session Returns a Session object containing authentication state and expiration information. Example 4: Map Module Dependencies \u00b6 Use the python-code-intel agent for complex analysis: User: Map all the dependencies of the payment module Agent traces imports and call relationships: payment/ \u251c\u2500\u2500 processor.py \u2502 \u251c\u2500\u2500 imports: stripe, logging, .models \u2502 \u2514\u2500\u2500 calls: validate_card(), create_charge() \u251c\u2500\u2500 models.py \u2502 \u2514\u2500\u2500 imports: dataclasses, typing \u2514\u2500\u2500 validators.py \u251c\u2500\u2500 imports: re, .exceptions \u2514\u2500\u2500 called by: processor.validate_card() Example 5: Understand Inheritance \u00b6 Trace class hierarchies: User: Show me the inheritance chain for DatabaseAdapter LSP reveals: DatabaseAdapter \u2514\u2500\u2500 inherits from: BaseAdapter (src/core/adapters.py:12) \u2514\u2500\u2500 inherits from: ABC (abc module) Implementations: - PostgresAdapter (src/adapters/postgres.py:8) - SQLiteAdapter (src/adapters/sqlite.py:8) - MockAdapter (tests/mocks.py:15) Example 6: Pre-Refactoring Analysis \u00b6 Before renaming or moving code: User: I want to rename UserService to AuthService. Show me all usages. LSP findReferences locates: Definition: src/services/user.py:10 - class UserService Usages (23 total): src/api/routes.py:5 - from services.user import UserService src/api/routes.py:34 - service = UserService() src/api/routes.py:78 - UserService.get_by_id(user_id) src/tests/test_user.py:12 - class TestUserService ... (19 more) Common Patterns \u00b6 Debugging Type Errors \u00b6 When Pyright reports a type error, use hover to understand what types are inferred: # Error: Argument of type \"str | None\" cannot be assigned to \"str\" result = process ( get_value ()) # What's get_value returning? # Use LSP hover on get_value() to see: # def get_value() -> str | None Understanding Legacy Code \u00b6 When diving into unfamiliar code: Use documentSymbol to see the structure of a file Use goToDefinition to trace imports and dependencies Use incomingCalls to understand how code is used Use hover to understand types without reading implementation Verifying Refactoring Safety \u00b6 Before making changes: Use findReferences to locate all usages Use incomingCalls to understand dependencies Use goToImplementation to find all implementations of an interface Limitations \u00b6 Startup time: Pyright needs to index your workspace on first use Dynamic code: Highly dynamic Python (heavy use of getattr , metaclasses) may not be fully understood External libraries: Type stubs needed for best results with third-party packages Large workspaces: Very large codebases may have slower response times Related Bundles \u00b6 lsp - Base LSP bundle (language-agnostic) foundation - Core development tools including grep for text search Summary \u00b6 The LSP Python bundle brings IDE-level code intelligence to your Amplifier workflow. Use it when you need to truly understand code relationships\u2014not just find text patterns. The semantic understanding it provides is invaluable for navigating complex codebases, preparing refactoring, and debugging type issues. For simple text searches, grep remains faster. But when you need to answer \"what calls this?\" or \"what type is this?\", LSP Python is the right tool.","title":"LSP Python"},{"location":"bundles/lsp-python.html#lsp-python-bundle","text":"","title":"LSP Python Bundle"},{"location":"bundles/lsp-python.html#overview","text":"The LSP Python bundle provides semantic code intelligence for Python projects using the Language Server Protocol (LSP) with Pyright as the backend. Unlike text-based search tools like grep, LSP understands your code semantically\u2014it knows the difference between a function definition, a function call, and a comment mentioning that function. This bundle transforms how you navigate and understand Python codebases by providing: Precise symbol resolution - Find where functions, classes, and variables are actually defined Type inference - Get inferred types even in codebases without type hints Call hierarchy tracing - Understand what calls what and map dependencies Semantic references - Find all usages of a symbol (not just text matches)","title":"Overview"},{"location":"bundles/lsp-python.html#whats-included","text":"","title":"What's Included"},{"location":"bundles/lsp-python.html#lsp-tool-pyright","text":"The bundle configures the LSP tool with Pyright, a fast static type checker for Python. Available operations: Operation Description goToDefinition Jump to where a symbol is defined findReferences Find all usages of a symbol hover Get type information and documentation documentSymbol List all symbols in a file workspaceSymbol Search for symbols across the workspace goToImplementation Find implementations of abstract methods prepareCallHierarchy Prepare for call hierarchy queries incomingCalls Find what calls a function outgoingCalls Find what a function calls","title":"LSP Tool (Pyright)"},{"location":"bundles/lsp-python.html#python-code-intel-agent","text":"A specialized agent for complex, multi-step Python code navigation tasks. While the LSP tool handles single operations, this agent orchestrates multiple LSP calls to answer higher-level questions like: \"Trace the inheritance chain for this class\" \"Map all dependencies of this module\" \"Show me the complete call graph for this function\"","title":"python-code-intel Agent"},{"location":"bundles/lsp-python.html#when-to-use","text":"","title":"When to Use"},{"location":"bundles/lsp-python.html#use-lsp-python-when-you-need","text":"Semantic Understanding Over Text Matching # Finding where authenticate() is defined # grep: matches comments, strings, and actual definitions # LSP goToDefinition: finds the exact definition location Type Information # What type does get_connection() return? # Even without type hints, Pyright infers types from implementation def get_connection (): return DatabaseConnection ( host = \"localhost\" ) # LSP hover reveals: () -> DatabaseConnection Call Hierarchy Analysis # Who calls process_payment()? # LSP incomingCalls gives you the complete call graph # grep would match \"process_payment\" in comments and strings too Refactoring Preparation # Before renaming a class, find ALL usages # LSP findReferences catches: # - Direct instantiations # - Type hints # - Inheritance relationships # - Import statements","title":"Use LSP Python When You Need"},{"location":"bundles/lsp-python.html#lsp-vs-grep-decision-guide","text":"Task Use LSP Use Grep Find function definition goToDefinition Pattern matching Find all callers incomingCalls Text search Get type signature hover Not possible Search across many files Limited Faster Find text in comments Not possible Pattern matching Understand inheritance goToImplementation Manual tracing Rule of thumb: Use LSP for understanding code relationships. Use grep for finding text patterns.","title":"LSP vs Grep: Decision Guide"},{"location":"bundles/lsp-python.html#configuration","text":"The bundle is pre-configured for Python. To use it, ensure your workspace has Python files and Pyright can resolve your imports.","title":"Configuration"},{"location":"bundles/lsp-python.html#requirements","text":"Python project with standard structure Virtual environment recommended (helps Pyright resolve imports) pyproject.toml or pyrightconfig.json for custom configuration (optional)","title":"Requirements"},{"location":"bundles/lsp-python.html#pyright-configuration","text":"For complex projects, create a pyrightconfig.json : { \"include\" : [ \"src\" ], \"exclude\" : [ \"**/node_modules\" , \"**/__pycache__\" ], \"venvPath\" : \".\" , \"venv\" : \".venv\" , \"pythonVersion\" : \"3.11\" }","title":"Pyright Configuration"},{"location":"bundles/lsp-python.html#try-it-yourself","text":"","title":"Try It Yourself"},{"location":"bundles/lsp-python.html#example-1-find-a-definition","text":"Navigate to where a function is defined: User: Where is the authenticate function defined? Amplifier uses LSP goToDefinition to find: src/auth/handlers.py:45 - def authenticate(credentials: dict) -> User","title":"Example 1: Find a Definition"},{"location":"bundles/lsp-python.html#example-2-trace-callers","text":"Find all code that calls a specific function: User: What calls the validate_token function? Amplifier uses LSP incomingCalls to map: - src/middleware/auth.py:23 - check_auth() - src/api/routes.py:89 - protected_endpoint() - src/websocket/handlers.py:34 - ws_authenticate()","title":"Example 2: Trace Callers"},{"location":"bundles/lsp-python.html#example-3-get-type-information","text":"Understand types even without annotations: User: What type does create_session return? Amplifier uses LSP hover: def create_session(user_id: str) -> Session Returns a Session object containing authentication state and expiration information.","title":"Example 3: Get Type Information"},{"location":"bundles/lsp-python.html#example-4-map-module-dependencies","text":"Use the python-code-intel agent for complex analysis: User: Map all the dependencies of the payment module Agent traces imports and call relationships: payment/ \u251c\u2500\u2500 processor.py \u2502 \u251c\u2500\u2500 imports: stripe, logging, .models \u2502 \u2514\u2500\u2500 calls: validate_card(), create_charge() \u251c\u2500\u2500 models.py \u2502 \u2514\u2500\u2500 imports: dataclasses, typing \u2514\u2500\u2500 validators.py \u251c\u2500\u2500 imports: re, .exceptions \u2514\u2500\u2500 called by: processor.validate_card()","title":"Example 4: Map Module Dependencies"},{"location":"bundles/lsp-python.html#example-5-understand-inheritance","text":"Trace class hierarchies: User: Show me the inheritance chain for DatabaseAdapter LSP reveals: DatabaseAdapter \u2514\u2500\u2500 inherits from: BaseAdapter (src/core/adapters.py:12) \u2514\u2500\u2500 inherits from: ABC (abc module) Implementations: - PostgresAdapter (src/adapters/postgres.py:8) - SQLiteAdapter (src/adapters/sqlite.py:8) - MockAdapter (tests/mocks.py:15)","title":"Example 5: Understand Inheritance"},{"location":"bundles/lsp-python.html#example-6-pre-refactoring-analysis","text":"Before renaming or moving code: User: I want to rename UserService to AuthService. Show me all usages. LSP findReferences locates: Definition: src/services/user.py:10 - class UserService Usages (23 total): src/api/routes.py:5 - from services.user import UserService src/api/routes.py:34 - service = UserService() src/api/routes.py:78 - UserService.get_by_id(user_id) src/tests/test_user.py:12 - class TestUserService ... (19 more)","title":"Example 6: Pre-Refactoring Analysis"},{"location":"bundles/lsp-python.html#common-patterns","text":"","title":"Common Patterns"},{"location":"bundles/lsp-python.html#debugging-type-errors","text":"When Pyright reports a type error, use hover to understand what types are inferred: # Error: Argument of type \"str | None\" cannot be assigned to \"str\" result = process ( get_value ()) # What's get_value returning? # Use LSP hover on get_value() to see: # def get_value() -> str | None","title":"Debugging Type Errors"},{"location":"bundles/lsp-python.html#understanding-legacy-code","text":"When diving into unfamiliar code: Use documentSymbol to see the structure of a file Use goToDefinition to trace imports and dependencies Use incomingCalls to understand how code is used Use hover to understand types without reading implementation","title":"Understanding Legacy Code"},{"location":"bundles/lsp-python.html#verifying-refactoring-safety","text":"Before making changes: Use findReferences to locate all usages Use incomingCalls to understand dependencies Use goToImplementation to find all implementations of an interface","title":"Verifying Refactoring Safety"},{"location":"bundles/lsp-python.html#limitations","text":"Startup time: Pyright needs to index your workspace on first use Dynamic code: Highly dynamic Python (heavy use of getattr , metaclasses) may not be fully understood External libraries: Type stubs needed for best results with third-party packages Large workspaces: Very large codebases may have slower response times","title":"Limitations"},{"location":"bundles/lsp-python.html#related-bundles","text":"lsp - Base LSP bundle (language-agnostic) foundation - Core development tools including grep for text search","title":"Related Bundles"},{"location":"bundles/lsp-python.html#summary","text":"The LSP Python bundle brings IDE-level code intelligence to your Amplifier workflow. Use it when you need to truly understand code relationships\u2014not just find text patterns. The semantic understanding it provides is invaluable for navigating complex codebases, preparing refactoring, and debugging type issues. For simple text searches, grep remains faster. But when you need to answer \"what calls this?\" or \"what type is this?\", LSP Python is the right tool.","title":"Summary"},{"location":"bundles/recipes.html","text":"Recipes Bundle \u00b6 The Recipes Bundle provides workflow orchestration capabilities for Amplifier, enabling you to define multi-step AI agent workflows as declarative YAML specifications. Think of recipes as \"playbooks\" that coordinate complex, multi-step tasks with built-in state management, error handling, and human-in-the-loop approval gates. Overview \u00b6 Recipes solve a fundamental challenge in AI-assisted development: coordinating complex tasks that require multiple steps, different agent capabilities, and human oversight. Instead of manually orchestrating each step, you define the workflow once and let the recipe system handle execution, state persistence, and error recovery. Key characteristics: Declarative : Define what should happen, not how to execute it Resumable : Sessions persist state so interrupted workflows can continue Composable : Build complex workflows from simple, reusable steps Observable : Track progress and inspect state at any point Human-in-the-loop : Add approval gates for critical decisions What's Included \u00b6 The recipes Tool \u00b6 The core tool for executing and managing recipe workflows: # Execute a recipe recipes : operation : execute recipe_path : ./my-recipe.yaml context : target_file : src/auth.py # Resume an interrupted session recipes : operation : resume session_id : recipe_20251118_143022_a3f2 # List active sessions recipes : operation : list # Validate recipe structure recipes : operation : validate recipe_path : ./my-recipe.yaml # Approval operations (for staged recipes) recipes : operation : approvals # List pending approvals recipes : operation : approve session_id : \"...\" stage_name : \"planning\" recipes : operation : deny session_id : \"...\" stage_name : \"planning\" reason : \"needs revision\" The recipe-author Agent \u00b6 A specialized agent for creating, validating, and refining recipe specifications: Conversational design : Guides you through recipe creation with clarifying questions Schema validation : Ensures recipes conform to the specification Pattern guidance : Recommends best practices for workflow orchestration Error detection : Identifies common mistakes before execution When to Use \u00b6 Good Use Cases \u00b6 Scenario Why Recipes Help Code review workflows Coordinate analysis, security check, and summary steps Multi-file refactoring Plan changes, implement across files, validate results Release processes Version bump, changelog, tests, PR creation with approvals Research tasks Gather information from multiple sources, synthesize findings Migration projects Analyze scope, plan phases, execute with checkpoints When Not to Use \u00b6 Simple, single-step tasks : Direct agent invocation is simpler Highly interactive work : Recipes are for autonomous execution Unpredictable workflows : If you can't define steps upfront, use agents directly Recipe Anatomy \u00b6 Basic Structure (Flat Recipe) \u00b6 name : code-review description : Review code for quality and security issues # Input parameters inputs : file_path : type : string required : true description : Path to the file to review # Sequential steps steps : - id : analyze agent : foundation:zen-architect instruction : | Analyze the code structure in {{ file_path }}. Identify complexity issues and improvement opportunities. - id : security agent : foundation:security-guardian instruction : | Review {{ file_path }} for security vulnerabilities. Check for OWASP Top 10 issues. - id : summarize agent : foundation:file-ops instruction : | Create a review summary combining: - Analysis findings: {{ steps.analyze.result }} - Security findings: {{ steps.security.result }} Staged Recipe (With Approval Gates) \u00b6 name : release-process description : Coordinated release with human approval gates inputs : version : type : string required : true stages : planning : approval_required : true steps : - id : changelog agent : foundation:explorer instruction : | Gather all changes since last release. Draft changelog for version {{ version }}. implementation : approval_required : true steps : - id : version_bump agent : foundation:file-ops instruction : | Update version to {{ version }} in package files. - id : create_pr agent : foundation:git-ops instruction : | Create release PR with changelog from planning stage. Key Concepts \u00b6 Context and Variable Interpolation \u00b6 Recipes support Jinja2-style templating for dynamic values: # Input variables instruction : \"Review {{ file_path }}\" # Step results instruction : \"Build on analysis: {{ steps.analyze.result }}\" # Stage results (staged recipes) instruction : \"Use plan from: {{ stages.planning.result }}\" Error Handling \u00b6 Configure behavior when steps fail: steps : - id : risky_operation agent : foundation:modular-builder instruction : \"Attempt complex refactoring\" on_error : continue # Options: fail (default), continue, retry retry : max_attempts : 3 delay : 5 # seconds Timeouts \u00b6 Prevent runaway executions: steps : - id : long_running agent : foundation:explorer instruction : \"Deep codebase analysis\" timeout : 300 # 5 minutes Foreach Loops \u00b6 Iterate over collections: steps : - id : review_files foreach : \"{{ input_files }}\" as : current_file agent : foundation:zen-architect instruction : \"Review {{ current_file }}\" Conditional Execution \u00b6 Run steps based on conditions: steps : - id : deploy when : \"{{ steps.tests.result.success == true }}\" agent : foundation:integration-specialist instruction : \"Deploy to staging\" Working with Sessions \u00b6 Session Lifecycle \u00b6 Created : Recipe parsed and validated Running : Steps executing sequentially Paused : Waiting for approval (staged recipes) Completed : All steps finished successfully Failed : Unrecoverable error encountered Listing and Resuming \u00b6 # In Amplifier, use the recipes tool: # List all active sessions recipes operation = list # Resume a specific session recipes operation = resume session_id = recipe_20251118_143022_a3f2 Approval Workflow \u00b6 For staged recipes with approval_required: true : # Check pending approvals recipes operation = approvals # Approve a stage to continue recipes operation = approve session_id = \"...\" stage_name = \"planning\" # Deny with reason (stops execution) recipes operation = deny session_id = \"...\" stage_name = \"planning\" reason = \"needs changes\" Try It Yourself \u00b6 Example 1: Simple Code Review Recipe \u00b6 Create code-review.yaml : name : code-review description : Comprehensive code review workflow inputs : file_path : type : string required : true steps : - id : structure agent : foundation:zen-architect instruction : | Review the code structure of {{ file_path }}. Assess: complexity, readability, adherence to SOLID principles. - id : security agent : foundation:security-guardian instruction : | Security review of {{ file_path }}. Check for common vulnerabilities. - id : report agent : foundation:file-ops instruction : | Generate a markdown review report combining: ## Structure Review {{ steps.structure.result }} ## Security Review {{ steps.security.result }} Execute it: Use the recipes tool to execute code-review.yaml with file_path set to src/auth.py Example 2: Research and Summarize \u00b6 Create research.yaml : name : topic-research description : Research a topic and produce a summary inputs : topic : type : string required : true depth : type : string default : \"moderate\" steps : - id : gather agent : foundation:web-research instruction : | Research \"{{ topic }}\" with {{ depth }} depth. Find authoritative sources and key information. - id : analyze agent : foundation:zen-architect instruction : | Analyze the research findings: {{ steps.gather.result }} Identify key themes, contradictions, and knowledge gaps. - id : synthesize agent : foundation:file-ops instruction : | Create a comprehensive summary document on \"{{ topic }}\": Research: {{ steps.gather.result }} Analysis: {{ steps.analyze.result }} Example 3: Using the Recipe Author \u00b6 For complex recipes, use the recipe-author agent: I need a recipe that: 1. Scans a codebase for TODO comments 2. Categorizes them by priority 3. Creates GitHub issues for high-priority items 4. Requires approval before creating issues The recipe-author agent will guide you through the design, asking clarifying questions and generating valid YAML. Best Practices \u00b6 Start simple : Begin with flat recipes before adding stages Use meaningful step IDs : They appear in logs and result references Provide clear instructions : Agents work best with specific, detailed prompts Add approval gates sparingly : Only where human judgment is truly needed Test with validate first : Catch schema errors before execution Keep steps focused : One clear objective per step Common Patterns \u00b6 Sequential Analysis Pipeline \u00b6 steps : - id : gather # Collect information - id : analyze # Process findings - id : decide # Make recommendations - id : implement # Execute decisions Fan-Out/Fan-In \u00b6 steps : - id : analyze_all foreach : \"{{ files }}\" as : file agent : foundation:explorer - id : combine instruction : \"Synthesize: {{ steps.analyze_all.results }}\" Approval Checkpoint \u00b6 stages : planning : approval_required : true steps : [ ... ] execution : # Only runs after planning is approved steps : [ ... ] Troubleshooting \u00b6 Issue Solution Recipe won't validate Check YAML syntax, ensure required fields present Step fails immediately Verify agent name is correct, check instruction format Variables not interpolating Use {{ }} syntax, check step ID references Session won't resume Verify session_id, check if session completed or failed Approval stuck Use recipes operation=approvals to see pending gates","title":"Recipes"},{"location":"bundles/recipes.html#recipes-bundle","text":"The Recipes Bundle provides workflow orchestration capabilities for Amplifier, enabling you to define multi-step AI agent workflows as declarative YAML specifications. Think of recipes as \"playbooks\" that coordinate complex, multi-step tasks with built-in state management, error handling, and human-in-the-loop approval gates.","title":"Recipes Bundle"},{"location":"bundles/recipes.html#overview","text":"Recipes solve a fundamental challenge in AI-assisted development: coordinating complex tasks that require multiple steps, different agent capabilities, and human oversight. Instead of manually orchestrating each step, you define the workflow once and let the recipe system handle execution, state persistence, and error recovery. Key characteristics: Declarative : Define what should happen, not how to execute it Resumable : Sessions persist state so interrupted workflows can continue Composable : Build complex workflows from simple, reusable steps Observable : Track progress and inspect state at any point Human-in-the-loop : Add approval gates for critical decisions","title":"Overview"},{"location":"bundles/recipes.html#whats-included","text":"","title":"What's Included"},{"location":"bundles/recipes.html#the-recipes-tool","text":"The core tool for executing and managing recipe workflows: # Execute a recipe recipes : operation : execute recipe_path : ./my-recipe.yaml context : target_file : src/auth.py # Resume an interrupted session recipes : operation : resume session_id : recipe_20251118_143022_a3f2 # List active sessions recipes : operation : list # Validate recipe structure recipes : operation : validate recipe_path : ./my-recipe.yaml # Approval operations (for staged recipes) recipes : operation : approvals # List pending approvals recipes : operation : approve session_id : \"...\" stage_name : \"planning\" recipes : operation : deny session_id : \"...\" stage_name : \"planning\" reason : \"needs revision\"","title":"The recipes Tool"},{"location":"bundles/recipes.html#the-recipe-author-agent","text":"A specialized agent for creating, validating, and refining recipe specifications: Conversational design : Guides you through recipe creation with clarifying questions Schema validation : Ensures recipes conform to the specification Pattern guidance : Recommends best practices for workflow orchestration Error detection : Identifies common mistakes before execution","title":"The recipe-author Agent"},{"location":"bundles/recipes.html#when-to-use","text":"","title":"When to Use"},{"location":"bundles/recipes.html#good-use-cases","text":"Scenario Why Recipes Help Code review workflows Coordinate analysis, security check, and summary steps Multi-file refactoring Plan changes, implement across files, validate results Release processes Version bump, changelog, tests, PR creation with approvals Research tasks Gather information from multiple sources, synthesize findings Migration projects Analyze scope, plan phases, execute with checkpoints","title":"Good Use Cases"},{"location":"bundles/recipes.html#when-not-to-use","text":"Simple, single-step tasks : Direct agent invocation is simpler Highly interactive work : Recipes are for autonomous execution Unpredictable workflows : If you can't define steps upfront, use agents directly","title":"When Not to Use"},{"location":"bundles/recipes.html#recipe-anatomy","text":"","title":"Recipe Anatomy"},{"location":"bundles/recipes.html#basic-structure-flat-recipe","text":"name : code-review description : Review code for quality and security issues # Input parameters inputs : file_path : type : string required : true description : Path to the file to review # Sequential steps steps : - id : analyze agent : foundation:zen-architect instruction : | Analyze the code structure in {{ file_path }}. Identify complexity issues and improvement opportunities. - id : security agent : foundation:security-guardian instruction : | Review {{ file_path }} for security vulnerabilities. Check for OWASP Top 10 issues. - id : summarize agent : foundation:file-ops instruction : | Create a review summary combining: - Analysis findings: {{ steps.analyze.result }} - Security findings: {{ steps.security.result }}","title":"Basic Structure (Flat Recipe)"},{"location":"bundles/recipes.html#staged-recipe-with-approval-gates","text":"name : release-process description : Coordinated release with human approval gates inputs : version : type : string required : true stages : planning : approval_required : true steps : - id : changelog agent : foundation:explorer instruction : | Gather all changes since last release. Draft changelog for version {{ version }}. implementation : approval_required : true steps : - id : version_bump agent : foundation:file-ops instruction : | Update version to {{ version }} in package files. - id : create_pr agent : foundation:git-ops instruction : | Create release PR with changelog from planning stage.","title":"Staged Recipe (With Approval Gates)"},{"location":"bundles/recipes.html#key-concepts","text":"","title":"Key Concepts"},{"location":"bundles/recipes.html#context-and-variable-interpolation","text":"Recipes support Jinja2-style templating for dynamic values: # Input variables instruction : \"Review {{ file_path }}\" # Step results instruction : \"Build on analysis: {{ steps.analyze.result }}\" # Stage results (staged recipes) instruction : \"Use plan from: {{ stages.planning.result }}\"","title":"Context and Variable Interpolation"},{"location":"bundles/recipes.html#error-handling","text":"Configure behavior when steps fail: steps : - id : risky_operation agent : foundation:modular-builder instruction : \"Attempt complex refactoring\" on_error : continue # Options: fail (default), continue, retry retry : max_attempts : 3 delay : 5 # seconds","title":"Error Handling"},{"location":"bundles/recipes.html#timeouts","text":"Prevent runaway executions: steps : - id : long_running agent : foundation:explorer instruction : \"Deep codebase analysis\" timeout : 300 # 5 minutes","title":"Timeouts"},{"location":"bundles/recipes.html#foreach-loops","text":"Iterate over collections: steps : - id : review_files foreach : \"{{ input_files }}\" as : current_file agent : foundation:zen-architect instruction : \"Review {{ current_file }}\"","title":"Foreach Loops"},{"location":"bundles/recipes.html#conditional-execution","text":"Run steps based on conditions: steps : - id : deploy when : \"{{ steps.tests.result.success == true }}\" agent : foundation:integration-specialist instruction : \"Deploy to staging\"","title":"Conditional Execution"},{"location":"bundles/recipes.html#working-with-sessions","text":"","title":"Working with Sessions"},{"location":"bundles/recipes.html#session-lifecycle","text":"Created : Recipe parsed and validated Running : Steps executing sequentially Paused : Waiting for approval (staged recipes) Completed : All steps finished successfully Failed : Unrecoverable error encountered","title":"Session Lifecycle"},{"location":"bundles/recipes.html#listing-and-resuming","text":"# In Amplifier, use the recipes tool: # List all active sessions recipes operation = list # Resume a specific session recipes operation = resume session_id = recipe_20251118_143022_a3f2","title":"Listing and Resuming"},{"location":"bundles/recipes.html#approval-workflow","text":"For staged recipes with approval_required: true : # Check pending approvals recipes operation = approvals # Approve a stage to continue recipes operation = approve session_id = \"...\" stage_name = \"planning\" # Deny with reason (stops execution) recipes operation = deny session_id = \"...\" stage_name = \"planning\" reason = \"needs changes\"","title":"Approval Workflow"},{"location":"bundles/recipes.html#try-it-yourself","text":"","title":"Try It Yourself"},{"location":"bundles/recipes.html#example-1-simple-code-review-recipe","text":"Create code-review.yaml : name : code-review description : Comprehensive code review workflow inputs : file_path : type : string required : true steps : - id : structure agent : foundation:zen-architect instruction : | Review the code structure of {{ file_path }}. Assess: complexity, readability, adherence to SOLID principles. - id : security agent : foundation:security-guardian instruction : | Security review of {{ file_path }}. Check for common vulnerabilities. - id : report agent : foundation:file-ops instruction : | Generate a markdown review report combining: ## Structure Review {{ steps.structure.result }} ## Security Review {{ steps.security.result }} Execute it: Use the recipes tool to execute code-review.yaml with file_path set to src/auth.py","title":"Example 1: Simple Code Review Recipe"},{"location":"bundles/recipes.html#example-2-research-and-summarize","text":"Create research.yaml : name : topic-research description : Research a topic and produce a summary inputs : topic : type : string required : true depth : type : string default : \"moderate\" steps : - id : gather agent : foundation:web-research instruction : | Research \"{{ topic }}\" with {{ depth }} depth. Find authoritative sources and key information. - id : analyze agent : foundation:zen-architect instruction : | Analyze the research findings: {{ steps.gather.result }} Identify key themes, contradictions, and knowledge gaps. - id : synthesize agent : foundation:file-ops instruction : | Create a comprehensive summary document on \"{{ topic }}\": Research: {{ steps.gather.result }} Analysis: {{ steps.analyze.result }}","title":"Example 2: Research and Summarize"},{"location":"bundles/recipes.html#example-3-using-the-recipe-author","text":"For complex recipes, use the recipe-author agent: I need a recipe that: 1. Scans a codebase for TODO comments 2. Categorizes them by priority 3. Creates GitHub issues for high-priority items 4. Requires approval before creating issues The recipe-author agent will guide you through the design, asking clarifying questions and generating valid YAML.","title":"Example 3: Using the Recipe Author"},{"location":"bundles/recipes.html#best-practices","text":"Start simple : Begin with flat recipes before adding stages Use meaningful step IDs : They appear in logs and result references Provide clear instructions : Agents work best with specific, detailed prompts Add approval gates sparingly : Only where human judgment is truly needed Test with validate first : Catch schema errors before execution Keep steps focused : One clear objective per step","title":"Best Practices"},{"location":"bundles/recipes.html#common-patterns","text":"","title":"Common Patterns"},{"location":"bundles/recipes.html#sequential-analysis-pipeline","text":"steps : - id : gather # Collect information - id : analyze # Process findings - id : decide # Make recommendations - id : implement # Execute decisions","title":"Sequential Analysis Pipeline"},{"location":"bundles/recipes.html#fan-outfan-in","text":"steps : - id : analyze_all foreach : \"{{ files }}\" as : file agent : foundation:explorer - id : combine instruction : \"Synthesize: {{ steps.analyze_all.results }}\"","title":"Fan-Out/Fan-In"},{"location":"bundles/recipes.html#approval-checkpoint","text":"stages : planning : approval_required : true steps : [ ... ] execution : # Only runs after planning is approved steps : [ ... ]","title":"Approval Checkpoint"},{"location":"bundles/recipes.html#troubleshooting","text":"Issue Solution Recipe won't validate Check YAML syntax, ensure required fields present Step fails immediately Verify agent name is correct, check instruction format Variables not interpolating Use {{ }} syntax, check step ID references Session won't resume Verify session_id, check if session completed or failed Approval stuck Use recipes operation=approvals to see pending gates","title":"Troubleshooting"},{"location":"concepts/index.html","text":"Core Concepts \u00b6 Understanding Amplifier's architecture and design philosophy is key to building effective AI-powered applications. This section explains the foundational concepts that power the system. These concepts build on each other\u2014start with the basics and progress to more advanced architectural patterns. Section Contents \u00b6 Page Description Sessions Conversation state and lifecycle management Agents Autonomous task executors with tools Providers LLM backends (Anthropic, OpenAI, Azure) Modules Extensibility through the module system Hooks Event interception and custom behaviors Context How agents receive and manage information Tool Architecture How tools work under the hood Multi-Agent Patterns Coordination between multiple agents Quick Tips \u00b6 Sessions are stateful \u2014 Each session maintains full conversation history Agents are stateless \u2014 Agent definitions are templates; sessions hold state Modules are composable \u2014 Mix and match capabilities without conflicts Hooks are powerful \u2014 Intercept any event for custom behavior Context is king \u2014 What the agent knows determines what it can do Core Architecture \u00b6 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 Application \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 Bundles (composed configurations) \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 Modules: Providers | Tools | Hooks \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 Amplifier Kernel \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 Key Principles \u00b6 Principle Description Thin Bundles Bundles compose modules; they don't implement Module Contracts Clear interfaces between components Event-Driven Hooks respond to lifecycle events Minimal Core Kernel is small; features live in modules Where to Start \u00b6 Just getting started? Read Sessions first \u2014 it's the foundation for everything else and explains how conversations work. Want to customize behavior? Jump to Hooks to learn how to intercept and modify agent behavior. Building multi-agent systems? Start with Agents then proceed to Multi-Agent Patterns . Concept Dependencies \u00b6 Sessions \u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u25ba Agents \u2500\u2500\u25ba Multi-Agent \u2502 Providers \u2500\u2500\u2500\u2500\u2524 \u2502 Modules \u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u25ba Hooks \u2502 Context \u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u25ba Tool Architecture Related Sections \u00b6 Quickstart: Your First Agent Advanced: Kernel Internals Bundles: Bundle Composition","title":"Overview"},{"location":"concepts/index.html#core-concepts","text":"Understanding Amplifier's architecture and design philosophy is key to building effective AI-powered applications. This section explains the foundational concepts that power the system. These concepts build on each other\u2014start with the basics and progress to more advanced architectural patterns.","title":"Core Concepts"},{"location":"concepts/index.html#section-contents","text":"Page Description Sessions Conversation state and lifecycle management Agents Autonomous task executors with tools Providers LLM backends (Anthropic, OpenAI, Azure) Modules Extensibility through the module system Hooks Event interception and custom behaviors Context How agents receive and manage information Tool Architecture How tools work under the hood Multi-Agent Patterns Coordination between multiple agents","title":"Section Contents"},{"location":"concepts/index.html#quick-tips","text":"Sessions are stateful \u2014 Each session maintains full conversation history Agents are stateless \u2014 Agent definitions are templates; sessions hold state Modules are composable \u2014 Mix and match capabilities without conflicts Hooks are powerful \u2014 Intercept any event for custom behavior Context is king \u2014 What the agent knows determines what it can do","title":"Quick Tips"},{"location":"concepts/index.html#core-architecture","text":"\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 Application \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 Bundles (composed configurations) \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 Modules: Providers | Tools | Hooks \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 Amplifier Kernel \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Core Architecture"},{"location":"concepts/index.html#key-principles","text":"Principle Description Thin Bundles Bundles compose modules; they don't implement Module Contracts Clear interfaces between components Event-Driven Hooks respond to lifecycle events Minimal Core Kernel is small; features live in modules","title":"Key Principles"},{"location":"concepts/index.html#where-to-start","text":"Just getting started? Read Sessions first \u2014 it's the foundation for everything else and explains how conversations work. Want to customize behavior? Jump to Hooks to learn how to intercept and modify agent behavior. Building multi-agent systems? Start with Agents then proceed to Multi-Agent Patterns .","title":"Where to Start"},{"location":"concepts/index.html#concept-dependencies","text":"Sessions \u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u25ba Agents \u2500\u2500\u25ba Multi-Agent \u2502 Providers \u2500\u2500\u2500\u2500\u2524 \u2502 Modules \u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u25ba Hooks \u2502 Context \u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u25ba Tool Architecture","title":"Concept Dependencies"},{"location":"concepts/index.html#related-sections","text":"Quickstart: Your First Agent Advanced: Kernel Internals Bundles: Bundle Composition","title":"Related Sections"},{"location":"concepts/agents.html","text":"Understanding Agents \u00b6 Agents are specialized AI assistants that handle complex, multi-step tasks autonomously. They're one of Amplifier's most powerful features for managing sophisticated workflows without overwhelming your main conversation context. What is an Agent? \u00b6 Key Insight: Agents ARE bundles. Same file format, same structure. An agent is simply a bundle that's designed to be launched as a sub-session via the task tool. There's no special \"agent format\" - any bundle can potentially act as an agent if it's configured for autonomous task execution. # This IS an agent - it's just a bundle! name : code-reviewer version : 1.0.0 description : Reviews code for quality and best practices instructions : | You are a code review specialist. Analyze the provided code for bugs, style issues, and improvement opportunities. Provide actionable feedback with specific line references. tools : - read_file - grep - glob The magic isn't in the format - it's in how agents are invoked. When you call an agent via the task tool, Amplifier: Spawns a fresh sub-session Loads the agent's bundle configuration Executes the task autonomously Returns results to your main session How Agents Work \u00b6 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 Main Session \u2502 task \u2502 Sub-Session \u2502 \u2502 (you) \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u25b6 \u2502 (agent) \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 - Your context \u2502 \u2502 - Fresh context \u2502 \u2502 - Your tools \u2502 \u2502 - Agent tools \u2502 \u2502 - Conversation \u2502 \u2502 - Single task \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u2502 \u2502 result \u2502 \u25c0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 The Sub-Session Model \u00b6 Each agent runs in complete isolation: Fresh context : Agents start with no memory of your conversation Scoped tools : Only tools defined in the agent's bundle are available Single mission : Agents focus on one specific task One response : Agents return a single final result This isolation is intentional. It means: Your main session stays uncluttered Agents can focus deeply on their specialty Complex tasks don't pollute your context window Multiple agents can run in parallel Information Flow \u00b6 You: \"Review the authentication module\" \u2502 \u25bc \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 task tool invocation \u2502 \u2502 \u2502 \u2502 agent: \"foundation:code-reviewer\" \u2502 \u2502 instruction: \"Review src/auth/*.py \u2502 \u2502 for security issues\" \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u25bc \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 Agent Sub-Session \u2502 \u2502 \u2502 \u2502 - Reads files \u2502 \u2502 - Analyzes patterns \u2502 \u2502 - Checks security practices \u2502 \u2502 - Generates detailed report \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u25bc Final report returned to main session Using Agents \u00b6 Agents are invoked through the task tool. The key parameters are: Parameter Required Description agent Yes Agent identifier (e.g., foundation:zen-architect ) instruction Yes Detailed task description session_id No Resume a previous agent session Writing Good Instructions \u00b6 Since agents start with zero context, your instructions must be comprehensive: # Bad - too vague instruction : \"Fix the bug\" # Good - complete context instruction : | Fix the KeyError in src/processor.py around line 45. Context: - The error occurs when processing empty input arrays - Expected behavior: return empty result, not crash - Related files: src/processor.py, src/validator.py Return: - What you changed and why - How to verify the fix Parallel Agent Execution \u00b6 Launch multiple agents simultaneously for independent tasks: \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 Main Session\u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25b6 Agent A (code review) \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25b6 Agent B (test coverage) \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25b6 Agent C (documentation) All three run concurrently, returning results as they complete. Built-in Agents \u00b6 Amplifier Foundation provides specialized agents for common workflows: Agent Purpose When to Use foundation:zen-architect Architecture design & code planning Starting new features, major refactors foundation:modular-builder Implementation from specs Building code after architecture phase foundation:bug-hunter Systematic debugging Tracking down errors and failures foundation:explorer Deep codebase reconnaissance Understanding unfamiliar code foundation:git-ops Git and GitHub operations Commits, PRs, branch management foundation:test-coverage Test analysis & gap identification Ensuring adequate test coverage foundation:web-research Internet search & fetching Finding external documentation foundation:security-guardian Security review & auditing Pre-deployment checks foundation:integration-specialist External API & MCP integration Connecting to services foundation:post-task-cleanup Codebase hygiene After completing major tasks Specialized Domain Agents \u00b6 Agent Purpose lsp:code-navigator Semantic code navigation via LSP lsp-python:python-code-intel Python-specific code intelligence recipes:recipe-author Creating and validating recipes design-intelligence:* UI/UX design specialists Creating Your Own Agents \u00b6 Any bundle can become an agent. Here's the pattern: 1. Define the Specialty \u00b6 # .amplifier/agents/pr-reviewer.yaml name : pr-reviewer version : 1.0.0 description : Reviews pull requests for quality and completeness instructions : | You are a PR review specialist. When given a PR or branch: 1. Analyze the changes for: - Code quality and style - Test coverage - Documentation updates - Breaking changes 2. Provide structured feedback: - Summary of changes - Issues found (critical/minor) - Suggestions for improvement - Approval recommendation tools : - read_file - grep - glob - bash # for git operations 2. Scope the Tools \u00b6 Only include tools the agent actually needs: # Minimal toolset for a documentation agent tools : - read_file - write_file - glob # Richer toolset for a debugging agent tools : - read_file - grep - glob - bash - LSP 3. Write Clear Instructions \u00b6 Agent instructions should specify: Role : What the agent specializes in Process : How to approach tasks Output format : What to return Boundaries : What NOT to do 4. Register for Discovery \u00b6 Place agents where they can be found: .amplifier/ agents/ pr-reviewer.yaml # Project-specific ~/.amplifier/ agents/ my-helper.yaml # Personal agents Agents vs Bundles \u00b6 The distinction is about usage pattern , not file format: Aspect Bundle (as context) Bundle (as agent) Loading Included in session Spawns sub-session Context Shared with main Isolated Lifecycle Persistent Task-scoped Invocation @mention or auto task tool Response Ongoing conversation Single result When to Use Each \u00b6 Use as Context (bundle): - Configuration that applies to all work - Instructions that guide ongoing behavior - Tool definitions needed throughout session Use as Agent (task): - Discrete, completable tasks - Work requiring deep focus - Parallel execution opportunities - Tasks benefiting from isolation The Spectrum \u00b6 Pure Context \u25c0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25b6 Pure Agent AGENTS.md Shared Task-specific Project behaviors specialists config Most bundles live somewhere in between, usable as either context or agents depending on the situation. Agent Design Patterns \u00b6 The Specialist Pattern \u00b6 Create agents for specific domains: # Each agent is an expert in one area security-reviewer # Security-focused review performance-analyst # Performance optimization api-designer # API design review The Pipeline Pattern \u00b6 Chain agents for complex workflows: analyze \u2500\u2500\u25b6 design \u2500\u2500\u25b6 implement \u2500\u2500\u25b6 review Each stage is a separate agent, passing context forward. The Parallel Pattern \u00b6 Fan out independent work: \u250c\u2500\u2500\u25b6 lint \u2502 main task \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u25b6 test \u2502 \u2514\u2500\u2500\u25b6 docs Results merge back for final synthesis. Key Takeaways \u00b6 Agents ARE bundles - Same YAML format, different invocation pattern Sub-sessions provide isolation - Fresh context, focused execution Instructions must be complete - Agents have no memory of your conversation Parallel execution is powerful - Launch independent agents simultaneously Tools are scoped - Agents only access what their bundle defines Create specialists - Build agents for your specific workflows Choose the right pattern - Context for ongoing guidance, agents for discrete tasks Next Steps \u00b6 Using the Task Tool - Deep dive into agent invocation Creating Custom Agents - Build your own specialists Recipe-Based Workflows - Orchestrate multi-agent pipelines","title":"Agents"},{"location":"concepts/agents.html#understanding-agents","text":"Agents are specialized AI assistants that handle complex, multi-step tasks autonomously. They're one of Amplifier's most powerful features for managing sophisticated workflows without overwhelming your main conversation context.","title":"Understanding Agents"},{"location":"concepts/agents.html#what-is-an-agent","text":"Key Insight: Agents ARE bundles. Same file format, same structure. An agent is simply a bundle that's designed to be launched as a sub-session via the task tool. There's no special \"agent format\" - any bundle can potentially act as an agent if it's configured for autonomous task execution. # This IS an agent - it's just a bundle! name : code-reviewer version : 1.0.0 description : Reviews code for quality and best practices instructions : | You are a code review specialist. Analyze the provided code for bugs, style issues, and improvement opportunities. Provide actionable feedback with specific line references. tools : - read_file - grep - glob The magic isn't in the format - it's in how agents are invoked. When you call an agent via the task tool, Amplifier: Spawns a fresh sub-session Loads the agent's bundle configuration Executes the task autonomously Returns results to your main session","title":"What is an Agent?"},{"location":"concepts/agents.html#how-agents-work","text":"\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 Main Session \u2502 task \u2502 Sub-Session \u2502 \u2502 (you) \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u25b6 \u2502 (agent) \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 - Your context \u2502 \u2502 - Fresh context \u2502 \u2502 - Your tools \u2502 \u2502 - Agent tools \u2502 \u2502 - Conversation \u2502 \u2502 - Single task \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u2502 \u2502 result \u2502 \u25c0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"How Agents Work"},{"location":"concepts/agents.html#the-sub-session-model","text":"Each agent runs in complete isolation: Fresh context : Agents start with no memory of your conversation Scoped tools : Only tools defined in the agent's bundle are available Single mission : Agents focus on one specific task One response : Agents return a single final result This isolation is intentional. It means: Your main session stays uncluttered Agents can focus deeply on their specialty Complex tasks don't pollute your context window Multiple agents can run in parallel","title":"The Sub-Session Model"},{"location":"concepts/agents.html#information-flow","text":"You: \"Review the authentication module\" \u2502 \u25bc \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 task tool invocation \u2502 \u2502 \u2502 \u2502 agent: \"foundation:code-reviewer\" \u2502 \u2502 instruction: \"Review src/auth/*.py \u2502 \u2502 for security issues\" \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u25bc \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 Agent Sub-Session \u2502 \u2502 \u2502 \u2502 - Reads files \u2502 \u2502 - Analyzes patterns \u2502 \u2502 - Checks security practices \u2502 \u2502 - Generates detailed report \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u25bc Final report returned to main session","title":"Information Flow"},{"location":"concepts/agents.html#using-agents","text":"Agents are invoked through the task tool. The key parameters are: Parameter Required Description agent Yes Agent identifier (e.g., foundation:zen-architect ) instruction Yes Detailed task description session_id No Resume a previous agent session","title":"Using Agents"},{"location":"concepts/agents.html#writing-good-instructions","text":"Since agents start with zero context, your instructions must be comprehensive: # Bad - too vague instruction : \"Fix the bug\" # Good - complete context instruction : | Fix the KeyError in src/processor.py around line 45. Context: - The error occurs when processing empty input arrays - Expected behavior: return empty result, not crash - Related files: src/processor.py, src/validator.py Return: - What you changed and why - How to verify the fix","title":"Writing Good Instructions"},{"location":"concepts/agents.html#parallel-agent-execution","text":"Launch multiple agents simultaneously for independent tasks: \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 Main Session\u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25b6 Agent A (code review) \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25b6 Agent B (test coverage) \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25b6 Agent C (documentation) All three run concurrently, returning results as they complete.","title":"Parallel Agent Execution"},{"location":"concepts/agents.html#built-in-agents","text":"Amplifier Foundation provides specialized agents for common workflows: Agent Purpose When to Use foundation:zen-architect Architecture design & code planning Starting new features, major refactors foundation:modular-builder Implementation from specs Building code after architecture phase foundation:bug-hunter Systematic debugging Tracking down errors and failures foundation:explorer Deep codebase reconnaissance Understanding unfamiliar code foundation:git-ops Git and GitHub operations Commits, PRs, branch management foundation:test-coverage Test analysis & gap identification Ensuring adequate test coverage foundation:web-research Internet search & fetching Finding external documentation foundation:security-guardian Security review & auditing Pre-deployment checks foundation:integration-specialist External API & MCP integration Connecting to services foundation:post-task-cleanup Codebase hygiene After completing major tasks","title":"Built-in Agents"},{"location":"concepts/agents.html#specialized-domain-agents","text":"Agent Purpose lsp:code-navigator Semantic code navigation via LSP lsp-python:python-code-intel Python-specific code intelligence recipes:recipe-author Creating and validating recipes design-intelligence:* UI/UX design specialists","title":"Specialized Domain Agents"},{"location":"concepts/agents.html#creating-your-own-agents","text":"Any bundle can become an agent. Here's the pattern:","title":"Creating Your Own Agents"},{"location":"concepts/agents.html#1-define-the-specialty","text":"# .amplifier/agents/pr-reviewer.yaml name : pr-reviewer version : 1.0.0 description : Reviews pull requests for quality and completeness instructions : | You are a PR review specialist. When given a PR or branch: 1. Analyze the changes for: - Code quality and style - Test coverage - Documentation updates - Breaking changes 2. Provide structured feedback: - Summary of changes - Issues found (critical/minor) - Suggestions for improvement - Approval recommendation tools : - read_file - grep - glob - bash # for git operations","title":"1. Define the Specialty"},{"location":"concepts/agents.html#2-scope-the-tools","text":"Only include tools the agent actually needs: # Minimal toolset for a documentation agent tools : - read_file - write_file - glob # Richer toolset for a debugging agent tools : - read_file - grep - glob - bash - LSP","title":"2. Scope the Tools"},{"location":"concepts/agents.html#3-write-clear-instructions","text":"Agent instructions should specify: Role : What the agent specializes in Process : How to approach tasks Output format : What to return Boundaries : What NOT to do","title":"3. Write Clear Instructions"},{"location":"concepts/agents.html#4-register-for-discovery","text":"Place agents where they can be found: .amplifier/ agents/ pr-reviewer.yaml # Project-specific ~/.amplifier/ agents/ my-helper.yaml # Personal agents","title":"4. Register for Discovery"},{"location":"concepts/agents.html#agents-vs-bundles","text":"The distinction is about usage pattern , not file format: Aspect Bundle (as context) Bundle (as agent) Loading Included in session Spawns sub-session Context Shared with main Isolated Lifecycle Persistent Task-scoped Invocation @mention or auto task tool Response Ongoing conversation Single result","title":"Agents vs Bundles"},{"location":"concepts/agents.html#when-to-use-each","text":"Use as Context (bundle): - Configuration that applies to all work - Instructions that guide ongoing behavior - Tool definitions needed throughout session Use as Agent (task): - Discrete, completable tasks - Work requiring deep focus - Parallel execution opportunities - Tasks benefiting from isolation","title":"When to Use Each"},{"location":"concepts/agents.html#the-spectrum","text":"Pure Context \u25c0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25b6 Pure Agent AGENTS.md Shared Task-specific Project behaviors specialists config Most bundles live somewhere in between, usable as either context or agents depending on the situation.","title":"The Spectrum"},{"location":"concepts/agents.html#agent-design-patterns","text":"","title":"Agent Design Patterns"},{"location":"concepts/agents.html#the-specialist-pattern","text":"Create agents for specific domains: # Each agent is an expert in one area security-reviewer # Security-focused review performance-analyst # Performance optimization api-designer # API design review","title":"The Specialist Pattern"},{"location":"concepts/agents.html#the-pipeline-pattern","text":"Chain agents for complex workflows: analyze \u2500\u2500\u25b6 design \u2500\u2500\u25b6 implement \u2500\u2500\u25b6 review Each stage is a separate agent, passing context forward.","title":"The Pipeline Pattern"},{"location":"concepts/agents.html#the-parallel-pattern","text":"Fan out independent work: \u250c\u2500\u2500\u25b6 lint \u2502 main task \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u25b6 test \u2502 \u2514\u2500\u2500\u25b6 docs Results merge back for final synthesis.","title":"The Parallel Pattern"},{"location":"concepts/agents.html#key-takeaways","text":"Agents ARE bundles - Same YAML format, different invocation pattern Sub-sessions provide isolation - Fresh context, focused execution Instructions must be complete - Agents have no memory of your conversation Parallel execution is powerful - Launch independent agents simultaneously Tools are scoped - Agents only access what their bundle defines Create specialists - Build agents for your specific workflows Choose the right pattern - Context for ongoing guidance, agents for discrete tasks","title":"Key Takeaways"},{"location":"concepts/agents.html#next-steps","text":"Using the Task Tool - Deep dive into agent invocation Creating Custom Agents - Build your own specialists Recipe-Based Workflows - Orchestrate multi-agent pipelines","title":"Next Steps"},{"location":"concepts/architecture.html","text":"Architecture Overview \u00b6 This document provides a comprehensive overview of the Amplifier kernel architecture, explaining the core design principles, component interactions, and data flow patterns that make the system work. The Kernel Philosophy \u00b6 Mechanism, not policy. The Amplifier kernel follows a fundamental design principle borrowed from operating system design: provide mechanisms, not policies. This means the kernel supplies the building blocks and infrastructure for AI agent execution without dictating how those blocks must be used. What This Means in Practice \u00b6 The kernel provides: Session management - The mechanism for tracking conversation state Provider abstraction - The mechanism for communicating with LLMs Tool execution - The mechanism for agents to take actions Event emission - The mechanism for observability and extension Module mounting - The mechanism for adding capabilities The kernel does NOT dictate: Which LLM provider you must use What tools are available to agents How conversation history is formatted What retry strategies to employ How errors should be presented to users The Litmus Test \u00b6 When deciding whether something belongs in the kernel, ask: Is it a mechanism or a policy? Mechanisms go in kernel; policies go in modules. Would removing it break the agent loop? If yes, it's kernel. If no, it's a module. Does it need to work the same way everywhere? Kernel components are universal. Examples: - Event emission \u2192 Kernel (mechanism for observability) - Retry logic \u2192 Module (policy decision) - Provider protocol \u2192 Kernel (mechanism for LLM communication) - Rate limiting \u2192 Module (policy for resource management) Session Lifecycle \u00b6 A session represents a complete conversation between a user and an AI agent. Understanding the session lifecycle is essential for building applications with Amplifier. Component Flow \u00b6 User Input \u2193 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 Session \u2502 \u2190 Maintains state, history, configuration \u2514\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2518 \u2193 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 Coordinator \u2502 \u2190 Manages session lifecycle, applies hooks \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2193 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 Orchestrator\u2502 \u2190\u2192 Provider (LLM API) \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2193 Tools/Hooks \u2190 External capabilities and integrations Session States \u00b6 A session progresses through distinct states: State Description created Session initialized but not yet started running Actively processing user input or LLM response idle Waiting for user input suspended Paused, can be resumed later completed Finished successfully failed Terminated due to error The Coordinator \u00b6 The Coordinator is the session's traffic controller. It: Receives user messages and adds them to session history Invokes hooks at appropriate lifecycle points Delegates to the Orchestrator for LLM interaction Manages state transitions between session states Handles interrupts and graceful shutdown The Orchestrator \u00b6 The Orchestrator manages the agent loop - the core cycle of: \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 \u2502 \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 \u2502 \u2502 Prepare \u2502 \u2192 \u2502 Invoke \u2502 \u2192 \u2502Parse\u2502 \u2502 \u2502 \u2502 Request \u2502 \u2502Provider\u2502 \u2502Reply\u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u252c\u2500\u2500\u2518 \u2502 \u2502 \u2191 \u2502 \u2502 \u2502 \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2502Execute Tools\u2502\u2190\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 The loop continues until: - The LLM responds without requesting tool calls - A maximum iteration limit is reached - An error occurs or the session is interrupted Session Configuration \u00b6 Sessions accept configuration that controls behavior: session = Session ( provider = my_provider , # Required: LLM provider system_prompt = \"You are...\" , # Optional: Agent instructions tools = [ tool1 , tool2 ], # Optional: Available tools hooks = [ hook1 , hook2 ], # Optional: Lifecycle hooks max_iterations = 50 , # Optional: Loop limit metadata = { \"user_id\" : \"123\" } # Optional: Custom metadata ) Event Flow \u00b6 Events provide observability into everything happening within a session. They enable logging, debugging, metrics collection, and reactive integrations. Event Architecture \u00b6 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 Session \u2502 \u2502 \u2502 \u2502 Component A \u2500\u2500emit\u2500\u2500\u2192 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 \u2502 \u2502 Event Bus \u2502\u2500\u2500\u2192 Hook 1\u2502 \u2502 Component B \u2500\u2500emit\u2500\u2500\u2192 \u2502 \u2502\u2500\u2500\u2192 Hook 2\u2502 \u2502 \u2502 (in-process)\u2502\u2500\u2500\u2192 Logger\u2502 \u2502 Component C \u2500\u2500emit\u2500\u2500\u2192 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 Event Categories \u00b6 Events are organized into categories: Category Examples Purpose session session.started , session.completed Lifecycle tracking message message.user , message.assistant Conversation flow tool tool.call.started , tool.call.completed Tool execution provider provider.request , provider.response LLM interaction error error.tool , error.provider Error tracking Event Structure \u00b6 Every event follows a consistent structure: { \"type\" : \"tool.call.completed\" , # Event type identifier \"session_id\" : \"abc-123\" , # Session context \"timestamp\" : \"2024-01-15T10:30:00Z\" , # When it occurred \"data\" : { # Event-specific payload \"tool_name\" : \"read_file\" , \"duration_ms\" : 45 , \"result\" : \"...\" } } Subscribing to Events \u00b6 Hooks can subscribe to specific event types: class MetricsHook ( Hook ): def __init__ ( self ): self . subscriptions = [ \"tool.call.completed\" , \"provider.response\" ] async def on_event ( self , event : Event ): if event . type == \"tool.call.completed\" : self . record_tool_latency ( event . data ) Event Ordering Guarantees \u00b6 Events are emitted synchronously during execution Events within a session are ordered by emission time No guarantees across sessions (they may run concurrently) Module Mounting \u00b6 Modules extend the kernel's capabilities without modifying its core. The mounting system provides a clean separation between kernel mechanisms and application-specific functionality. Module Types \u00b6 Type Purpose Examples Provider LLM communication Anthropic, OpenAI, Azure Tool Agent capabilities File operations, web search Hook Lifecycle integration Logging, metrics, guards Storage Persistence Session storage, memory The Mount Protocol \u00b6 Modules implement a standard protocol for lifecycle management: class Module ( Protocol ): async def mount ( self , context : MountContext ) -> None : \"\"\"Called when module is attached to a session.\"\"\" pass async def unmount ( self ) -> None : \"\"\"Called when module is detached or session ends.\"\"\" pass Mount Context \u00b6 When mounting, modules receive context about their environment: @dataclass class MountContext : session_id : str # The session being mounted to config : dict # Module-specific configuration event_bus : EventBus # For emitting/subscribing to events kernel_version : str # For compatibility checks Module Dependencies \u00b6 Modules can declare dependencies on other modules: class DatabaseTool ( Tool ): dependencies = [ \"connection-pool\" ] # Requires connection pool module async def mount ( self , context : MountContext ): # Connection pool is guaranteed to be mounted first self . pool = context . get_module ( \"connection-pool\" ) Mount Order \u00b6 The kernel mounts modules in dependency order: Core kernel components initialize Providers mount (LLM connectivity) Storage modules mount (persistence ready) Tools mount (capabilities available) Hooks mount (observability active) Hot Reloading \u00b6 Some module types support hot reloading during a session: # Add a tool mid-session await session . mount_tool ( new_tool ) # Remove a hook await session . unmount_hook ( old_hook ) Note: Providers and storage typically cannot be hot-reloaded as they maintain critical state. Key Takeaways \u00b6 1. Separation of Concerns \u00b6 The kernel provides mechanisms; modules implement policies. This separation enables: - Flexible application architecture - Easy testing through module substitution - Clear boundaries for debugging 2. Event-Driven Observability \u00b6 Everything emits events. This means: - Full visibility into system behavior - Non-invasive monitoring and debugging - Reactive integrations without modifying core logic 3. Composable by Design \u00b6 The module system enables composition: - Mix and match providers, tools, and hooks - Build application-specific bundles - Share and reuse modules across projects 4. Session-Centric Model \u00b6 Sessions are the fundamental unit: - All state lives within a session - Sessions are independent and isolated - Sessions can be persisted, resumed, and analyzed 5. Predictable Lifecycle \u00b6 Clear state machines govern behavior: - Session states are explicit and observable - Mount/unmount lifecycle is deterministic - The agent loop follows a consistent pattern What's Next \u00b6 Now that you understand the architecture: Sessions Deep Dive - Detailed session management Building Modules - Create custom modules Event Reference - Complete event catalog Provider Protocol - LLM integration details","title":"Architecture Deep Dive"},{"location":"concepts/architecture.html#architecture-overview","text":"This document provides a comprehensive overview of the Amplifier kernel architecture, explaining the core design principles, component interactions, and data flow patterns that make the system work.","title":"Architecture Overview"},{"location":"concepts/architecture.html#the-kernel-philosophy","text":"Mechanism, not policy. The Amplifier kernel follows a fundamental design principle borrowed from operating system design: provide mechanisms, not policies. This means the kernel supplies the building blocks and infrastructure for AI agent execution without dictating how those blocks must be used.","title":"The Kernel Philosophy"},{"location":"concepts/architecture.html#what-this-means-in-practice","text":"The kernel provides: Session management - The mechanism for tracking conversation state Provider abstraction - The mechanism for communicating with LLMs Tool execution - The mechanism for agents to take actions Event emission - The mechanism for observability and extension Module mounting - The mechanism for adding capabilities The kernel does NOT dictate: Which LLM provider you must use What tools are available to agents How conversation history is formatted What retry strategies to employ How errors should be presented to users","title":"What This Means in Practice"},{"location":"concepts/architecture.html#the-litmus-test","text":"When deciding whether something belongs in the kernel, ask: Is it a mechanism or a policy? Mechanisms go in kernel; policies go in modules. Would removing it break the agent loop? If yes, it's kernel. If no, it's a module. Does it need to work the same way everywhere? Kernel components are universal. Examples: - Event emission \u2192 Kernel (mechanism for observability) - Retry logic \u2192 Module (policy decision) - Provider protocol \u2192 Kernel (mechanism for LLM communication) - Rate limiting \u2192 Module (policy for resource management)","title":"The Litmus Test"},{"location":"concepts/architecture.html#session-lifecycle","text":"A session represents a complete conversation between a user and an AI agent. Understanding the session lifecycle is essential for building applications with Amplifier.","title":"Session Lifecycle"},{"location":"concepts/architecture.html#component-flow","text":"User Input \u2193 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 Session \u2502 \u2190 Maintains state, history, configuration \u2514\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2518 \u2193 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 Coordinator \u2502 \u2190 Manages session lifecycle, applies hooks \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2193 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 Orchestrator\u2502 \u2190\u2192 Provider (LLM API) \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2193 Tools/Hooks \u2190 External capabilities and integrations","title":"Component Flow"},{"location":"concepts/architecture.html#session-states","text":"A session progresses through distinct states: State Description created Session initialized but not yet started running Actively processing user input or LLM response idle Waiting for user input suspended Paused, can be resumed later completed Finished successfully failed Terminated due to error","title":"Session States"},{"location":"concepts/architecture.html#the-coordinator","text":"The Coordinator is the session's traffic controller. It: Receives user messages and adds them to session history Invokes hooks at appropriate lifecycle points Delegates to the Orchestrator for LLM interaction Manages state transitions between session states Handles interrupts and graceful shutdown","title":"The Coordinator"},{"location":"concepts/architecture.html#the-orchestrator","text":"The Orchestrator manages the agent loop - the core cycle of: \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 \u2502 \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 \u2502 \u2502 Prepare \u2502 \u2192 \u2502 Invoke \u2502 \u2192 \u2502Parse\u2502 \u2502 \u2502 \u2502 Request \u2502 \u2502Provider\u2502 \u2502Reply\u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u252c\u2500\u2500\u2518 \u2502 \u2502 \u2191 \u2502 \u2502 \u2502 \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2502Execute Tools\u2502\u2190\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 The loop continues until: - The LLM responds without requesting tool calls - A maximum iteration limit is reached - An error occurs or the session is interrupted","title":"The Orchestrator"},{"location":"concepts/architecture.html#session-configuration","text":"Sessions accept configuration that controls behavior: session = Session ( provider = my_provider , # Required: LLM provider system_prompt = \"You are...\" , # Optional: Agent instructions tools = [ tool1 , tool2 ], # Optional: Available tools hooks = [ hook1 , hook2 ], # Optional: Lifecycle hooks max_iterations = 50 , # Optional: Loop limit metadata = { \"user_id\" : \"123\" } # Optional: Custom metadata )","title":"Session Configuration"},{"location":"concepts/architecture.html#event-flow","text":"Events provide observability into everything happening within a session. They enable logging, debugging, metrics collection, and reactive integrations.","title":"Event Flow"},{"location":"concepts/architecture.html#event-architecture","text":"\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 Session \u2502 \u2502 \u2502 \u2502 Component A \u2500\u2500emit\u2500\u2500\u2192 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 \u2502 \u2502 Event Bus \u2502\u2500\u2500\u2192 Hook 1\u2502 \u2502 Component B \u2500\u2500emit\u2500\u2500\u2192 \u2502 \u2502\u2500\u2500\u2192 Hook 2\u2502 \u2502 \u2502 (in-process)\u2502\u2500\u2500\u2192 Logger\u2502 \u2502 Component C \u2500\u2500emit\u2500\u2500\u2192 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Event Architecture"},{"location":"concepts/architecture.html#event-categories","text":"Events are organized into categories: Category Examples Purpose session session.started , session.completed Lifecycle tracking message message.user , message.assistant Conversation flow tool tool.call.started , tool.call.completed Tool execution provider provider.request , provider.response LLM interaction error error.tool , error.provider Error tracking","title":"Event Categories"},{"location":"concepts/architecture.html#event-structure","text":"Every event follows a consistent structure: { \"type\" : \"tool.call.completed\" , # Event type identifier \"session_id\" : \"abc-123\" , # Session context \"timestamp\" : \"2024-01-15T10:30:00Z\" , # When it occurred \"data\" : { # Event-specific payload \"tool_name\" : \"read_file\" , \"duration_ms\" : 45 , \"result\" : \"...\" } }","title":"Event Structure"},{"location":"concepts/architecture.html#subscribing-to-events","text":"Hooks can subscribe to specific event types: class MetricsHook ( Hook ): def __init__ ( self ): self . subscriptions = [ \"tool.call.completed\" , \"provider.response\" ] async def on_event ( self , event : Event ): if event . type == \"tool.call.completed\" : self . record_tool_latency ( event . data )","title":"Subscribing to Events"},{"location":"concepts/architecture.html#event-ordering-guarantees","text":"Events are emitted synchronously during execution Events within a session are ordered by emission time No guarantees across sessions (they may run concurrently)","title":"Event Ordering Guarantees"},{"location":"concepts/architecture.html#module-mounting","text":"Modules extend the kernel's capabilities without modifying its core. The mounting system provides a clean separation between kernel mechanisms and application-specific functionality.","title":"Module Mounting"},{"location":"concepts/architecture.html#module-types","text":"Type Purpose Examples Provider LLM communication Anthropic, OpenAI, Azure Tool Agent capabilities File operations, web search Hook Lifecycle integration Logging, metrics, guards Storage Persistence Session storage, memory","title":"Module Types"},{"location":"concepts/architecture.html#the-mount-protocol","text":"Modules implement a standard protocol for lifecycle management: class Module ( Protocol ): async def mount ( self , context : MountContext ) -> None : \"\"\"Called when module is attached to a session.\"\"\" pass async def unmount ( self ) -> None : \"\"\"Called when module is detached or session ends.\"\"\" pass","title":"The Mount Protocol"},{"location":"concepts/architecture.html#mount-context","text":"When mounting, modules receive context about their environment: @dataclass class MountContext : session_id : str # The session being mounted to config : dict # Module-specific configuration event_bus : EventBus # For emitting/subscribing to events kernel_version : str # For compatibility checks","title":"Mount Context"},{"location":"concepts/architecture.html#module-dependencies","text":"Modules can declare dependencies on other modules: class DatabaseTool ( Tool ): dependencies = [ \"connection-pool\" ] # Requires connection pool module async def mount ( self , context : MountContext ): # Connection pool is guaranteed to be mounted first self . pool = context . get_module ( \"connection-pool\" )","title":"Module Dependencies"},{"location":"concepts/architecture.html#mount-order","text":"The kernel mounts modules in dependency order: Core kernel components initialize Providers mount (LLM connectivity) Storage modules mount (persistence ready) Tools mount (capabilities available) Hooks mount (observability active)","title":"Mount Order"},{"location":"concepts/architecture.html#hot-reloading","text":"Some module types support hot reloading during a session: # Add a tool mid-session await session . mount_tool ( new_tool ) # Remove a hook await session . unmount_hook ( old_hook ) Note: Providers and storage typically cannot be hot-reloaded as they maintain critical state.","title":"Hot Reloading"},{"location":"concepts/architecture.html#key-takeaways","text":"","title":"Key Takeaways"},{"location":"concepts/architecture.html#1-separation-of-concerns","text":"The kernel provides mechanisms; modules implement policies. This separation enables: - Flexible application architecture - Easy testing through module substitution - Clear boundaries for debugging","title":"1. Separation of Concerns"},{"location":"concepts/architecture.html#2-event-driven-observability","text":"Everything emits events. This means: - Full visibility into system behavior - Non-invasive monitoring and debugging - Reactive integrations without modifying core logic","title":"2. Event-Driven Observability"},{"location":"concepts/architecture.html#3-composable-by-design","text":"The module system enables composition: - Mix and match providers, tools, and hooks - Build application-specific bundles - Share and reuse modules across projects","title":"3. Composable by Design"},{"location":"concepts/architecture.html#4-session-centric-model","text":"Sessions are the fundamental unit: - All state lives within a session - Sessions are independent and isolated - Sessions can be persisted, resumed, and analyzed","title":"4. Session-Centric Model"},{"location":"concepts/architecture.html#5-predictable-lifecycle","text":"Clear state machines govern behavior: - Session states are explicit and observable - Mount/unmount lifecycle is deterministic - The agent loop follows a consistent pattern","title":"5. Predictable Lifecycle"},{"location":"concepts/architecture.html#whats-next","text":"Now that you understand the architecture: Sessions Deep Dive - Detailed session management Building Modules - Create custom modules Event Reference - Complete event catalog Provider Protocol - LLM integration details","title":"What's Next"},{"location":"concepts/bundles.html","text":"Understanding Bundles \u00b6 Bundles are the primary unit of composition in Amplifier. They package together everything an agent needs\u2014instructions, tools, behaviors, and context\u2014into a single, reusable configuration that can be shared, combined, and customized. What is a Bundle? \u00b6 A bundle is a composable configuration package that defines an agent's capabilities. Think of it like a recipe: it specifies the ingredients (tools, context files), the instructions (system prompts, behaviors), and how they combine to create a specific agent personality and capability set. The Core Idea \u00b6 Traditional AI agent configuration often involves: - Scattered configuration files - Duplicated prompts across projects - Manual tool registration - Inconsistent setups between environments Bundles solve this by providing a single source of truth for an agent's configuration that can be: Versioned alongside your code Shared across teams and projects Composed to build complex agents from simple parts Overridden for environment-specific customization Bundle vs Agent \u00b6 It's important to understand the distinction: Aspect Bundle Agent Definition Configuration package Runtime instance Contains Instructions, tools, behaviors Active session state Lifetime Persistent (file-based) Ephemeral (session-based) Purpose Define capabilities Execute tasks A bundle is the blueprint ; an agent is the running instance created from that blueprint. Bundle Structure \u00b6 Every bundle follows a standard structure using Markdown files with YAML frontmatter. This format is both human-readable and machine-parseable. Basic Bundle Layout \u00b6 my-bundle/ \u251c\u2500\u2500 bundle.md # Main bundle definition \u251c\u2500\u2500 context/ # Supporting context files \u2502 \u251c\u2500\u2500 guidelines.md \u2502 \u2514\u2500\u2500 examples.md \u251c\u2500\u2500 behaviors/ # Custom behaviors \u2502 \u2514\u2500\u2500 review-code.md \u2514\u2500\u2500 tools/ # Custom tool definitions (optional) \u2514\u2500\u2500 lint.yaml The bundle.md File \u00b6 The bundle.md file is the entry point for every bundle. It contains: --- name: code-reviewer description: \"Expert code review agent\" version: \"1.0.0\" # Tool configuration tools: - read_file - write_file - grep - glob - bash # Include other bundles includes: - foundation:core-tools - my-org:coding-standards # Behaviors to activate behaviors: - thorough-review - security-focus # Context files to load context: - context/guidelines.md - context/examples.md --- # Code Reviewer You are an expert code reviewer focused on quality, security, and maintainability. ## Your Approach 1. Read the code thoroughly before commenting 2. Focus on substantive issues, not style nitpicks 3. Provide actionable suggestions with examples 4. Acknowledge good patterns when you see them ## Review Checklist - [ ] Logic correctness - [ ] Error handling - [ ] Security considerations - [ ] Performance implications - [ ] Test coverage Frontmatter Fields \u00b6 Field Required Description name Yes Unique identifier for the bundle description No Human-readable description version No Semantic version string tools No List of tools to enable includes No Other bundles to compose behaviors No Behaviors to activate context No Additional context files to load Body Content \u00b6 The markdown body after the frontmatter becomes the agent's system prompt. This is where you define: The agent's role and personality Specific instructions and guidelines Domain knowledge Response formats Composition \u00b6 One of the most powerful features of bundles is composition. You can build complex agents by combining simpler bundles. The includes Field \u00b6 Use includes to inherit from other bundles: includes : - foundation:core-tools # From foundation collection - my-org:coding-standards # From your organization - ./local-overrides # From relative path When bundles are composed: 1. Tools are merged (union of all tools) 2. Context is accumulated (all context files load) 3. Behaviors are combined (all behaviors activate) 4. Instructions are layered (child overrides parent) Composition Order Matters \u00b6 Bundles are processed in order, with later bundles taking precedence: includes : - base-agent # Loaded first (lowest priority) - security-focused # Adds security behaviors - my-customizations # Loaded last (highest priority) Behaviors \u00b6 Behaviors are reusable instruction fragments that modify agent behavior. Unlike full bundles, behaviors are lightweight and focused on a single concern. --- name: security-focus trigger: \"when reviewing code\" --- ## Security Review Requirements When reviewing code, always check for: - Input validation and sanitization - Authentication and authorization - Sensitive data exposure - SQL injection vulnerabilities - XSS attack vectors Behaviors can be: - Always active : Load with every request - Conditionally triggered : Activate based on context - User-invoked : Activated by explicit command Practical Composition Example \u00b6 Here's how you might compose a specialized agent: # devops-agent/bundle.md --- name : devops-agent includes : - foundation:core-tools - foundation:git-ops - cloud:aws-tools behaviors : - infrastructure-as-code - security-compliance - cost-awareness --- # DevOps Agent You specialize in infrastructure, deployment, and operational concerns. This agent inherits: - File and shell tools from core-tools - Git capabilities from git-ops - AWS-specific tools from aws-tools - Three domain-specific behaviors Creating a Bundle \u00b6 Let's walk through creating a bundle from scratch. Step 1: Define the Purpose \u00b6 Before writing any configuration, clearly define: - What problem does this agent solve? - What tools does it need? - What domain knowledge is required? - Who will use it? Step 2: Create the Structure \u00b6 mkdir -p my-agent/ { context,behaviors } touch my-agent/bundle.md Step 3: Write the Bundle Definition \u00b6 --- name: documentation-writer description: \"Creates clear, comprehensive documentation\" version: \"1.0.0\" tools: - read_file - write_file - glob - grep includes: - foundation:core-tools context: - context/style-guide.md --- # Documentation Writer You are an expert technical writer who creates clear, comprehensive documentation. ## Writing Principles 1. **Clarity first** : Use simple language 2. **Structure matters** : Organize logically 3. **Examples help** : Show, don't just tell 4. **Audience awareness** : Know your reader Step 4: Add Context Files \u00b6 Create supporting context that provides domain knowledge: <!-- context/style-guide.md --> # Documentation Style Guide ## Voice and Tone - Use active voice - Be direct and concise - Avoid jargon unless necessary ## Formatting - Use headers to organize content - Include code examples in fenced blocks - Add tables for comparative information Step 5: Test the Bundle \u00b6 Run your bundle and verify it works as expected: amp --bundle ./my-agent Bundle Best Practices \u00b6 DO: - Keep bundles focused on a single domain - Use composition instead of duplication - Version your bundles alongside code - Document the bundle's purpose and usage DON'T: - Create monolithic bundles that do everything - Duplicate instructions across bundles - Hardcode environment-specific values - Include sensitive data in bundles Advanced Topics \u00b6 Environment-Specific Overrides \u00b6 Use includes with environment bundles: includes : - base-agent - ${ENVIRONMENT:-development} # Loads dev/staging/prod bundle Bundle Inheritance Patterns \u00b6 Specialization : Start general, get specific foundation:core \u2192 domain:backend \u2192 project:api-service Layering : Add capabilities incrementally base + security + monitoring + custom Collection Organization \u00b6 Group related bundles into collections: my-collection/ \u251c\u2500\u2500 collection.yaml # Collection metadata \u251c\u2500\u2500 agents/ \u2502 \u251c\u2500\u2500 reviewer/ \u2502 \u2514\u2500\u2500 writer/ \u251c\u2500\u2500 behaviors/ \u2502 \u2514\u2500\u2500 shared/ \u2514\u2500\u2500 context/ \u2514\u2500\u2500 common/ Key Takeaways \u00b6 Bundles are composable packages that define everything an agent needs\u2014tools, instructions, behaviors, and context. Markdown + YAML frontmatter provides a human-readable, version-controllable format for agent configuration. Composition is powerful : Use includes to build complex agents from simple, focused bundles. Tools merge, context accumulates, and instructions layer. Behaviors add modularity : Extract reusable instruction fragments into behaviors that can be mixed and matched. Structure matters : Follow the standard bundle layout for consistency and discoverability. Keep bundles focused : One bundle should solve one class of problems. Use composition to combine capabilities. Test and iterate : Bundles are code\u2014version them, test them, and refine them based on real usage. Next Steps \u00b6 Creating Your First Bundle - Hands-on tutorial Behaviors Deep Dive - Learn about behavior composition Collections - Organizing bundles at scale","title":"Bundles"},{"location":"concepts/bundles.html#understanding-bundles","text":"Bundles are the primary unit of composition in Amplifier. They package together everything an agent needs\u2014instructions, tools, behaviors, and context\u2014into a single, reusable configuration that can be shared, combined, and customized.","title":"Understanding Bundles"},{"location":"concepts/bundles.html#what-is-a-bundle","text":"A bundle is a composable configuration package that defines an agent's capabilities. Think of it like a recipe: it specifies the ingredients (tools, context files), the instructions (system prompts, behaviors), and how they combine to create a specific agent personality and capability set.","title":"What is a Bundle?"},{"location":"concepts/bundles.html#the-core-idea","text":"Traditional AI agent configuration often involves: - Scattered configuration files - Duplicated prompts across projects - Manual tool registration - Inconsistent setups between environments Bundles solve this by providing a single source of truth for an agent's configuration that can be: Versioned alongside your code Shared across teams and projects Composed to build complex agents from simple parts Overridden for environment-specific customization","title":"The Core Idea"},{"location":"concepts/bundles.html#bundle-vs-agent","text":"It's important to understand the distinction: Aspect Bundle Agent Definition Configuration package Runtime instance Contains Instructions, tools, behaviors Active session state Lifetime Persistent (file-based) Ephemeral (session-based) Purpose Define capabilities Execute tasks A bundle is the blueprint ; an agent is the running instance created from that blueprint.","title":"Bundle vs Agent"},{"location":"concepts/bundles.html#bundle-structure","text":"Every bundle follows a standard structure using Markdown files with YAML frontmatter. This format is both human-readable and machine-parseable.","title":"Bundle Structure"},{"location":"concepts/bundles.html#basic-bundle-layout","text":"my-bundle/ \u251c\u2500\u2500 bundle.md # Main bundle definition \u251c\u2500\u2500 context/ # Supporting context files \u2502 \u251c\u2500\u2500 guidelines.md \u2502 \u2514\u2500\u2500 examples.md \u251c\u2500\u2500 behaviors/ # Custom behaviors \u2502 \u2514\u2500\u2500 review-code.md \u2514\u2500\u2500 tools/ # Custom tool definitions (optional) \u2514\u2500\u2500 lint.yaml","title":"Basic Bundle Layout"},{"location":"concepts/bundles.html#the-bundlemd-file","text":"The bundle.md file is the entry point for every bundle. It contains: --- name: code-reviewer description: \"Expert code review agent\" version: \"1.0.0\" # Tool configuration tools: - read_file - write_file - grep - glob - bash # Include other bundles includes: - foundation:core-tools - my-org:coding-standards # Behaviors to activate behaviors: - thorough-review - security-focus # Context files to load context: - context/guidelines.md - context/examples.md --- # Code Reviewer You are an expert code reviewer focused on quality, security, and maintainability. ## Your Approach 1. Read the code thoroughly before commenting 2. Focus on substantive issues, not style nitpicks 3. Provide actionable suggestions with examples 4. Acknowledge good patterns when you see them ## Review Checklist - [ ] Logic correctness - [ ] Error handling - [ ] Security considerations - [ ] Performance implications - [ ] Test coverage","title":"The bundle.md File"},{"location":"concepts/bundles.html#frontmatter-fields","text":"Field Required Description name Yes Unique identifier for the bundle description No Human-readable description version No Semantic version string tools No List of tools to enable includes No Other bundles to compose behaviors No Behaviors to activate context No Additional context files to load","title":"Frontmatter Fields"},{"location":"concepts/bundles.html#body-content","text":"The markdown body after the frontmatter becomes the agent's system prompt. This is where you define: The agent's role and personality Specific instructions and guidelines Domain knowledge Response formats","title":"Body Content"},{"location":"concepts/bundles.html#composition","text":"One of the most powerful features of bundles is composition. You can build complex agents by combining simpler bundles.","title":"Composition"},{"location":"concepts/bundles.html#the-includes-field","text":"Use includes to inherit from other bundles: includes : - foundation:core-tools # From foundation collection - my-org:coding-standards # From your organization - ./local-overrides # From relative path When bundles are composed: 1. Tools are merged (union of all tools) 2. Context is accumulated (all context files load) 3. Behaviors are combined (all behaviors activate) 4. Instructions are layered (child overrides parent)","title":"The includes Field"},{"location":"concepts/bundles.html#composition-order-matters","text":"Bundles are processed in order, with later bundles taking precedence: includes : - base-agent # Loaded first (lowest priority) - security-focused # Adds security behaviors - my-customizations # Loaded last (highest priority)","title":"Composition Order Matters"},{"location":"concepts/bundles.html#behaviors","text":"Behaviors are reusable instruction fragments that modify agent behavior. Unlike full bundles, behaviors are lightweight and focused on a single concern. --- name: security-focus trigger: \"when reviewing code\" --- ## Security Review Requirements When reviewing code, always check for: - Input validation and sanitization - Authentication and authorization - Sensitive data exposure - SQL injection vulnerabilities - XSS attack vectors Behaviors can be: - Always active : Load with every request - Conditionally triggered : Activate based on context - User-invoked : Activated by explicit command","title":"Behaviors"},{"location":"concepts/bundles.html#practical-composition-example","text":"Here's how you might compose a specialized agent: # devops-agent/bundle.md --- name : devops-agent includes : - foundation:core-tools - foundation:git-ops - cloud:aws-tools behaviors : - infrastructure-as-code - security-compliance - cost-awareness --- # DevOps Agent You specialize in infrastructure, deployment, and operational concerns. This agent inherits: - File and shell tools from core-tools - Git capabilities from git-ops - AWS-specific tools from aws-tools - Three domain-specific behaviors","title":"Practical Composition Example"},{"location":"concepts/bundles.html#creating-a-bundle","text":"Let's walk through creating a bundle from scratch.","title":"Creating a Bundle"},{"location":"concepts/bundles.html#step-1-define-the-purpose","text":"Before writing any configuration, clearly define: - What problem does this agent solve? - What tools does it need? - What domain knowledge is required? - Who will use it?","title":"Step 1: Define the Purpose"},{"location":"concepts/bundles.html#step-2-create-the-structure","text":"mkdir -p my-agent/ { context,behaviors } touch my-agent/bundle.md","title":"Step 2: Create the Structure"},{"location":"concepts/bundles.html#step-3-write-the-bundle-definition","text":"--- name: documentation-writer description: \"Creates clear, comprehensive documentation\" version: \"1.0.0\" tools: - read_file - write_file - glob - grep includes: - foundation:core-tools context: - context/style-guide.md --- # Documentation Writer You are an expert technical writer who creates clear, comprehensive documentation. ## Writing Principles 1. **Clarity first** : Use simple language 2. **Structure matters** : Organize logically 3. **Examples help** : Show, don't just tell 4. **Audience awareness** : Know your reader","title":"Step 3: Write the Bundle Definition"},{"location":"concepts/bundles.html#step-4-add-context-files","text":"Create supporting context that provides domain knowledge: <!-- context/style-guide.md --> # Documentation Style Guide ## Voice and Tone - Use active voice - Be direct and concise - Avoid jargon unless necessary ## Formatting - Use headers to organize content - Include code examples in fenced blocks - Add tables for comparative information","title":"Step 4: Add Context Files"},{"location":"concepts/bundles.html#step-5-test-the-bundle","text":"Run your bundle and verify it works as expected: amp --bundle ./my-agent","title":"Step 5: Test the Bundle"},{"location":"concepts/bundles.html#bundle-best-practices","text":"DO: - Keep bundles focused on a single domain - Use composition instead of duplication - Version your bundles alongside code - Document the bundle's purpose and usage DON'T: - Create monolithic bundles that do everything - Duplicate instructions across bundles - Hardcode environment-specific values - Include sensitive data in bundles","title":"Bundle Best Practices"},{"location":"concepts/bundles.html#advanced-topics","text":"","title":"Advanced Topics"},{"location":"concepts/bundles.html#environment-specific-overrides","text":"Use includes with environment bundles: includes : - base-agent - ${ENVIRONMENT:-development} # Loads dev/staging/prod bundle","title":"Environment-Specific Overrides"},{"location":"concepts/bundles.html#bundle-inheritance-patterns","text":"Specialization : Start general, get specific foundation:core \u2192 domain:backend \u2192 project:api-service Layering : Add capabilities incrementally base + security + monitoring + custom","title":"Bundle Inheritance Patterns"},{"location":"concepts/bundles.html#collection-organization","text":"Group related bundles into collections: my-collection/ \u251c\u2500\u2500 collection.yaml # Collection metadata \u251c\u2500\u2500 agents/ \u2502 \u251c\u2500\u2500 reviewer/ \u2502 \u2514\u2500\u2500 writer/ \u251c\u2500\u2500 behaviors/ \u2502 \u2514\u2500\u2500 shared/ \u2514\u2500\u2500 context/ \u2514\u2500\u2500 common/","title":"Collection Organization"},{"location":"concepts/bundles.html#key-takeaways","text":"Bundles are composable packages that define everything an agent needs\u2014tools, instructions, behaviors, and context. Markdown + YAML frontmatter provides a human-readable, version-controllable format for agent configuration. Composition is powerful : Use includes to build complex agents from simple, focused bundles. Tools merge, context accumulates, and instructions layer. Behaviors add modularity : Extract reusable instruction fragments into behaviors that can be mixed and matched. Structure matters : Follow the standard bundle layout for consistency and discoverability. Keep bundles focused : One bundle should solve one class of problems. Use composition to combine capabilities. Test and iterate : Bundles are code\u2014version them, test them, and refine them based on real usage.","title":"Key Takeaways"},{"location":"concepts/bundles.html#next-steps","text":"Creating Your First Bundle - Hands-on tutorial Behaviors Deep Dive - Learn about behavior composition Collections - Organizing bundles at scale","title":"Next Steps"},{"location":"concepts/hooks.html","text":"Understanding Hooks \u00b6 Hooks are Amplifier's mechanism for observing and reacting to events in the agent lifecycle. They allow you to extend agent behavior without modifying core logic, enabling cross-cutting concerns like logging, metrics, guardrails, and custom integrations. What is a Hook? \u00b6 A hook is a lifecycle observer that receives notifications when specific events occur during agent execution. Unlike tools that agents actively invoke, hooks passively listen and respond to the natural flow of agent activity. Think of hooks as event listeners attached to the agent runtime. When an agent starts a turn, calls a tool, receives a response, or completes its work, hooks are notified and can take action. from amplifier_core.hooks import Hook , HookContext class LoggingHook ( Hook ): \"\"\"A simple hook that logs agent activity.\"\"\" async def on_turn_start ( self , ctx : HookContext ) -> None : print ( f \"Turn started: { ctx . turn_id } \" ) async def on_turn_end ( self , ctx : HookContext ) -> None : print ( f \"Turn completed in { ctx . duration_ms } ms\" ) Hooks are registered with the agent runtime and automatically invoked at the appropriate lifecycle points. You don't call hooks directly\u2014the system calls them for you. Hook vs Tool \u00b6 Understanding the distinction between hooks and tools is fundamental to Amplifier's design: Aspect Tool Hook Invocation Agent explicitly calls System automatically triggers Control Agent decides when to use Fires on lifecycle events Visibility Agent sees and chooses Transparent to agent Purpose Provide capabilities Observe and react Return value Returns data to agent No return to agent Tools are capabilities \u2014they extend what an agent can do . A file-reading tool gives the agent the ability to read files. The agent decides when and how to use it. Hooks are observers \u2014they extend what happens during execution. A logging hook records every tool call, but the agent doesn't know or care that logging is happening. This separation keeps agent logic clean while allowing powerful cross-cutting functionality. Event Types \u00b6 Hooks can subscribe to various lifecycle events. Here are the primary event categories: Session Events \u00b6 on_session_start \u2014 A new session begins on_session_end \u2014 A session completes or terminates on_session_resume \u2014 A persisted session resumes Turn Events \u00b6 on_turn_start \u2014 An agent turn begins (user message received) on_turn_end \u2014 An agent turn completes (response generated) on_turn_error \u2014 An error occurs during a turn Tool Events \u00b6 on_tool_call_start \u2014 Agent initiates a tool call on_tool_call_end \u2014 Tool execution completes on_tool_call_error \u2014 Tool execution fails Message Events \u00b6 on_user_message \u2014 User submits a message on_assistant_message \u2014 Agent generates a response on_system_message \u2014 System injects context Provider Events \u00b6 on_llm_request \u2014 Request sent to LLM provider on_llm_response \u2014 Response received from provider on_llm_stream_chunk \u2014 Streaming chunk received Each event provides a HookContext with relevant data about the event, including timing, identifiers, and payload information. Built-in Hooks \u00b6 Amplifier provides several hooks out of the box: MetricsHook \u00b6 Collects timing and usage metrics for observability: from amplifier_core.hooks import MetricsHook metrics_hook = MetricsHook ( emit_interval = 60 , # Emit aggregated metrics every 60 seconds include_tool_timing = True ) GuardrailHook \u00b6 Enforces safety constraints and policies: from amplifier_core.hooks import GuardrailHook guardrail_hook = GuardrailHook ( block_patterns = [ r \"password\" , r \"secret\" ], max_tool_calls_per_turn = 50 ) AuditHook \u00b6 Records a complete audit trail of agent activity: from amplifier_core.hooks import AuditHook audit_hook = AuditHook ( output_path = \"./audit.jsonl\" , include_payloads = True ) ContextInjectionHook \u00b6 Injects dynamic context into agent prompts: from amplifier_core.hooks import ContextInjectionHook context_hook = ContextInjectionHook ( injectors = [ lambda ctx : f \"Current time: { datetime . now () } \" , lambda ctx : f \"Session ID: { ctx . session_id } \" ] ) Creating Hooks \u00b6 Creating custom hooks is straightforward. Implement the Hook base class and override the event methods you care about. Basic Hook Structure \u00b6 from amplifier_core.hooks import Hook , HookContext from typing import Optional class MyCustomHook ( Hook ): \"\"\"Custom hook with selective event handling.\"\"\" def __init__ ( self , config : dict ): self . config = config async def on_turn_start ( self , ctx : HookContext ) -> None : # Called when a turn begins pass async def on_tool_call_end ( self , ctx : HookContext ) -> None : # Called after each tool completes tool_name = ctx . tool_name duration = ctx . duration_ms print ( f \"Tool { tool_name } completed in { duration } ms\" ) Hook with State \u00b6 Hooks can maintain state across events: class TokenCounterHook ( Hook ): \"\"\"Tracks token usage across a session.\"\"\" def __init__ ( self ): self . total_input_tokens = 0 self . total_output_tokens = 0 async def on_llm_response ( self , ctx : HookContext ) -> None : usage = ctx . payload . get ( \"usage\" , {}) self . total_input_tokens += usage . get ( \"input_tokens\" , 0 ) self . total_output_tokens += usage . get ( \"output_tokens\" , 0 ) async def on_session_end ( self , ctx : HookContext ) -> None : print ( f \"Session totals: { self . total_input_tokens } in, \" f \" { self . total_output_tokens } out\" ) Registering Hooks \u00b6 Register hooks when creating an agent or session: from amplifier_core import Agent agent = Agent ( name = \"my-agent\" , hooks = [ MetricsHook (), MyCustomHook ( config = { \"verbose\" : True }), TokenCounterHook () ] ) Hook Ordering \u00b6 Hooks execute in registration order. If order matters (e.g., a guardrail should run before logging), register them accordingly: hooks = [ GuardrailHook (), # Check constraints first AuditHook (), # Then record the activity MetricsHook () # Finally collect metrics ] Error Handling in Hooks \u00b6 Hook errors are isolated\u2014a failing hook won't crash the agent: class SafeHook ( Hook ): async def on_turn_end ( self , ctx : HookContext ) -> None : try : await self . do_something_risky () except Exception as e : # Log but don't propagate logger . error ( f \"Hook error: { e } \" ) Key Takeaways \u00b6 Hooks are observers, not actors. They watch lifecycle events without interfering with agent logic. The agent doesn't know hooks exist. Use hooks for cross-cutting concerns. Logging, metrics, auditing, guardrails, and context injection are perfect hook use cases. Tools vs hooks is about control. Agents control tool usage; the system controls hook invocation. Choose based on who should decide when the functionality runs. Hooks execute in order. Registration order determines execution order. Place guardrails before audit hooks if you want to audit blocked requests. Keep hooks lightweight. Hooks run synchronously in the event flow. Heavy processing should be offloaded to background tasks. Hooks are isolated. A failing hook won't crash your agent, but you should still handle errors gracefully. State is per-instance. Each hook instance maintains its own state. Create new instances for independent tracking. Hooks embody Amplifier's philosophy of composable, non-intrusive extensibility. They let you add powerful functionality to any agent without touching its core implementation.","title":"Hooks"},{"location":"concepts/hooks.html#understanding-hooks","text":"Hooks are Amplifier's mechanism for observing and reacting to events in the agent lifecycle. They allow you to extend agent behavior without modifying core logic, enabling cross-cutting concerns like logging, metrics, guardrails, and custom integrations.","title":"Understanding Hooks"},{"location":"concepts/hooks.html#what-is-a-hook","text":"A hook is a lifecycle observer that receives notifications when specific events occur during agent execution. Unlike tools that agents actively invoke, hooks passively listen and respond to the natural flow of agent activity. Think of hooks as event listeners attached to the agent runtime. When an agent starts a turn, calls a tool, receives a response, or completes its work, hooks are notified and can take action. from amplifier_core.hooks import Hook , HookContext class LoggingHook ( Hook ): \"\"\"A simple hook that logs agent activity.\"\"\" async def on_turn_start ( self , ctx : HookContext ) -> None : print ( f \"Turn started: { ctx . turn_id } \" ) async def on_turn_end ( self , ctx : HookContext ) -> None : print ( f \"Turn completed in { ctx . duration_ms } ms\" ) Hooks are registered with the agent runtime and automatically invoked at the appropriate lifecycle points. You don't call hooks directly\u2014the system calls them for you.","title":"What is a Hook?"},{"location":"concepts/hooks.html#hook-vs-tool","text":"Understanding the distinction between hooks and tools is fundamental to Amplifier's design: Aspect Tool Hook Invocation Agent explicitly calls System automatically triggers Control Agent decides when to use Fires on lifecycle events Visibility Agent sees and chooses Transparent to agent Purpose Provide capabilities Observe and react Return value Returns data to agent No return to agent Tools are capabilities \u2014they extend what an agent can do . A file-reading tool gives the agent the ability to read files. The agent decides when and how to use it. Hooks are observers \u2014they extend what happens during execution. A logging hook records every tool call, but the agent doesn't know or care that logging is happening. This separation keeps agent logic clean while allowing powerful cross-cutting functionality.","title":"Hook vs Tool"},{"location":"concepts/hooks.html#event-types","text":"Hooks can subscribe to various lifecycle events. Here are the primary event categories:","title":"Event Types"},{"location":"concepts/hooks.html#session-events","text":"on_session_start \u2014 A new session begins on_session_end \u2014 A session completes or terminates on_session_resume \u2014 A persisted session resumes","title":"Session Events"},{"location":"concepts/hooks.html#turn-events","text":"on_turn_start \u2014 An agent turn begins (user message received) on_turn_end \u2014 An agent turn completes (response generated) on_turn_error \u2014 An error occurs during a turn","title":"Turn Events"},{"location":"concepts/hooks.html#tool-events","text":"on_tool_call_start \u2014 Agent initiates a tool call on_tool_call_end \u2014 Tool execution completes on_tool_call_error \u2014 Tool execution fails","title":"Tool Events"},{"location":"concepts/hooks.html#message-events","text":"on_user_message \u2014 User submits a message on_assistant_message \u2014 Agent generates a response on_system_message \u2014 System injects context","title":"Message Events"},{"location":"concepts/hooks.html#provider-events","text":"on_llm_request \u2014 Request sent to LLM provider on_llm_response \u2014 Response received from provider on_llm_stream_chunk \u2014 Streaming chunk received Each event provides a HookContext with relevant data about the event, including timing, identifiers, and payload information.","title":"Provider Events"},{"location":"concepts/hooks.html#built-in-hooks","text":"Amplifier provides several hooks out of the box:","title":"Built-in Hooks"},{"location":"concepts/hooks.html#metricshook","text":"Collects timing and usage metrics for observability: from amplifier_core.hooks import MetricsHook metrics_hook = MetricsHook ( emit_interval = 60 , # Emit aggregated metrics every 60 seconds include_tool_timing = True )","title":"MetricsHook"},{"location":"concepts/hooks.html#guardrailhook","text":"Enforces safety constraints and policies: from amplifier_core.hooks import GuardrailHook guardrail_hook = GuardrailHook ( block_patterns = [ r \"password\" , r \"secret\" ], max_tool_calls_per_turn = 50 )","title":"GuardrailHook"},{"location":"concepts/hooks.html#audithook","text":"Records a complete audit trail of agent activity: from amplifier_core.hooks import AuditHook audit_hook = AuditHook ( output_path = \"./audit.jsonl\" , include_payloads = True )","title":"AuditHook"},{"location":"concepts/hooks.html#contextinjectionhook","text":"Injects dynamic context into agent prompts: from amplifier_core.hooks import ContextInjectionHook context_hook = ContextInjectionHook ( injectors = [ lambda ctx : f \"Current time: { datetime . now () } \" , lambda ctx : f \"Session ID: { ctx . session_id } \" ] )","title":"ContextInjectionHook"},{"location":"concepts/hooks.html#creating-hooks","text":"Creating custom hooks is straightforward. Implement the Hook base class and override the event methods you care about.","title":"Creating Hooks"},{"location":"concepts/hooks.html#basic-hook-structure","text":"from amplifier_core.hooks import Hook , HookContext from typing import Optional class MyCustomHook ( Hook ): \"\"\"Custom hook with selective event handling.\"\"\" def __init__ ( self , config : dict ): self . config = config async def on_turn_start ( self , ctx : HookContext ) -> None : # Called when a turn begins pass async def on_tool_call_end ( self , ctx : HookContext ) -> None : # Called after each tool completes tool_name = ctx . tool_name duration = ctx . duration_ms print ( f \"Tool { tool_name } completed in { duration } ms\" )","title":"Basic Hook Structure"},{"location":"concepts/hooks.html#hook-with-state","text":"Hooks can maintain state across events: class TokenCounterHook ( Hook ): \"\"\"Tracks token usage across a session.\"\"\" def __init__ ( self ): self . total_input_tokens = 0 self . total_output_tokens = 0 async def on_llm_response ( self , ctx : HookContext ) -> None : usage = ctx . payload . get ( \"usage\" , {}) self . total_input_tokens += usage . get ( \"input_tokens\" , 0 ) self . total_output_tokens += usage . get ( \"output_tokens\" , 0 ) async def on_session_end ( self , ctx : HookContext ) -> None : print ( f \"Session totals: { self . total_input_tokens } in, \" f \" { self . total_output_tokens } out\" )","title":"Hook with State"},{"location":"concepts/hooks.html#registering-hooks","text":"Register hooks when creating an agent or session: from amplifier_core import Agent agent = Agent ( name = \"my-agent\" , hooks = [ MetricsHook (), MyCustomHook ( config = { \"verbose\" : True }), TokenCounterHook () ] )","title":"Registering Hooks"},{"location":"concepts/hooks.html#hook-ordering","text":"Hooks execute in registration order. If order matters (e.g., a guardrail should run before logging), register them accordingly: hooks = [ GuardrailHook (), # Check constraints first AuditHook (), # Then record the activity MetricsHook () # Finally collect metrics ]","title":"Hook Ordering"},{"location":"concepts/hooks.html#error-handling-in-hooks","text":"Hook errors are isolated\u2014a failing hook won't crash the agent: class SafeHook ( Hook ): async def on_turn_end ( self , ctx : HookContext ) -> None : try : await self . do_something_risky () except Exception as e : # Log but don't propagate logger . error ( f \"Hook error: { e } \" )","title":"Error Handling in Hooks"},{"location":"concepts/hooks.html#key-takeaways","text":"Hooks are observers, not actors. They watch lifecycle events without interfering with agent logic. The agent doesn't know hooks exist. Use hooks for cross-cutting concerns. Logging, metrics, auditing, guardrails, and context injection are perfect hook use cases. Tools vs hooks is about control. Agents control tool usage; the system controls hook invocation. Choose based on who should decide when the functionality runs. Hooks execute in order. Registration order determines execution order. Place guardrails before audit hooks if you want to audit blocked requests. Keep hooks lightweight. Hooks run synchronously in the event flow. Heavy processing should be offloaded to background tasks. Hooks are isolated. A failing hook won't crash your agent, but you should still handle errors gracefully. State is per-instance. Each hook instance maintains its own state. Create new instances for independent tracking. Hooks embody Amplifier's philosophy of composable, non-intrusive extensibility. They let you add powerful functionality to any agent without touching its core implementation.","title":"Key Takeaways"},{"location":"concepts/modules.html","text":"Understanding Modules \u00b6 Modules are the fundamental building blocks of Amplifier. They represent the \"bricks and studs\" philosophy\u2014self-contained units with standardized interfaces that snap together to create powerful AI applications. Understanding modules is essential to mastering Amplifier's architecture. What is a Module? \u00b6 A module is a self-contained unit of functionality that: Has a single, well-defined purpose Implements a specific contract (interface) Can be swapped, upgraded, or replaced without affecting others Operates independently while integrating seamlessly Think of modules like LEGO bricks. Each brick has a specific shape and purpose, but they all share the same connection system (studs and sockets). You can build anything by combining bricks, and you can always swap one brick for another of the same type. The Module Philosophy \u00b6 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 YOUR APPLICATION \u2502 \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 \u2502 \u2502Provider \u2502 \u2502 Tool \u2502 \u2502 Context \u2502 \u2502 Hook \u2502 \u2502 \u2502 \u2502 Module \u2502 \u2502 Module \u2502 \u2502 Module \u2502 \u2502 Module \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2518 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u2502 \u2502 \u2502 \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 \u2502 \u2502Orchestrator \u2502 \u2502 \u2502 \u2502 Module \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 Modules communicate through contracts , not implementations. This means: A Claude provider and an OpenAI provider are interchangeable A filesystem tool and a database tool both implement the same tool contract You can add observability hooks without changing any other code The 5 Module Types \u00b6 Amplifier defines exactly five module types. Each has a specific role and contract: Type Purpose Contract When It Runs Provider LLM backends complete() When AI response needed Tool Agent capabilities execute() When LLM requests action Orchestrator Main engine The agent loop Continuously during session Context Memory & state messages Before each LLM call Hook Observers events On system events Provider Modules \u00b6 Providers connect Amplifier to language models. They abstract away the differences between OpenAI, Anthropic, Azure, local models, and others. Contract: complete(messages, tools, config) -> response # All providers implement the same interface class Provider ( Protocol ): async def complete ( self , messages : list [ Message ], tools : list [ Tool ], config : CompletionConfig ) -> CompletionResponse : ... Key characteristics: - Handle authentication and API specifics internally - Normalize responses to a common format - Support streaming where available - Manage rate limiting and retries Examples: AnthropicProvider , OpenAIProvider , AzureProvider , OllamaProvider Tool Modules \u00b6 Tools give agents the ability to act in the world. They represent capabilities the LLM can invoke to accomplish tasks. Contract: execute(arguments) -> result class Tool ( Protocol ): name : str description : str parameters : JSONSchema async def execute ( self , arguments : dict ) -> ToolResult : ... Key characteristics: - Self-describing (name, description, parameters) - Executed when the LLM decides to use them - Return structured results back to the conversation - Can be dynamically enabled/disabled Examples: read_file , write_file , bash , web_search , grep Orchestrator Modules \u00b6 The orchestrator is the brain of the agent. It runs the main loop: getting context, calling the LLM, executing tools, and repeating. Contract: The agent loop itself class Orchestrator ( Protocol ): async def run ( self , session : Session ) -> None : while not done : # 1. Gather context messages = await context . get_messages () # 2. Call LLM response = await provider . complete ( messages , tools ) # 3. Process response if response . has_tool_calls : results = await execute_tools ( response . tool_calls ) # 4. Check completion done = response . is_final Key characteristics: - Controls the agent's decision-making flow - Manages turn-taking between user and agent - Coordinates all other module types - Handles completion conditions Examples: StandardOrchestrator , ReActOrchestrator , PlanningOrchestrator Context Modules \u00b6 Context modules manage what the agent \"knows\" during a conversation. They build the message history and inject relevant information. Contract: messages - provides the conversation context class Context ( Protocol ): async def get_messages ( self , session : Session ) -> list [ Message ]: ... async def add_message ( self , message : Message ) -> None : ... Key characteristics: - Maintain conversation history - Inject system prompts and instructions - Can add retrieved documents (RAG) - Handle context window limits Examples: ConversationContext , SlidingWindowContext , RAGContext Hook Modules \u00b6 Hooks observe and react to system events without modifying the core flow. They're perfect for logging, analytics, guardrails, and side effects. Contract: events - receives notifications class Hook ( Protocol ): async def on_event ( self , event : Event ) -> None : ... Key characteristics: - Passive observers (don't change main flow) - Subscribe to specific event types - Run asynchronously when events occur - Can emit their own events Examples: LoggingHook , MetricsHook , GuardrailHook , AuditHook Tool vs Hook \u00b6 This distinction confuses many newcomers. Here's the key difference: Aspect Tool Hook Triggered by LLM decides to use it Code events fire Purpose Give agent capabilities Observe/react to events Control flow Blocks until complete Runs asynchronously Visibility LLM knows about it LLM doesn't know Examples Read file, search web Log events, track metrics When to Use Tools \u00b6 Use a tool when the LLM needs to decide whether to use the capability: # Tool: LLM chooses when to search @tool async def web_search ( query : str ) -> str : \"\"\"Search the web for information.\"\"\" return await search_engine . query ( query ) The LLM sees this tool, understands its purpose, and invokes it when relevant. When to Use Hooks \u00b6 Use a hook when you want to observe without the LLM knowing : # Hook: Automatically logs all tool calls class ToolLoggingHook ( Hook ): async def on_event ( self , event : Event ): if event . type == \"tool_call\" : logger . info ( f \"Tool called: { event . tool_name } \" ) The LLM never knows this hook exists\u2014it just observes silently. The Decision Tree \u00b6 Should the LLM decide when this runs? \u2502 \u251c\u2500\u2500 YES \u2192 Use a TOOL \u2502 (agent capability) \u2502 \u2514\u2500\u2500 NO \u2192 Use a HOOK (system observation) Module Composition \u00b6 The power of modules comes from composition. You combine simple modules to create sophisticated behavior: # A simple but powerful agent configuration provider : anthropic orchestrator : standard tools : - read_file - write_file - bash - web_search context : - conversation - system_prompt hooks : - logging - metrics - guardrails Adding New Capabilities \u00b6 Want to add a new capability? Just add a module: tools : - read_file - write_file - bash - web_search - database_query # New capability! Swapping Implementations \u00b6 Need to change providers? Just swap: # Before provider : openai # After provider : anthropic Everything else stays the same. Module Contracts \u00b6 Every module type has a contract \u2014a promise about how it behaves. Contracts enable: Interchangeability : Any module implementing the contract works Testing : Mock modules that follow the contract Evolution : Improve internals without breaking interfaces The Contract Principle \u00b6 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 Module A \u2502 \u2502 Module B \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 (OpenAI) \u2502 \u2502 (Anthropic) \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 Contract \u2502 \u2502 complete() \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 Kernel \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 The kernel only knows about contracts, not implementations. This is what makes modules truly interchangeable. Key Takeaways \u00b6 Five module types : Provider, Tool, Orchestrator, Context, Hook\u2014each with a specific purpose Contracts over implementations : Modules are interchangeable because they implement standard contracts Tools vs Hooks : Tools are LLM-invoked capabilities; hooks are silent observers Composition is key : Combine simple modules to create powerful agents Single responsibility : Each module does one thing well The LEGO principle : Standard interfaces let you build anything from simple, swappable pieces What's Next? \u00b6 Now that you understand modules, explore each type in depth: Providers: Connecting to LLMs Tools: Agent Capabilities Orchestrators: The Agent Loop Context: Memory and State Hooks: Observability Or see modules in action: Building Your First Agent Module Configuration","title":"Modules"},{"location":"concepts/modules.html#understanding-modules","text":"Modules are the fundamental building blocks of Amplifier. They represent the \"bricks and studs\" philosophy\u2014self-contained units with standardized interfaces that snap together to create powerful AI applications. Understanding modules is essential to mastering Amplifier's architecture.","title":"Understanding Modules"},{"location":"concepts/modules.html#what-is-a-module","text":"A module is a self-contained unit of functionality that: Has a single, well-defined purpose Implements a specific contract (interface) Can be swapped, upgraded, or replaced without affecting others Operates independently while integrating seamlessly Think of modules like LEGO bricks. Each brick has a specific shape and purpose, but they all share the same connection system (studs and sockets). You can build anything by combining bricks, and you can always swap one brick for another of the same type.","title":"What is a Module?"},{"location":"concepts/modules.html#the-module-philosophy","text":"\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 YOUR APPLICATION \u2502 \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 \u2502 \u2502Provider \u2502 \u2502 Tool \u2502 \u2502 Context \u2502 \u2502 Hook \u2502 \u2502 \u2502 \u2502 Module \u2502 \u2502 Module \u2502 \u2502 Module \u2502 \u2502 Module \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2518 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u2502 \u2502 \u2502 \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 \u2502 \u2502Orchestrator \u2502 \u2502 \u2502 \u2502 Module \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 Modules communicate through contracts , not implementations. This means: A Claude provider and an OpenAI provider are interchangeable A filesystem tool and a database tool both implement the same tool contract You can add observability hooks without changing any other code","title":"The Module Philosophy"},{"location":"concepts/modules.html#the-5-module-types","text":"Amplifier defines exactly five module types. Each has a specific role and contract: Type Purpose Contract When It Runs Provider LLM backends complete() When AI response needed Tool Agent capabilities execute() When LLM requests action Orchestrator Main engine The agent loop Continuously during session Context Memory & state messages Before each LLM call Hook Observers events On system events","title":"The 5 Module Types"},{"location":"concepts/modules.html#provider-modules","text":"Providers connect Amplifier to language models. They abstract away the differences between OpenAI, Anthropic, Azure, local models, and others. Contract: complete(messages, tools, config) -> response # All providers implement the same interface class Provider ( Protocol ): async def complete ( self , messages : list [ Message ], tools : list [ Tool ], config : CompletionConfig ) -> CompletionResponse : ... Key characteristics: - Handle authentication and API specifics internally - Normalize responses to a common format - Support streaming where available - Manage rate limiting and retries Examples: AnthropicProvider , OpenAIProvider , AzureProvider , OllamaProvider","title":"Provider Modules"},{"location":"concepts/modules.html#tool-modules","text":"Tools give agents the ability to act in the world. They represent capabilities the LLM can invoke to accomplish tasks. Contract: execute(arguments) -> result class Tool ( Protocol ): name : str description : str parameters : JSONSchema async def execute ( self , arguments : dict ) -> ToolResult : ... Key characteristics: - Self-describing (name, description, parameters) - Executed when the LLM decides to use them - Return structured results back to the conversation - Can be dynamically enabled/disabled Examples: read_file , write_file , bash , web_search , grep","title":"Tool Modules"},{"location":"concepts/modules.html#orchestrator-modules","text":"The orchestrator is the brain of the agent. It runs the main loop: getting context, calling the LLM, executing tools, and repeating. Contract: The agent loop itself class Orchestrator ( Protocol ): async def run ( self , session : Session ) -> None : while not done : # 1. Gather context messages = await context . get_messages () # 2. Call LLM response = await provider . complete ( messages , tools ) # 3. Process response if response . has_tool_calls : results = await execute_tools ( response . tool_calls ) # 4. Check completion done = response . is_final Key characteristics: - Controls the agent's decision-making flow - Manages turn-taking between user and agent - Coordinates all other module types - Handles completion conditions Examples: StandardOrchestrator , ReActOrchestrator , PlanningOrchestrator","title":"Orchestrator Modules"},{"location":"concepts/modules.html#context-modules","text":"Context modules manage what the agent \"knows\" during a conversation. They build the message history and inject relevant information. Contract: messages - provides the conversation context class Context ( Protocol ): async def get_messages ( self , session : Session ) -> list [ Message ]: ... async def add_message ( self , message : Message ) -> None : ... Key characteristics: - Maintain conversation history - Inject system prompts and instructions - Can add retrieved documents (RAG) - Handle context window limits Examples: ConversationContext , SlidingWindowContext , RAGContext","title":"Context Modules"},{"location":"concepts/modules.html#hook-modules","text":"Hooks observe and react to system events without modifying the core flow. They're perfect for logging, analytics, guardrails, and side effects. Contract: events - receives notifications class Hook ( Protocol ): async def on_event ( self , event : Event ) -> None : ... Key characteristics: - Passive observers (don't change main flow) - Subscribe to specific event types - Run asynchronously when events occur - Can emit their own events Examples: LoggingHook , MetricsHook , GuardrailHook , AuditHook","title":"Hook Modules"},{"location":"concepts/modules.html#tool-vs-hook","text":"This distinction confuses many newcomers. Here's the key difference: Aspect Tool Hook Triggered by LLM decides to use it Code events fire Purpose Give agent capabilities Observe/react to events Control flow Blocks until complete Runs asynchronously Visibility LLM knows about it LLM doesn't know Examples Read file, search web Log events, track metrics","title":"Tool vs Hook"},{"location":"concepts/modules.html#when-to-use-tools","text":"Use a tool when the LLM needs to decide whether to use the capability: # Tool: LLM chooses when to search @tool async def web_search ( query : str ) -> str : \"\"\"Search the web for information.\"\"\" return await search_engine . query ( query ) The LLM sees this tool, understands its purpose, and invokes it when relevant.","title":"When to Use Tools"},{"location":"concepts/modules.html#when-to-use-hooks","text":"Use a hook when you want to observe without the LLM knowing : # Hook: Automatically logs all tool calls class ToolLoggingHook ( Hook ): async def on_event ( self , event : Event ): if event . type == \"tool_call\" : logger . info ( f \"Tool called: { event . tool_name } \" ) The LLM never knows this hook exists\u2014it just observes silently.","title":"When to Use Hooks"},{"location":"concepts/modules.html#the-decision-tree","text":"Should the LLM decide when this runs? \u2502 \u251c\u2500\u2500 YES \u2192 Use a TOOL \u2502 (agent capability) \u2502 \u2514\u2500\u2500 NO \u2192 Use a HOOK (system observation)","title":"The Decision Tree"},{"location":"concepts/modules.html#module-composition","text":"The power of modules comes from composition. You combine simple modules to create sophisticated behavior: # A simple but powerful agent configuration provider : anthropic orchestrator : standard tools : - read_file - write_file - bash - web_search context : - conversation - system_prompt hooks : - logging - metrics - guardrails","title":"Module Composition"},{"location":"concepts/modules.html#adding-new-capabilities","text":"Want to add a new capability? Just add a module: tools : - read_file - write_file - bash - web_search - database_query # New capability!","title":"Adding New Capabilities"},{"location":"concepts/modules.html#swapping-implementations","text":"Need to change providers? Just swap: # Before provider : openai # After provider : anthropic Everything else stays the same.","title":"Swapping Implementations"},{"location":"concepts/modules.html#module-contracts","text":"Every module type has a contract \u2014a promise about how it behaves. Contracts enable: Interchangeability : Any module implementing the contract works Testing : Mock modules that follow the contract Evolution : Improve internals without breaking interfaces","title":"Module Contracts"},{"location":"concepts/modules.html#the-contract-principle","text":"\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 Module A \u2502 \u2502 Module B \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 (OpenAI) \u2502 \u2502 (Anthropic) \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 Contract \u2502 \u2502 complete() \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 Kernel \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 The kernel only knows about contracts, not implementations. This is what makes modules truly interchangeable.","title":"The Contract Principle"},{"location":"concepts/modules.html#key-takeaways","text":"Five module types : Provider, Tool, Orchestrator, Context, Hook\u2014each with a specific purpose Contracts over implementations : Modules are interchangeable because they implement standard contracts Tools vs Hooks : Tools are LLM-invoked capabilities; hooks are silent observers Composition is key : Combine simple modules to create powerful agents Single responsibility : Each module does one thing well The LEGO principle : Standard interfaces let you build anything from simple, swappable pieces","title":"Key Takeaways"},{"location":"concepts/modules.html#whats-next","text":"Now that you understand modules, explore each type in depth: Providers: Connecting to LLMs Tools: Agent Capabilities Orchestrators: The Agent Loop Context: Memory and State Hooks: Observability Or see modules in action: Building Your First Agent Module Configuration","title":"What's Next?"},{"location":"concepts/recipes.html","text":"Understanding Recipes \u00b6 Recipes are declarative YAML specifications that define multi-step agent workflows. They allow you to orchestrate complex tasks by breaking them into sequential steps, each potentially delegating to different agents. Recipes provide structure, reproducibility, and human oversight for AI-driven processes. What is a Recipe? \u00b6 A Recipe is a blueprint for agent orchestration. Rather than manually invoking agents step-by-step, you define the entire workflow upfront in a YAML file. The recipe executor then handles: Sequential execution - Steps run in order, with each step's output available to subsequent steps State persistence - Context accumulates across steps, building a shared understanding Automatic checkpointing - Sessions can be resumed if interrupted Error handling - Built-in retry logic and failure management Approval gates - Human-in-the-loop checkpoints for critical decisions Think of recipes as the difference between giving verbal instructions one at a time versus handing someone a complete written procedure. Both accomplish the goal, but the written procedure is reproducible, auditable, and can be improved over time. A Simple Example \u00b6 name : code-review description : Review code changes and suggest improvements steps : - id : analyze agent : foundation:explorer instruction : | Analyze the code in {{ file_path }}. Identify the main purpose, structure, and any patterns used. - id : review agent : foundation:zen-architect instruction : | Based on the analysis: {{ steps.analyze.result }} Review this code for: - Adherence to simplicity principles - Potential bugs or edge cases - Opportunities for improvement This recipe defines two steps: first exploring the code structure, then reviewing it with architectural expertise. The second step receives the output of the first through template variables. When to Use Recipes \u00b6 Recipes excel in scenarios where you need: Reproducible Workflows \u00b6 When you find yourself repeatedly performing the same multi-agent task, a recipe captures that process. Instead of remembering which agents to invoke and in what order, you run the recipe and get consistent results. Examples: - Code review pipelines - Documentation generation - Release preparation checklists - Security audits Complex Multi-Step Tasks \u00b6 Some tasks naturally decompose into phases that build on each other. Recipes make these dependencies explicit and ensure proper sequencing. Examples: - Feature implementation (design \u2192 implement \u2192 test \u2192 document) - Bug investigation (reproduce \u2192 analyze \u2192 fix \u2192 verify) - Migration tasks (assess \u2192 plan \u2192 execute \u2192 validate) Tasks Requiring Human Oversight \u00b6 When certain decisions shouldn't be fully automated, recipes support approval gates. Execution pauses until a human reviews and approves (or rejects) continuing. Examples: - Production deployments - Security-sensitive changes - Decisions with significant business impact Collaborative Workflows \u00b6 Recipes create a shared understanding between team members. Anyone can run the recipe and understand exactly what steps will be taken, making handoffs and reviews straightforward. Recipe Structure \u00b6 Every recipe follows a consistent structure with required and optional elements. Required Elements \u00b6 name : my-workflow # Unique identifier for the recipe description : What it does # Human-readable description steps : # List of steps to execute - id : step-one # Unique step identifier agent : agent:name # Agent to invoke instruction : | # Task for the agent What to do... Optional Elements \u00b6 # Context variables (can be overridden at execution time) context : default_branch : main environment : staging # Global settings settings : timeout : 300 # Default timeout per step (seconds) retry_count : 2 # Default retry attempts on failure # Step-level options steps : - id : example agent : foundation:explorer instruction : Explore the codebase timeout : 600 # Override default timeout retry_count : 3 # Override default retries on_error : continue # continue, fail, or skip Flat vs. Staged Recipes \u00b6 Recipes come in two flavors: Flat recipes execute all steps sequentially without pause: name : simple-task steps : - id : step-one agent : foundation:explorer instruction : First task - id : step-two agent : foundation:file-ops instruction : Second task Staged recipes group steps into stages with approval gates between them: name : careful-deployment stages : - name : planning steps : - id : analyze agent : foundation:zen-architect instruction : Plan the deployment requires_approval : true - name : execution steps : - id : deploy agent : foundation:modular-builder instruction : Execute the deployment plan Steps and Context \u00b6 Steps are the fundamental units of a recipe. Each step invokes an agent with specific instructions and can access accumulated context from previous steps. Step Anatomy \u00b6 steps : - id : unique-identifier # Required: referenced by other steps agent : bundle:agent-name # Required: which agent to use instruction : | # Required: what to do Detailed instructions for the agent. Can span multiple lines. # Optional fields timeout : 300 # Seconds before timeout retry_count : 2 # Retries on failure on_error : fail # fail, continue, or skip condition : \"{{ steps.previous.success }}\" # Conditional execution Context Flow \u00b6 Context flows through recipes in two ways: 1. Explicit context variables - Defined at recipe level or passed at execution: context : project_name : my-app target_branch : main steps : - id : setup agent : foundation:file-ops instruction : | Working on project: {{ project_name }} Target branch: {{ target_branch }} 2. Step results - Output from previous steps: steps : - id : discover agent : foundation:explorer instruction : Find all Python files in src/ - id : analyze agent : lsp-python:python-code-intel instruction : | Analyze these files: {{ steps.discover.result }} Template Syntax \u00b6 Recipes use Jinja2-style templates for variable interpolation: Pattern Description {{ variable }} Insert a context variable {{ steps.id.result }} Insert a step's result {{ steps.id.success }} Boolean: did the step succeed? {% if condition %}...{% endif %} Conditional content {% for item in list %}...{% endfor %} Loop over items Advanced Context Features \u00b6 Foreach loops execute a step multiple times: steps : - id : review-each agent : foundation:zen-architect foreach : \"{{ files }}\" instruction : | Review the file: {{ item }} Conditional execution skips steps based on conditions: steps : - id : deploy-prod agent : foundation:modular-builder condition : \"{{ environment == 'production' }}\" instruction : Deploy to production servers Approval Gates \u00b6 Approval gates pause recipe execution until a human approves or denies continuation. They provide critical oversight for high-stakes workflows. Defining Approval Gates \u00b6 In staged recipes, add requires_approval: true to a stage: stages : - name : analysis steps : - id : security-scan agent : foundation:security-guardian instruction : Scan for vulnerabilities requires_approval : true approval_message : | Security scan complete. Review findings before proceeding. - name : deployment steps : - id : deploy agent : foundation:modular-builder instruction : Deploy the application Managing Approvals \u00b6 When a recipe reaches an approval gate, it pauses and waits. You can manage pending approvals: # List all pending approvals recipes operation=approvals # Approve a stage to continue recipes operation=approve session_id=xxx stage_name=analysis # Deny a stage (stops execution) recipes operation=deny session_id=xxx stage_name=analysis reason=\"Found critical vulnerability\" Approval Metadata \u00b6 When approving, you can include metadata that becomes available to subsequent steps: # The approval context is available in later steps steps : - id : post-approval agent : foundation:modular-builder instruction : | Approval notes: {{ approval.notes }} Approved by: {{ approval.user }} Best Practices for Approval Gates \u00b6 Include clear context - The approval message should summarize what was done and what will happen next Use sparingly - Too many gates slow workflows; reserve for genuinely critical checkpoints Provide actionable information - Include links, summaries, or specific items to review Consider timeouts - Long-pending approvals may indicate a stale workflow Recipe Operations \u00b6 The recipe system supports several operations: Operation Description execute Run a recipe from a YAML file resume Continue an interrupted session list Show active recipe sessions validate Check recipe structure without running approvals List pending approvals approve Approve a pending stage deny Deny a pending stage Execution Example \u00b6 # Execute a recipe with context recipes operation=execute recipe_path=review.yaml context={\"file_path\" : \"src/main.py\" } # Resume an interrupted session recipes operation=resume session_id=recipe_20260110_143022_a3f2 # Validate before running recipes operation=validate recipe_path=new-recipe.yaml Error Handling \u00b6 Recipes provide flexible error handling at multiple levels: Step-Level Error Handling \u00b6 steps : - id : risky-operation agent : foundation:integration-specialist instruction : Call external API retry_count : 3 # Retry up to 3 times timeout : 60 # Timeout after 60 seconds on_error : continue # Don't fail the whole recipe Error Strategies \u00b6 Strategy Behavior fail Stop the recipe immediately (default) continue Log the error and proceed to next step skip Skip dependent steps and continue Accessing Error Information \u00b6 Failed steps provide error context: steps : - id : handle-failure condition : \"{{ not steps.risky-operation.success }}\" agent : foundation:bug-hunter instruction : | The previous step failed with: {{ steps.risky-operation.error }} Investigate and suggest fixes. Key Takeaways \u00b6 Recipes are declarative workflows - Define what should happen, not how to orchestrate it manually Steps build on each other - Each step can access results from previous steps through template variables Two flavors exist - Flat recipes for simple sequences, staged recipes for workflows needing approval gates Context flows automatically - Variables and results accumulate, giving later steps full awareness of earlier work Approval gates enable oversight - Pause execution at critical points for human review and decision-making Error handling is flexible - Configure retries, timeouts, and failure strategies per-step or globally Sessions are resumable - Interrupted recipes can continue from where they left off Validation prevents surprises - Check recipe structure before execution to catch errors early Recipes transform ad-hoc agent orchestration into reproducible, auditable processes. Start simple with flat recipes, add stages and approvals as workflows mature, and leverage context flow to build sophisticated multi-agent pipelines.","title":"Recipes"},{"location":"concepts/recipes.html#understanding-recipes","text":"Recipes are declarative YAML specifications that define multi-step agent workflows. They allow you to orchestrate complex tasks by breaking them into sequential steps, each potentially delegating to different agents. Recipes provide structure, reproducibility, and human oversight for AI-driven processes.","title":"Understanding Recipes"},{"location":"concepts/recipes.html#what-is-a-recipe","text":"A Recipe is a blueprint for agent orchestration. Rather than manually invoking agents step-by-step, you define the entire workflow upfront in a YAML file. The recipe executor then handles: Sequential execution - Steps run in order, with each step's output available to subsequent steps State persistence - Context accumulates across steps, building a shared understanding Automatic checkpointing - Sessions can be resumed if interrupted Error handling - Built-in retry logic and failure management Approval gates - Human-in-the-loop checkpoints for critical decisions Think of recipes as the difference between giving verbal instructions one at a time versus handing someone a complete written procedure. Both accomplish the goal, but the written procedure is reproducible, auditable, and can be improved over time.","title":"What is a Recipe?"},{"location":"concepts/recipes.html#a-simple-example","text":"name : code-review description : Review code changes and suggest improvements steps : - id : analyze agent : foundation:explorer instruction : | Analyze the code in {{ file_path }}. Identify the main purpose, structure, and any patterns used. - id : review agent : foundation:zen-architect instruction : | Based on the analysis: {{ steps.analyze.result }} Review this code for: - Adherence to simplicity principles - Potential bugs or edge cases - Opportunities for improvement This recipe defines two steps: first exploring the code structure, then reviewing it with architectural expertise. The second step receives the output of the first through template variables.","title":"A Simple Example"},{"location":"concepts/recipes.html#when-to-use-recipes","text":"Recipes excel in scenarios where you need:","title":"When to Use Recipes"},{"location":"concepts/recipes.html#reproducible-workflows","text":"When you find yourself repeatedly performing the same multi-agent task, a recipe captures that process. Instead of remembering which agents to invoke and in what order, you run the recipe and get consistent results. Examples: - Code review pipelines - Documentation generation - Release preparation checklists - Security audits","title":"Reproducible Workflows"},{"location":"concepts/recipes.html#complex-multi-step-tasks","text":"Some tasks naturally decompose into phases that build on each other. Recipes make these dependencies explicit and ensure proper sequencing. Examples: - Feature implementation (design \u2192 implement \u2192 test \u2192 document) - Bug investigation (reproduce \u2192 analyze \u2192 fix \u2192 verify) - Migration tasks (assess \u2192 plan \u2192 execute \u2192 validate)","title":"Complex Multi-Step Tasks"},{"location":"concepts/recipes.html#tasks-requiring-human-oversight","text":"When certain decisions shouldn't be fully automated, recipes support approval gates. Execution pauses until a human reviews and approves (or rejects) continuing. Examples: - Production deployments - Security-sensitive changes - Decisions with significant business impact","title":"Tasks Requiring Human Oversight"},{"location":"concepts/recipes.html#collaborative-workflows","text":"Recipes create a shared understanding between team members. Anyone can run the recipe and understand exactly what steps will be taken, making handoffs and reviews straightforward.","title":"Collaborative Workflows"},{"location":"concepts/recipes.html#recipe-structure","text":"Every recipe follows a consistent structure with required and optional elements.","title":"Recipe Structure"},{"location":"concepts/recipes.html#required-elements","text":"name : my-workflow # Unique identifier for the recipe description : What it does # Human-readable description steps : # List of steps to execute - id : step-one # Unique step identifier agent : agent:name # Agent to invoke instruction : | # Task for the agent What to do...","title":"Required Elements"},{"location":"concepts/recipes.html#optional-elements","text":"# Context variables (can be overridden at execution time) context : default_branch : main environment : staging # Global settings settings : timeout : 300 # Default timeout per step (seconds) retry_count : 2 # Default retry attempts on failure # Step-level options steps : - id : example agent : foundation:explorer instruction : Explore the codebase timeout : 600 # Override default timeout retry_count : 3 # Override default retries on_error : continue # continue, fail, or skip","title":"Optional Elements"},{"location":"concepts/recipes.html#flat-vs-staged-recipes","text":"Recipes come in two flavors: Flat recipes execute all steps sequentially without pause: name : simple-task steps : - id : step-one agent : foundation:explorer instruction : First task - id : step-two agent : foundation:file-ops instruction : Second task Staged recipes group steps into stages with approval gates between them: name : careful-deployment stages : - name : planning steps : - id : analyze agent : foundation:zen-architect instruction : Plan the deployment requires_approval : true - name : execution steps : - id : deploy agent : foundation:modular-builder instruction : Execute the deployment plan","title":"Flat vs. Staged Recipes"},{"location":"concepts/recipes.html#steps-and-context","text":"Steps are the fundamental units of a recipe. Each step invokes an agent with specific instructions and can access accumulated context from previous steps.","title":"Steps and Context"},{"location":"concepts/recipes.html#step-anatomy","text":"steps : - id : unique-identifier # Required: referenced by other steps agent : bundle:agent-name # Required: which agent to use instruction : | # Required: what to do Detailed instructions for the agent. Can span multiple lines. # Optional fields timeout : 300 # Seconds before timeout retry_count : 2 # Retries on failure on_error : fail # fail, continue, or skip condition : \"{{ steps.previous.success }}\" # Conditional execution","title":"Step Anatomy"},{"location":"concepts/recipes.html#context-flow","text":"Context flows through recipes in two ways: 1. Explicit context variables - Defined at recipe level or passed at execution: context : project_name : my-app target_branch : main steps : - id : setup agent : foundation:file-ops instruction : | Working on project: {{ project_name }} Target branch: {{ target_branch }} 2. Step results - Output from previous steps: steps : - id : discover agent : foundation:explorer instruction : Find all Python files in src/ - id : analyze agent : lsp-python:python-code-intel instruction : | Analyze these files: {{ steps.discover.result }}","title":"Context Flow"},{"location":"concepts/recipes.html#template-syntax","text":"Recipes use Jinja2-style templates for variable interpolation: Pattern Description {{ variable }} Insert a context variable {{ steps.id.result }} Insert a step's result {{ steps.id.success }} Boolean: did the step succeed? {% if condition %}...{% endif %} Conditional content {% for item in list %}...{% endfor %} Loop over items","title":"Template Syntax"},{"location":"concepts/recipes.html#advanced-context-features","text":"Foreach loops execute a step multiple times: steps : - id : review-each agent : foundation:zen-architect foreach : \"{{ files }}\" instruction : | Review the file: {{ item }} Conditional execution skips steps based on conditions: steps : - id : deploy-prod agent : foundation:modular-builder condition : \"{{ environment == 'production' }}\" instruction : Deploy to production servers","title":"Advanced Context Features"},{"location":"concepts/recipes.html#approval-gates","text":"Approval gates pause recipe execution until a human approves or denies continuation. They provide critical oversight for high-stakes workflows.","title":"Approval Gates"},{"location":"concepts/recipes.html#defining-approval-gates","text":"In staged recipes, add requires_approval: true to a stage: stages : - name : analysis steps : - id : security-scan agent : foundation:security-guardian instruction : Scan for vulnerabilities requires_approval : true approval_message : | Security scan complete. Review findings before proceeding. - name : deployment steps : - id : deploy agent : foundation:modular-builder instruction : Deploy the application","title":"Defining Approval Gates"},{"location":"concepts/recipes.html#managing-approvals","text":"When a recipe reaches an approval gate, it pauses and waits. You can manage pending approvals: # List all pending approvals recipes operation=approvals # Approve a stage to continue recipes operation=approve session_id=xxx stage_name=analysis # Deny a stage (stops execution) recipes operation=deny session_id=xxx stage_name=analysis reason=\"Found critical vulnerability\"","title":"Managing Approvals"},{"location":"concepts/recipes.html#approval-metadata","text":"When approving, you can include metadata that becomes available to subsequent steps: # The approval context is available in later steps steps : - id : post-approval agent : foundation:modular-builder instruction : | Approval notes: {{ approval.notes }} Approved by: {{ approval.user }}","title":"Approval Metadata"},{"location":"concepts/recipes.html#best-practices-for-approval-gates","text":"Include clear context - The approval message should summarize what was done and what will happen next Use sparingly - Too many gates slow workflows; reserve for genuinely critical checkpoints Provide actionable information - Include links, summaries, or specific items to review Consider timeouts - Long-pending approvals may indicate a stale workflow","title":"Best Practices for Approval Gates"},{"location":"concepts/recipes.html#recipe-operations","text":"The recipe system supports several operations: Operation Description execute Run a recipe from a YAML file resume Continue an interrupted session list Show active recipe sessions validate Check recipe structure without running approvals List pending approvals approve Approve a pending stage deny Deny a pending stage","title":"Recipe Operations"},{"location":"concepts/recipes.html#execution-example","text":"# Execute a recipe with context recipes operation=execute recipe_path=review.yaml context={\"file_path\" : \"src/main.py\" } # Resume an interrupted session recipes operation=resume session_id=recipe_20260110_143022_a3f2 # Validate before running recipes operation=validate recipe_path=new-recipe.yaml","title":"Execution Example"},{"location":"concepts/recipes.html#error-handling","text":"Recipes provide flexible error handling at multiple levels:","title":"Error Handling"},{"location":"concepts/recipes.html#step-level-error-handling","text":"steps : - id : risky-operation agent : foundation:integration-specialist instruction : Call external API retry_count : 3 # Retry up to 3 times timeout : 60 # Timeout after 60 seconds on_error : continue # Don't fail the whole recipe","title":"Step-Level Error Handling"},{"location":"concepts/recipes.html#error-strategies","text":"Strategy Behavior fail Stop the recipe immediately (default) continue Log the error and proceed to next step skip Skip dependent steps and continue","title":"Error Strategies"},{"location":"concepts/recipes.html#accessing-error-information","text":"Failed steps provide error context: steps : - id : handle-failure condition : \"{{ not steps.risky-operation.success }}\" agent : foundation:bug-hunter instruction : | The previous step failed with: {{ steps.risky-operation.error }} Investigate and suggest fixes.","title":"Accessing Error Information"},{"location":"concepts/recipes.html#key-takeaways","text":"Recipes are declarative workflows - Define what should happen, not how to orchestrate it manually Steps build on each other - Each step can access results from previous steps through template variables Two flavors exist - Flat recipes for simple sequences, staged recipes for workflows needing approval gates Context flows automatically - Variables and results accumulate, giving later steps full awareness of earlier work Approval gates enable oversight - Pause execution at critical points for human review and decision-making Error handling is flexible - Configure retries, timeouts, and failure strategies per-step or globally Sessions are resumable - Interrupted recipes can continue from where they left off Validation prevents surprises - Check recipe structure before execution to catch errors early Recipes transform ad-hoc agent orchestration into reproducible, auditable processes. Start simple with flat recipes, add stages and approvals as workflows mature, and leverage context flow to build sophisticated multi-agent pipelines.","title":"Key Takeaways"},{"location":"concepts/skills.html","text":"Understanding Skills \u00b6 Skills are one of Amplifier's most powerful mechanisms for extending agent capabilities. They provide a way to package domain knowledge, best practices, and specialized workflows that agents can load on-demand. What is a Skill? \u00b6 A skill is loadable domain knowledge - a markdown file containing instructions, patterns, examples, and references that an agent can incorporate into its context when needed. Think of skills as \"expertise modules\" that agents can consult: Domain expertise : Coding standards, architectural patterns, security guidelines Workflow guidance : Step-by-step processes for complex tasks Reference material : API documentation, configuration schemas, examples Best practices : Industry standards, project conventions, quality guidelines Skills differ from static documentation in a key way: they're designed to be actively loaded into agent context when relevant, rather than passively referenced. Skill vs. Context File \u00b6 While both contain information, they serve different purposes: Aspect Context Files Skills Loading Always loaded at startup Loaded on-demand Scope Session-wide context Task-specific knowledge Size Should be concise Can be comprehensive Purpose Shape agent behavior Provide domain expertise Discovering Skills \u00b6 Before loading a skill, you need to know what's available. Amplifier provides discovery mechanisms through the load_skill tool. List All Available Skills \u00b6 load_skill ( list = True ) This returns all skills discovered from configured directories, including: - Workspace skills : .amplifier/skills/ in your project - User skills : ~/.amplifier/skills/ in your home directory - Collection skills : Skills bundled with Amplifier collections Search for Skills \u00b6 When you know roughly what you need but not the exact skill name: load_skill ( search = \"python\" ) This filters skills by name or description matching your search term. Get Skill Metadata \u00b6 Before loading a full skill (which consumes context), you can inspect its metadata: load_skill ( info = \"python-standards\" ) This returns the skill's name, description, version, and path without loading the full content. Loading Skills \u00b6 Once you've identified a relevant skill, load it to bring its knowledge into context. Basic Loading \u00b6 load_skill ( skill_name = \"design-patterns\" ) This loads the complete skill content into the agent's context. The skill becomes part of the agent's working knowledge for the remainder of the task. What Happens When You Load a Skill \u00b6 Content injection : The skill's markdown content is added to context Directory reference : You receive a skill_directory path for accessing companion files Immediate availability : The knowledge is immediately usable Accessing Companion Files \u00b6 Many skills include companion files - examples, templates, or reference implementations: # Load the skill first result = load_skill ( skill_name = \"api-testing\" ) # Access companion files using the returned directory read_file ( result . skill_directory + \"/examples/basic-test.py\" ) Creating Skills \u00b6 Skills are markdown files with a simple structure. Creating your own is straightforward. Skill File Structure \u00b6 --- name: my-custom-skill description: Brief description of what this skill provides version: 1.0.0 --- # Skill Title ## Overview What this skill covers and when to use it. ## Guidelines The actual domain knowledge, patterns, and practices. ## Examples Concrete examples demonstrating the concepts. ## References Links to additional resources or companion files. Where to Place Skills \u00b6 Skills are discovered from these locations (in priority order): Workspace : .amplifier/skills/your-skill.md - Project-specific skills User : ~/.amplifier/skills/your-skill.md - Personal skills across projects Collections : Skills bundled with installed collections First-match-wins: workspace skills override user skills with the same name. Skill Authoring Best Practices \u00b6 Be specific and actionable # Good: Actionable guidance When implementing retry logic: 1. Use exponential backoff starting at 100ms 2. Cap maximum retries at 5 3. Add jitter to prevent thundering herd # Avoid: Vague advice Retry logic should be implemented carefully. Include concrete examples ## Example: Rate Limiter Implementation ```python class RateLimiter: def __init__ (self, max_requests: int, window_seconds: int): self.max_requests = max_requests self.window = window_seconds self.requests = [] def allow(self) -> bool: now = time.time() self.requests = [t for t in self.requests if now - t < self.window] if len(self.requests) < self.max_requests: self.requests.append(now) return True return False **Reference companion files** ```markdown ## Templates See the companion files for ready-to-use templates: - `templates/api-client.py` - Base API client class - `templates/retry-decorator.py` - Retry decorator implementation Skill Naming Conventions \u00b6 Use lowercase with hyphens: python-standards , api-design Be descriptive but concise: react-testing not rt Group related skills with prefixes: aws-lambda , aws-s3 When to Use Skills \u00b6 Skills shine in specific scenarios: Use skills when: - You need specialized domain knowledge for a task - The knowledge is too large for always-on context files - Multiple agents might need the same expertise - You want to standardize approaches across a team Don't use skills when: - The information should always be available (use context files) - You need real-time information (use web search) - The task is simple and well-understood Skills vs. Other Knowledge Sources \u00b6 Source Best For Limitations Skills Domain expertise, patterns Static, must be loaded Context files Always-needed guidance Limited by context size Web search Current information Variable quality Documentation Reference lookup Not agent-optimized Key Takeaways \u00b6 Skills are loadable expertise - Domain knowledge packaged for agent consumption Discover before loading - Use list , search , and info to find the right skill without wasting context Load on-demand - Skills are task-specific; load them when needed, not preemptively Create your own - Project or personal skills are simple markdown files in known locations Include companions - Skills can reference example files, templates, and other resources Priority matters - Workspace skills override user skills; first match wins Be specific - Good skills provide actionable guidance and concrete examples, not vague advice Skills transform agents from general-purpose assistants into domain experts. By packaging knowledge effectively, you enable agents to tackle specialized tasks with the same expertise a human specialist would bring.","title":"Skills"},{"location":"concepts/skills.html#understanding-skills","text":"Skills are one of Amplifier's most powerful mechanisms for extending agent capabilities. They provide a way to package domain knowledge, best practices, and specialized workflows that agents can load on-demand.","title":"Understanding Skills"},{"location":"concepts/skills.html#what-is-a-skill","text":"A skill is loadable domain knowledge - a markdown file containing instructions, patterns, examples, and references that an agent can incorporate into its context when needed. Think of skills as \"expertise modules\" that agents can consult: Domain expertise : Coding standards, architectural patterns, security guidelines Workflow guidance : Step-by-step processes for complex tasks Reference material : API documentation, configuration schemas, examples Best practices : Industry standards, project conventions, quality guidelines Skills differ from static documentation in a key way: they're designed to be actively loaded into agent context when relevant, rather than passively referenced.","title":"What is a Skill?"},{"location":"concepts/skills.html#skill-vs-context-file","text":"While both contain information, they serve different purposes: Aspect Context Files Skills Loading Always loaded at startup Loaded on-demand Scope Session-wide context Task-specific knowledge Size Should be concise Can be comprehensive Purpose Shape agent behavior Provide domain expertise","title":"Skill vs. Context File"},{"location":"concepts/skills.html#discovering-skills","text":"Before loading a skill, you need to know what's available. Amplifier provides discovery mechanisms through the load_skill tool.","title":"Discovering Skills"},{"location":"concepts/skills.html#list-all-available-skills","text":"load_skill ( list = True ) This returns all skills discovered from configured directories, including: - Workspace skills : .amplifier/skills/ in your project - User skills : ~/.amplifier/skills/ in your home directory - Collection skills : Skills bundled with Amplifier collections","title":"List All Available Skills"},{"location":"concepts/skills.html#search-for-skills","text":"When you know roughly what you need but not the exact skill name: load_skill ( search = \"python\" ) This filters skills by name or description matching your search term.","title":"Search for Skills"},{"location":"concepts/skills.html#get-skill-metadata","text":"Before loading a full skill (which consumes context), you can inspect its metadata: load_skill ( info = \"python-standards\" ) This returns the skill's name, description, version, and path without loading the full content.","title":"Get Skill Metadata"},{"location":"concepts/skills.html#loading-skills","text":"Once you've identified a relevant skill, load it to bring its knowledge into context.","title":"Loading Skills"},{"location":"concepts/skills.html#basic-loading","text":"load_skill ( skill_name = \"design-patterns\" ) This loads the complete skill content into the agent's context. The skill becomes part of the agent's working knowledge for the remainder of the task.","title":"Basic Loading"},{"location":"concepts/skills.html#what-happens-when-you-load-a-skill","text":"Content injection : The skill's markdown content is added to context Directory reference : You receive a skill_directory path for accessing companion files Immediate availability : The knowledge is immediately usable","title":"What Happens When You Load a Skill"},{"location":"concepts/skills.html#accessing-companion-files","text":"Many skills include companion files - examples, templates, or reference implementations: # Load the skill first result = load_skill ( skill_name = \"api-testing\" ) # Access companion files using the returned directory read_file ( result . skill_directory + \"/examples/basic-test.py\" )","title":"Accessing Companion Files"},{"location":"concepts/skills.html#creating-skills","text":"Skills are markdown files with a simple structure. Creating your own is straightforward.","title":"Creating Skills"},{"location":"concepts/skills.html#skill-file-structure","text":"--- name: my-custom-skill description: Brief description of what this skill provides version: 1.0.0 --- # Skill Title ## Overview What this skill covers and when to use it. ## Guidelines The actual domain knowledge, patterns, and practices. ## Examples Concrete examples demonstrating the concepts. ## References Links to additional resources or companion files.","title":"Skill File Structure"},{"location":"concepts/skills.html#where-to-place-skills","text":"Skills are discovered from these locations (in priority order): Workspace : .amplifier/skills/your-skill.md - Project-specific skills User : ~/.amplifier/skills/your-skill.md - Personal skills across projects Collections : Skills bundled with installed collections First-match-wins: workspace skills override user skills with the same name.","title":"Where to Place Skills"},{"location":"concepts/skills.html#skill-authoring-best-practices","text":"Be specific and actionable # Good: Actionable guidance When implementing retry logic: 1. Use exponential backoff starting at 100ms 2. Cap maximum retries at 5 3. Add jitter to prevent thundering herd # Avoid: Vague advice Retry logic should be implemented carefully. Include concrete examples ## Example: Rate Limiter Implementation ```python class RateLimiter: def __init__ (self, max_requests: int, window_seconds: int): self.max_requests = max_requests self.window = window_seconds self.requests = [] def allow(self) -> bool: now = time.time() self.requests = [t for t in self.requests if now - t < self.window] if len(self.requests) < self.max_requests: self.requests.append(now) return True return False **Reference companion files** ```markdown ## Templates See the companion files for ready-to-use templates: - `templates/api-client.py` - Base API client class - `templates/retry-decorator.py` - Retry decorator implementation","title":"Skill Authoring Best Practices"},{"location":"concepts/skills.html#skill-naming-conventions","text":"Use lowercase with hyphens: python-standards , api-design Be descriptive but concise: react-testing not rt Group related skills with prefixes: aws-lambda , aws-s3","title":"Skill Naming Conventions"},{"location":"concepts/skills.html#when-to-use-skills","text":"Skills shine in specific scenarios: Use skills when: - You need specialized domain knowledge for a task - The knowledge is too large for always-on context files - Multiple agents might need the same expertise - You want to standardize approaches across a team Don't use skills when: - The information should always be available (use context files) - You need real-time information (use web search) - The task is simple and well-understood","title":"When to Use Skills"},{"location":"concepts/skills.html#skills-vs-other-knowledge-sources","text":"Source Best For Limitations Skills Domain expertise, patterns Static, must be loaded Context files Always-needed guidance Limited by context size Web search Current information Variable quality Documentation Reference lookup Not agent-optimized","title":"Skills vs. Other Knowledge Sources"},{"location":"concepts/skills.html#key-takeaways","text":"Skills are loadable expertise - Domain knowledge packaged for agent consumption Discover before loading - Use list , search , and info to find the right skill without wasting context Load on-demand - Skills are task-specific; load them when needed, not preemptively Create your own - Project or personal skills are simple markdown files in known locations Include companions - Skills can reference example files, templates, and other resources Priority matters - Workspace skills override user skills; first match wins Be specific - Good skills provide actionable guidance and concrete examples, not vague advice Skills transform agents from general-purpose assistants into domain experts. By packaging knowledge effectively, you enable agents to tackle specialized tasks with the same expertise a human specialist would bring.","title":"Key Takeaways"},{"location":"dev-setup/index.html","text":"Development Setup \u00b6 This section covers setting up a development environment for working on Amplifier itself or building applications that extend it. Follow these guides to configure a productive local setup. Whether you're contributing to the core project or building custom modules, proper setup ensures a smooth experience. Section Contents \u00b6 Page Description Environment Setup Python, dependencies, and tooling IDE Configuration VS Code, PyCharm, and editor setup Local Development Running Amplifier from source Testing Running and writing tests Debugging Debug techniques and tools Contributing How to contribute to Amplifier Code Style Conventions and formatting Release Process Versioning and publishing Quick Tips \u00b6 Use uv \u2014 It's faster than pip and handles dependencies better Virtual environments \u2014 Always isolate project dependencies Pre-commit hooks \u2014 Enable them to catch issues before commits Type checking \u2014 Run pyright/mypy regularly during development Test early \u2014 Write tests as you develop, not after System Requirements \u00b6 Requirement Version Notes Python 3.11+ 3.12 recommended uv or pip Latest uv preferred Git 2.30+ For version control Node.js 18+ For some tooling (optional) Quick Start \u00b6 # Clone the repository git clone https://github.com/microsoft/amplifier.git cd amplifier # Create virtual environment uv venv source .venv/bin/activate # or .venv\\Scripts\\activate on Windows # Install in development mode uv pip install -e \".[dev]\" # Run tests to verify setup pytest # Start development session amp --dev Where to Start \u00b6 Setting up for the first time? Follow Environment Setup for complete installation instructions. Contributing to Amplifier? Read Contributing for workflow and guidelines. Debugging issues? Check Debugging for techniques and common problems. Development Workflow \u00b6 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 Feature \u2502\u2500\u2500\u2500\u25ba\u2502 Tests \u2502\u2500\u2500\u2500\u25ba\u2502 PR \u2502 \u2502 Branch \u2502 \u2502 Passing \u2502 \u2502 Review \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u2502 \u2502 \u25bc \u25bc \u25bc Write Code Run pytest Address Feedback Type Check Check Coverage Merge to Main Recommended Tools \u00b6 Tool Purpose Install uv Package management pip install uv ruff Linting and formatting pip install ruff pyright Type checking pip install pyright pytest Testing Included in dev deps Common Tasks \u00b6 # Format code ruff format . # Check types pyright # Run specific tests pytest tests/test_sessions.py -v # Run with coverage pytest --cov = amplifier Related Sections \u00b6 Quickstart: Installation Advanced: Custom Tools Concepts: Module System","title":"Overview"},{"location":"dev-setup/index.html#development-setup","text":"This section covers setting up a development environment for working on Amplifier itself or building applications that extend it. Follow these guides to configure a productive local setup. Whether you're contributing to the core project or building custom modules, proper setup ensures a smooth experience.","title":"Development Setup"},{"location":"dev-setup/index.html#section-contents","text":"Page Description Environment Setup Python, dependencies, and tooling IDE Configuration VS Code, PyCharm, and editor setup Local Development Running Amplifier from source Testing Running and writing tests Debugging Debug techniques and tools Contributing How to contribute to Amplifier Code Style Conventions and formatting Release Process Versioning and publishing","title":"Section Contents"},{"location":"dev-setup/index.html#quick-tips","text":"Use uv \u2014 It's faster than pip and handles dependencies better Virtual environments \u2014 Always isolate project dependencies Pre-commit hooks \u2014 Enable them to catch issues before commits Type checking \u2014 Run pyright/mypy regularly during development Test early \u2014 Write tests as you develop, not after","title":"Quick Tips"},{"location":"dev-setup/index.html#system-requirements","text":"Requirement Version Notes Python 3.11+ 3.12 recommended uv or pip Latest uv preferred Git 2.30+ For version control Node.js 18+ For some tooling (optional)","title":"System Requirements"},{"location":"dev-setup/index.html#quick-start","text":"# Clone the repository git clone https://github.com/microsoft/amplifier.git cd amplifier # Create virtual environment uv venv source .venv/bin/activate # or .venv\\Scripts\\activate on Windows # Install in development mode uv pip install -e \".[dev]\" # Run tests to verify setup pytest # Start development session amp --dev","title":"Quick Start"},{"location":"dev-setup/index.html#where-to-start","text":"Setting up for the first time? Follow Environment Setup for complete installation instructions. Contributing to Amplifier? Read Contributing for workflow and guidelines. Debugging issues? Check Debugging for techniques and common problems.","title":"Where to Start"},{"location":"dev-setup/index.html#development-workflow","text":"\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 Feature \u2502\u2500\u2500\u2500\u25ba\u2502 Tests \u2502\u2500\u2500\u2500\u25ba\u2502 PR \u2502 \u2502 Branch \u2502 \u2502 Passing \u2502 \u2502 Review \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u2502 \u2502 \u25bc \u25bc \u25bc Write Code Run pytest Address Feedback Type Check Check Coverage Merge to Main","title":"Development Workflow"},{"location":"dev-setup/index.html#recommended-tools","text":"Tool Purpose Install uv Package management pip install uv ruff Linting and formatting pip install ruff pyright Type checking pip install pyright pytest Testing Included in dev deps","title":"Recommended Tools"},{"location":"dev-setup/index.html#common-tasks","text":"# Format code ruff format . # Check types pyright # Run specific tests pytest tests/test_sessions.py -v # Run with coverage pytest --cov = amplifier","title":"Common Tasks"},{"location":"dev-setup/index.html#related-sections","text":"Quickstart: Installation Advanced: Custom Tools Concepts: Module System","title":"Related Sections"},{"location":"dev-setup/cli-tools.html","text":"CLI Tools \u00b6 Useful command-line tools for Amplifier development. Overview \u00b6 These tools enhance your Amplifier development workflow: Tool Purpose amp Main Amplifier CLI uv Fast Python package manager jq JSON processor fzf Fuzzy finder bat Better cat ripgrep Fast search amp (Amplifier CLI) \u00b6 Installation \u00b6 # Via uv (recommended) uv tool install amplifier # Verify amp --version Key Commands \u00b6 # Start interactive session amp # Run single prompt amp run \"explain this code\" # Use specific bundle amp --bundle recipes # List sessions amp session list # Resume session amp session resume [ id ] Bundle Management \u00b6 # Add a bundle amp bundle add git+https://github.com/microsoft/amplifier-bundle-recipes@main # List bundles amp bundle list # Use a bundle amp bundle use recipes # Remove a bundle amp bundle remove recipes Recipe Commands \u00b6 # Run recipe amp recipes execute recipe.yaml --context '{}' # List sessions amp recipes list # Resume recipe amp recipes resume [ session-id ] # Validate recipe amp recipes validate recipe.yaml uv (Python Package Manager) \u00b6 Fast, modern Python package management. Installation \u00b6 curl -LsSf https://astral.sh/uv/install.sh | sh Key Commands \u00b6 # Create virtual environment uv venv # Install packages uv pip install requests # Install from requirements uv pip install -r requirements.txt # Install tool globally uv tool install ruff Why uv? \u00b6 10-100x faster than pip Automatic venv detection Lockfile support Tool management jq (JSON Processor) \u00b6 Query and manipulate JSON from the command line. Installation \u00b6 # macOS brew install jq # Ubuntu/Debian sudo apt install jq # Windows winget install jqlang.jq Common Uses \u00b6 # Pretty print JSON curl https://api.example.com/users | jq . # Extract field cat data.json | jq '.name' # Filter array cat users.json | jq '.[] | select(.active == true)' # Count items cat items.json | jq 'length' # Transform data cat users.json | jq '{count: length, names: [.[].name]}' With Amplifier Logs \u00b6 # Parse session events cat events.jsonl | jq 'select(.event_type == \"tool:call\")' # Get tool names used cat events.jsonl | jq -r 'select(.event_type == \"tool:call\") | .tool_name' fzf (Fuzzy Finder) \u00b6 Interactive fuzzy search for anything. Installation \u00b6 # macOS brew install fzf # Ubuntu/Debian sudo apt install fzf # Setup shell integration $( brew --prefix ) /opt/fzf/install Common Uses \u00b6 # Find and open file vim $( fzf ) # Search command history history | fzf # Git branch checkout git checkout $( git branch | fzf ) # Find session amp session resume $( amp session list | fzf | awk '{print $1}' ) With Amplifier \u00b6 # Find recipe to run amp recipes execute $( find recipes -name \"*.yaml\" | fzf ) # Resume session interactively amp session list | fzf | xargs amp session resume bat (Better cat) \u00b6 Syntax-highlighted file viewer. Installation \u00b6 # macOS brew install bat # Ubuntu/Debian sudo apt install bat # Note: on Ubuntu, the command is 'batcat' Common Uses \u00b6 # View file with syntax highlighting bat config.yaml # Show line numbers bat -n script.py # Show specific lines bat --line-range 10 :20 app.py # Compare files bat --diff file1.py file2.py ripgrep (rg) \u00b6 Faster grep with smart defaults. Installation \u00b6 # macOS brew install ripgrep # Ubuntu/Debian sudo apt install ripgrep Common Uses \u00b6 # Search for pattern rg \"TODO\" # Search specific file type rg \"function\" --type js # Show context rg \"error\" -C 3 # Ignore case rg -i \"config\" # List files only rg -l \"import pandas\" vs Amplifier grep \u00b6 Amplifier's built-in grep uses ripgrep when available, with added features like output limits and smart exclusions. Use rg directly when you need full control. Shell Aliases \u00b6 Add to your ~/.bashrc or ~/.zshrc : # Amplifier shortcuts alias a = 'amp' alias ar = 'amp run' alias as = 'amp session' alias ab = 'amp bundle' # Development alias py = 'python3' alias pip = 'uv pip' # Navigation alias .. = 'cd ..' alias ... = 'cd ../..' # Git alias gs = 'git status' alias gd = 'git diff' alias gc = 'git commit' alias gp = 'git push' Try It Yourself \u00b6 Exercise 1: Install Tools \u00b6 # Install the essentials uv tool install amplifier brew install jq fzf bat ripgrep # or apt equivalent Exercise 2: Explore Session Logs \u00b6 # Find latest session ls -t ~/.amplifier/sessions/ | head -1 # Parse events cat ~/.amplifier/sessions/ [ id ] /events.jsonl | jq '.event_type' | sort | uniq -c Exercise 3: Fuzzy Find \u00b6 # Install fzf if needed brew install fzf # Use it vim $( fzf ) Next \u00b6 Set up your development environment: \u2192 Shadow Workspace","title":"CLI Tools"},{"location":"dev-setup/cli-tools.html#cli-tools","text":"Useful command-line tools for Amplifier development.","title":"CLI Tools"},{"location":"dev-setup/cli-tools.html#overview","text":"These tools enhance your Amplifier development workflow: Tool Purpose amp Main Amplifier CLI uv Fast Python package manager jq JSON processor fzf Fuzzy finder bat Better cat ripgrep Fast search","title":"Overview"},{"location":"dev-setup/cli-tools.html#amp-amplifier-cli","text":"","title":"amp (Amplifier CLI)"},{"location":"dev-setup/cli-tools.html#installation","text":"# Via uv (recommended) uv tool install amplifier # Verify amp --version","title":"Installation"},{"location":"dev-setup/cli-tools.html#key-commands","text":"# Start interactive session amp # Run single prompt amp run \"explain this code\" # Use specific bundle amp --bundle recipes # List sessions amp session list # Resume session amp session resume [ id ]","title":"Key Commands"},{"location":"dev-setup/cli-tools.html#bundle-management","text":"# Add a bundle amp bundle add git+https://github.com/microsoft/amplifier-bundle-recipes@main # List bundles amp bundle list # Use a bundle amp bundle use recipes # Remove a bundle amp bundle remove recipes","title":"Bundle Management"},{"location":"dev-setup/cli-tools.html#recipe-commands","text":"# Run recipe amp recipes execute recipe.yaml --context '{}' # List sessions amp recipes list # Resume recipe amp recipes resume [ session-id ] # Validate recipe amp recipes validate recipe.yaml","title":"Recipe Commands"},{"location":"dev-setup/cli-tools.html#uv-python-package-manager","text":"Fast, modern Python package management.","title":"uv (Python Package Manager)"},{"location":"dev-setup/cli-tools.html#installation_1","text":"curl -LsSf https://astral.sh/uv/install.sh | sh","title":"Installation"},{"location":"dev-setup/cli-tools.html#key-commands_1","text":"# Create virtual environment uv venv # Install packages uv pip install requests # Install from requirements uv pip install -r requirements.txt # Install tool globally uv tool install ruff","title":"Key Commands"},{"location":"dev-setup/cli-tools.html#why-uv","text":"10-100x faster than pip Automatic venv detection Lockfile support Tool management","title":"Why uv?"},{"location":"dev-setup/cli-tools.html#jq-json-processor","text":"Query and manipulate JSON from the command line.","title":"jq (JSON Processor)"},{"location":"dev-setup/cli-tools.html#installation_2","text":"# macOS brew install jq # Ubuntu/Debian sudo apt install jq # Windows winget install jqlang.jq","title":"Installation"},{"location":"dev-setup/cli-tools.html#common-uses","text":"# Pretty print JSON curl https://api.example.com/users | jq . # Extract field cat data.json | jq '.name' # Filter array cat users.json | jq '.[] | select(.active == true)' # Count items cat items.json | jq 'length' # Transform data cat users.json | jq '{count: length, names: [.[].name]}'","title":"Common Uses"},{"location":"dev-setup/cli-tools.html#with-amplifier-logs","text":"# Parse session events cat events.jsonl | jq 'select(.event_type == \"tool:call\")' # Get tool names used cat events.jsonl | jq -r 'select(.event_type == \"tool:call\") | .tool_name'","title":"With Amplifier Logs"},{"location":"dev-setup/cli-tools.html#fzf-fuzzy-finder","text":"Interactive fuzzy search for anything.","title":"fzf (Fuzzy Finder)"},{"location":"dev-setup/cli-tools.html#installation_3","text":"# macOS brew install fzf # Ubuntu/Debian sudo apt install fzf # Setup shell integration $( brew --prefix ) /opt/fzf/install","title":"Installation"},{"location":"dev-setup/cli-tools.html#common-uses_1","text":"# Find and open file vim $( fzf ) # Search command history history | fzf # Git branch checkout git checkout $( git branch | fzf ) # Find session amp session resume $( amp session list | fzf | awk '{print $1}' )","title":"Common Uses"},{"location":"dev-setup/cli-tools.html#with-amplifier","text":"# Find recipe to run amp recipes execute $( find recipes -name \"*.yaml\" | fzf ) # Resume session interactively amp session list | fzf | xargs amp session resume","title":"With Amplifier"},{"location":"dev-setup/cli-tools.html#bat-better-cat","text":"Syntax-highlighted file viewer.","title":"bat (Better cat)"},{"location":"dev-setup/cli-tools.html#installation_4","text":"# macOS brew install bat # Ubuntu/Debian sudo apt install bat # Note: on Ubuntu, the command is 'batcat'","title":"Installation"},{"location":"dev-setup/cli-tools.html#common-uses_2","text":"# View file with syntax highlighting bat config.yaml # Show line numbers bat -n script.py # Show specific lines bat --line-range 10 :20 app.py # Compare files bat --diff file1.py file2.py","title":"Common Uses"},{"location":"dev-setup/cli-tools.html#ripgrep-rg","text":"Faster grep with smart defaults.","title":"ripgrep (rg)"},{"location":"dev-setup/cli-tools.html#installation_5","text":"# macOS brew install ripgrep # Ubuntu/Debian sudo apt install ripgrep","title":"Installation"},{"location":"dev-setup/cli-tools.html#common-uses_3","text":"# Search for pattern rg \"TODO\" # Search specific file type rg \"function\" --type js # Show context rg \"error\" -C 3 # Ignore case rg -i \"config\" # List files only rg -l \"import pandas\"","title":"Common Uses"},{"location":"dev-setup/cli-tools.html#vs-amplifier-grep","text":"Amplifier's built-in grep uses ripgrep when available, with added features like output limits and smart exclusions. Use rg directly when you need full control.","title":"vs Amplifier grep"},{"location":"dev-setup/cli-tools.html#shell-aliases","text":"Add to your ~/.bashrc or ~/.zshrc : # Amplifier shortcuts alias a = 'amp' alias ar = 'amp run' alias as = 'amp session' alias ab = 'amp bundle' # Development alias py = 'python3' alias pip = 'uv pip' # Navigation alias .. = 'cd ..' alias ... = 'cd ../..' # Git alias gs = 'git status' alias gd = 'git diff' alias gc = 'git commit' alias gp = 'git push'","title":"Shell Aliases"},{"location":"dev-setup/cli-tools.html#try-it-yourself","text":"","title":"Try It Yourself"},{"location":"dev-setup/cli-tools.html#exercise-1-install-tools","text":"# Install the essentials uv tool install amplifier brew install jq fzf bat ripgrep # or apt equivalent","title":"Exercise 1: Install Tools"},{"location":"dev-setup/cli-tools.html#exercise-2-explore-session-logs","text":"# Find latest session ls -t ~/.amplifier/sessions/ | head -1 # Parse events cat ~/.amplifier/sessions/ [ id ] /events.jsonl | jq '.event_type' | sort | uniq -c","title":"Exercise 2: Explore Session Logs"},{"location":"dev-setup/cli-tools.html#exercise-3-fuzzy-find","text":"# Install fzf if needed brew install fzf # Use it vim $( fzf )","title":"Exercise 3: Fuzzy Find"},{"location":"dev-setup/cli-tools.html#next","text":"Set up your development environment: \u2192 Shadow Workspace","title":"Next"},{"location":"dev-setup/debugging.html","text":"Debugging \u00b6 Troubleshoot issues with Amplifier and your AI-assisted workflows. Overview \u00b6 Debugging approaches: Issue Type Where to Look Session errors events.jsonl Tool failures Tool output, logs Provider issues API errors, model limits Recipe problems Step results, context Bundle issues Bundle validation Session Analysis \u00b6 Find Your Session \u00b6 # List recent sessions ls -lt ~/.amplifier/sessions/ | head -10 # Or in Amplifier amp session list Read Session Events \u00b6 Sessions are logged to events.jsonl : cd ~/.amplifier/sessions/ [ session-id ] # View all events cat events.jsonl | jq . # Filter by event type cat events.jsonl | jq 'select(.event_type == \"tool:call\")' # See errors cat events.jsonl | jq 'select(.event_type | contains(\"error\"))' Common Event Types \u00b6 Event Meaning session:start Session began turn:start User message received provider:request API call to LLM provider:response LLM response tool:call Tool invoked tool:result Tool returned turn:end Response complete session:end Session ended Session Analyst Agent \u00b6 For complex issues, use the specialist: > Analyze why session [id] failed The session-analyst agent safely handles large event logs. Tool Debugging \u00b6 See Tool Calls \u00b6 # In session, see what tools were called cat events.jsonl | jq -r 'select(.event_type == \"tool:call\") | .tool_name' Tool Errors \u00b6 # Find tool errors cat events.jsonl | jq 'select(.event_type == \"tool:result\" and .error != null)' Common Tool Issues \u00b6 bash timeout: # Command took too long # Solution: Use explicit timeout timeout 120 long_command File not found: # Check path ls -la [ path ] # Check working directory pwd Permission denied: # Check permissions ls -la [ file ] chmod +x [ script ] Provider Debugging \u00b6 API Errors \u00b6 # Find provider errors cat events.jsonl | jq 'select(.event_type == \"provider:response\" and .error != null)' Common Provider Issues \u00b6 Rate limiting: Error: 429 Too Many Requests Wait and retry Check your API plan limits Consider using a different model Token limits: Error: Context length exceeded Conversation too long Start new session Use smaller context Invalid API key: Error: 401 Unauthorized Check ANTHROPIC_API_KEY is set Verify key is valid Check for typos Test Provider Connection \u00b6 # Anthropic curl https://api.anthropic.com/v1/messages \\ -H \"x-api-key: $ANTHROPIC_API_KEY \" \\ -H \"content-type: application/json\" \\ -H \"anthropic-version: 2023-06-01\" \\ -d '{\"model\": \"claude-sonnet-4-20250514\", \"max_tokens\": 10, \"messages\": [{\"role\": \"user\", \"content\": \"Hi\"}]}' Recipe Debugging \u00b6 Validate Recipe \u00b6 amp recipes validate my-recipe.yaml Check Recipe Session \u00b6 # List recipe sessions amp recipes list # View recipe session events cat ~/.amplifier/sessions/recipe_ [ id ] /events.jsonl | jq . Step Results \u00b6 # See what each step returned cat events.jsonl | jq 'select(.event_type == \"step:complete\")' Common Recipe Issues \u00b6 Context variable missing: Error: Required context variable 'file_path' not provided Add --context '{\"file_path\": \"...\"}' Step failed: - Check the step's agent - Review the instruction - Look at step result in events Bundle Debugging \u00b6 Validate Bundle \u00b6 amp bundle validate ./my-bundle Check What's Loaded \u00b6 > What bundle am I using? > What tools do you have? > What agents are available? Bundle Load Errors \u00b6 Check for: - Missing bundle.yaml - Invalid YAML syntax - Missing included bundles - Invalid module references Verbose Mode \u00b6 Get more output: # Set debug logging export AMPLIFIER_LOG_LEVEL = debug # Run Amplifier amp Log Locations \u00b6 Log Location Session events ~/.amplifier/sessions/[id]/events.jsonl Application logs ~/.amplifier/logs/ Recipe sessions ~/.amplifier/sessions/recipe_[id]/ Debugging Workflow \u00b6 Step 1: Reproduce \u00b6 # Note the session ID amp session list | head -1 Step 2: Find Events \u00b6 cd ~/.amplifier/sessions/ [ id ] cat events.jsonl | jq '.event_type' | sort | uniq -c Step 3: Locate Error \u00b6 # Find errors cat events.jsonl | jq 'select(.error != null)' # Find last event before error cat events.jsonl | tail -20 | jq . Step 4: Understand Context \u00b6 # See what led to error cat events.jsonl | jq 'select(.event_type == \"turn:start\" or .event_type == \"tool:call\")' | tail -10 Step 5: Fix and Retry \u00b6 Based on findings: - Fix configuration - Adjust prompts - Retry operation Try It Yourself \u00b6 Exercise 1: Explore Session \u00b6 # Find latest session SESSION = $( ls -t ~/.amplifier/sessions/ | head -1 ) # Count event types cat ~/.amplifier/sessions/ $SESSION /events.jsonl | jq '.event_type' | sort | uniq -c Exercise 2: Find Tool Calls \u00b6 # What tools were used? cat ~/.amplifier/sessions/ $SESSION /events.jsonl | \\ jq -r 'select(.event_type == \"tool:call\") | .tool_name' | \\ sort | uniq -c | sort -rn Exercise 3: Debug an Error \u00b6 Intentionally cause an error: > Read the file /nonexistent/path/file.txt Then find it in logs: cat events.jsonl | jq 'select(.error != null)' Getting Help \u00b6 If stuck: Search the error - Often others have hit it Check GitHub Issues - Known problems and solutions Ask Amplifier - \"Why did this fail?\" Session analyst - \"Analyze session [id]\"","title":"Debugging"},{"location":"dev-setup/debugging.html#debugging","text":"Troubleshoot issues with Amplifier and your AI-assisted workflows.","title":"Debugging"},{"location":"dev-setup/debugging.html#overview","text":"Debugging approaches: Issue Type Where to Look Session errors events.jsonl Tool failures Tool output, logs Provider issues API errors, model limits Recipe problems Step results, context Bundle issues Bundle validation","title":"Overview"},{"location":"dev-setup/debugging.html#session-analysis","text":"","title":"Session Analysis"},{"location":"dev-setup/debugging.html#find-your-session","text":"# List recent sessions ls -lt ~/.amplifier/sessions/ | head -10 # Or in Amplifier amp session list","title":"Find Your Session"},{"location":"dev-setup/debugging.html#read-session-events","text":"Sessions are logged to events.jsonl : cd ~/.amplifier/sessions/ [ session-id ] # View all events cat events.jsonl | jq . # Filter by event type cat events.jsonl | jq 'select(.event_type == \"tool:call\")' # See errors cat events.jsonl | jq 'select(.event_type | contains(\"error\"))'","title":"Read Session Events"},{"location":"dev-setup/debugging.html#common-event-types","text":"Event Meaning session:start Session began turn:start User message received provider:request API call to LLM provider:response LLM response tool:call Tool invoked tool:result Tool returned turn:end Response complete session:end Session ended","title":"Common Event Types"},{"location":"dev-setup/debugging.html#session-analyst-agent","text":"For complex issues, use the specialist: > Analyze why session [id] failed The session-analyst agent safely handles large event logs.","title":"Session Analyst Agent"},{"location":"dev-setup/debugging.html#tool-debugging","text":"","title":"Tool Debugging"},{"location":"dev-setup/debugging.html#see-tool-calls","text":"# In session, see what tools were called cat events.jsonl | jq -r 'select(.event_type == \"tool:call\") | .tool_name'","title":"See Tool Calls"},{"location":"dev-setup/debugging.html#tool-errors","text":"# Find tool errors cat events.jsonl | jq 'select(.event_type == \"tool:result\" and .error != null)'","title":"Tool Errors"},{"location":"dev-setup/debugging.html#common-tool-issues","text":"bash timeout: # Command took too long # Solution: Use explicit timeout timeout 120 long_command File not found: # Check path ls -la [ path ] # Check working directory pwd Permission denied: # Check permissions ls -la [ file ] chmod +x [ script ]","title":"Common Tool Issues"},{"location":"dev-setup/debugging.html#provider-debugging","text":"","title":"Provider Debugging"},{"location":"dev-setup/debugging.html#api-errors","text":"# Find provider errors cat events.jsonl | jq 'select(.event_type == \"provider:response\" and .error != null)'","title":"API Errors"},{"location":"dev-setup/debugging.html#common-provider-issues","text":"Rate limiting: Error: 429 Too Many Requests Wait and retry Check your API plan limits Consider using a different model Token limits: Error: Context length exceeded Conversation too long Start new session Use smaller context Invalid API key: Error: 401 Unauthorized Check ANTHROPIC_API_KEY is set Verify key is valid Check for typos","title":"Common Provider Issues"},{"location":"dev-setup/debugging.html#test-provider-connection","text":"# Anthropic curl https://api.anthropic.com/v1/messages \\ -H \"x-api-key: $ANTHROPIC_API_KEY \" \\ -H \"content-type: application/json\" \\ -H \"anthropic-version: 2023-06-01\" \\ -d '{\"model\": \"claude-sonnet-4-20250514\", \"max_tokens\": 10, \"messages\": [{\"role\": \"user\", \"content\": \"Hi\"}]}'","title":"Test Provider Connection"},{"location":"dev-setup/debugging.html#recipe-debugging","text":"","title":"Recipe Debugging"},{"location":"dev-setup/debugging.html#validate-recipe","text":"amp recipes validate my-recipe.yaml","title":"Validate Recipe"},{"location":"dev-setup/debugging.html#check-recipe-session","text":"# List recipe sessions amp recipes list # View recipe session events cat ~/.amplifier/sessions/recipe_ [ id ] /events.jsonl | jq .","title":"Check Recipe Session"},{"location":"dev-setup/debugging.html#step-results","text":"# See what each step returned cat events.jsonl | jq 'select(.event_type == \"step:complete\")'","title":"Step Results"},{"location":"dev-setup/debugging.html#common-recipe-issues","text":"Context variable missing: Error: Required context variable 'file_path' not provided Add --context '{\"file_path\": \"...\"}' Step failed: - Check the step's agent - Review the instruction - Look at step result in events","title":"Common Recipe Issues"},{"location":"dev-setup/debugging.html#bundle-debugging","text":"","title":"Bundle Debugging"},{"location":"dev-setup/debugging.html#validate-bundle","text":"amp bundle validate ./my-bundle","title":"Validate Bundle"},{"location":"dev-setup/debugging.html#check-whats-loaded","text":"> What bundle am I using? > What tools do you have? > What agents are available?","title":"Check What's Loaded"},{"location":"dev-setup/debugging.html#bundle-load-errors","text":"Check for: - Missing bundle.yaml - Invalid YAML syntax - Missing included bundles - Invalid module references","title":"Bundle Load Errors"},{"location":"dev-setup/debugging.html#verbose-mode","text":"Get more output: # Set debug logging export AMPLIFIER_LOG_LEVEL = debug # Run Amplifier amp","title":"Verbose Mode"},{"location":"dev-setup/debugging.html#log-locations","text":"Log Location Session events ~/.amplifier/sessions/[id]/events.jsonl Application logs ~/.amplifier/logs/ Recipe sessions ~/.amplifier/sessions/recipe_[id]/","title":"Log Locations"},{"location":"dev-setup/debugging.html#debugging-workflow","text":"","title":"Debugging Workflow"},{"location":"dev-setup/debugging.html#step-1-reproduce","text":"# Note the session ID amp session list | head -1","title":"Step 1: Reproduce"},{"location":"dev-setup/debugging.html#step-2-find-events","text":"cd ~/.amplifier/sessions/ [ id ] cat events.jsonl | jq '.event_type' | sort | uniq -c","title":"Step 2: Find Events"},{"location":"dev-setup/debugging.html#step-3-locate-error","text":"# Find errors cat events.jsonl | jq 'select(.error != null)' # Find last event before error cat events.jsonl | tail -20 | jq .","title":"Step 3: Locate Error"},{"location":"dev-setup/debugging.html#step-4-understand-context","text":"# See what led to error cat events.jsonl | jq 'select(.event_type == \"turn:start\" or .event_type == \"tool:call\")' | tail -10","title":"Step 4: Understand Context"},{"location":"dev-setup/debugging.html#step-5-fix-and-retry","text":"Based on findings: - Fix configuration - Adjust prompts - Retry operation","title":"Step 5: Fix and Retry"},{"location":"dev-setup/debugging.html#try-it-yourself","text":"","title":"Try It Yourself"},{"location":"dev-setup/debugging.html#exercise-1-explore-session","text":"# Find latest session SESSION = $( ls -t ~/.amplifier/sessions/ | head -1 ) # Count event types cat ~/.amplifier/sessions/ $SESSION /events.jsonl | jq '.event_type' | sort | uniq -c","title":"Exercise 1: Explore Session"},{"location":"dev-setup/debugging.html#exercise-2-find-tool-calls","text":"# What tools were used? cat ~/.amplifier/sessions/ $SESSION /events.jsonl | \\ jq -r 'select(.event_type == \"tool:call\") | .tool_name' | \\ sort | uniq -c | sort -rn","title":"Exercise 2: Find Tool Calls"},{"location":"dev-setup/debugging.html#exercise-3-debug-an-error","text":"Intentionally cause an error: > Read the file /nonexistent/path/file.txt Then find it in logs: cat events.jsonl | jq 'select(.error != null)'","title":"Exercise 3: Debug an Error"},{"location":"dev-setup/debugging.html#getting-help","text":"If stuck: Search the error - Often others have hit it Check GitHub Issues - Known problems and solutions Ask Amplifier - \"Why did this fail?\" Session analyst - \"Analyze session [id]\"","title":"Getting Help"},{"location":"dev-setup/remote-dev.html","text":"Remote Development \u00b6 Run Amplifier on remote machines, containers, and cloud environments. Overview \u00b6 Remote development options: Method Best For SSH Remote servers, VMs VS Code Remote Seamless IDE experience Docker Isolated environments GitHub Codespaces Cloud development WSL Windows + Linux SSH \u00b6 Run Amplifier on a remote server. Setup \u00b6 # SSH to your server ssh user@remote-server # Install Amplifier curl -LsSf https://astral.sh/uv/install.sh | sh uv tool install amplifier # Configure provider (on remote) export ANTHROPIC_API_KEY = \"your-key\" # Run amp Port Forwarding \u00b6 For web UIs or local services: ssh -L 8080 :localhost:8080 user@remote-server Persistent Sessions \u00b6 Use tmux to keep sessions alive: # Start tmux ssh user@remote-server tmux new -s amplifier # Run Amplifier amp # Detach: Ctrl+b, then d # Reconnect later ssh user@remote-server tmux attach -t amplifier VS Code Remote \u00b6 Use VS Code's Remote extensions for seamless experience. Remote - SSH \u00b6 # Install extension code --install-extension ms-vscode-remote.remote-ssh # Connect # Ctrl+Shift+P \u2192 \"Remote-SSH: Connect to Host\" # Open terminal in VS Code # Run Amplifier normally amp Remote - Containers \u00b6 # Install extension code --install-extension ms-vscode-remote.remote-containers # Create devcontainer config mkdir .devcontainer .devcontainer/devcontainer.json : { \"name\" : \"Amplifier Dev\" , \"image\" : \"python:3.12\" , \"postCreateCommand\" : \"curl -LsSf https://astral.sh/uv/install.sh | sh && uv tool install amplifier\" , \"remoteEnv\" : { \"ANTHROPIC_API_KEY\" : \"${localEnv:ANTHROPIC_API_KEY}\" } } Docker \u00b6 Run Amplifier in a container. Basic Usage \u00b6 # Run interactive container docker run -it --rm \\ -v $( pwd ) :/workspace \\ -w /workspace \\ -e ANTHROPIC_API_KEY = \" $ANTHROPIC_API_KEY \" \\ python:3.12 bash # Inside container curl -LsSf https://astral.sh/uv/install.sh | sh source ~/.cargo/env uv tool install amplifier amp Dockerfile \u00b6 FROM python:3.12-slim # Install uv RUN curl -LsSf https://astral.sh/uv/install.sh | sh # Add uv to PATH ENV PATH = \"/root/.cargo/bin: $PATH \" # Install Amplifier RUN uv tool install amplifier WORKDIR /workspace CMD [ \"amp\" ] Build and run: docker build -t amplifier-dev . docker run -it --rm \\ -v $( pwd ) :/workspace \\ -e ANTHROPIC_API_KEY \\ amplifier-dev Docker Compose \u00b6 version : '3.8' services : amplifier : build : . volumes : - .:/workspace environment : - ANTHROPIC_API_KEY stdin_open : true tty : true docker compose run amplifier GitHub Codespaces \u00b6 Cloud-hosted development environment. Setup \u00b6 Create .devcontainer/devcontainer.json in your repo: { \"name\" : \"Amplifier Workspace\" , \"image\" : \"mcr.microsoft.com/devcontainers/python:3.12\" , \"postCreateCommand\" : \"curl -LsSf https://astral.sh/uv/install.sh | sh && source ~/.cargo/env && uv tool install amplifier\" , \"secrets\" : { \"ANTHROPIC_API_KEY\" : { \"description\" : \"API key for Anthropic Claude\" } }, \"customizations\" : { \"vscode\" : { \"extensions\" : [ \"ms-python.python\" ] } } } Set secret in GitHub repo settings: Settings \u2192 Secrets \u2192 Codespaces Add ANTHROPIC_API_KEY Create Codespace: Code \u2192 Codespaces \u2192 Create on main In terminal: amp WSL (Windows Subsystem for Linux) \u00b6 Run Amplifier in Linux on Windows. Setup \u00b6 # Install WSL (PowerShell Admin) wsl - -install -d Ubuntu # Start WSL wsl In WSL: # Install uv curl -LsSf https://astral.sh/uv/install.sh | sh source ~/.cargo/env # Install Amplifier uv tool install amplifier # Configure export ANTHROPIC_API_KEY = \"your-key\" echo 'export ANTHROPIC_API_KEY=\"your-key\"' >> ~/.bashrc # Run amp Access Windows Files \u00b6 # Windows drives are mounted at /mnt cd /mnt/c/Users/YourName/Projects # Run Amplifier on Windows project amp VS Code + WSL \u00b6 # From WSL cd /mnt/c/YourProject code . # Opens VS Code connected to WSL Environment Variables \u00b6 Securely handle API keys: Local .env File \u00b6 # .env (gitignored!) ANTHROPIC_API_KEY = sk-ant-... OPENAI_API_KEY = sk-... # Load before running source .env amp direnv \u00b6 Auto-load environment per directory: # Install brew install direnv # Setup echo 'eval \"$(direnv hook bash)\"' >> ~/.bashrc # Create .envrc echo 'export ANTHROPIC_API_KEY=\"sk-ant-...\"' > .envrc direnv allow # Now auto-loads when you cd into directory Try It Yourself \u00b6 Exercise 1: Docker \u00b6 docker run -it --rm \\ -v $( pwd ) :/workspace \\ -e ANTHROPIC_API_KEY \\ python:3.12 bash -c \" curl -LsSf https://astral.sh/uv/install.sh | sh && source ~/.cargo/env && uv tool install amplifier && amp \" Exercise 2: tmux \u00b6 # Start tmux tmux new -s dev # Run Amplifier amp # Detach: Ctrl+b, d # Reattach: tmux attach -t dev Next \u00b6 Learn debugging techniques: \u2192 Debugging","title":"Remote Development"},{"location":"dev-setup/remote-dev.html#remote-development","text":"Run Amplifier on remote machines, containers, and cloud environments.","title":"Remote Development"},{"location":"dev-setup/remote-dev.html#overview","text":"Remote development options: Method Best For SSH Remote servers, VMs VS Code Remote Seamless IDE experience Docker Isolated environments GitHub Codespaces Cloud development WSL Windows + Linux","title":"Overview"},{"location":"dev-setup/remote-dev.html#ssh","text":"Run Amplifier on a remote server.","title":"SSH"},{"location":"dev-setup/remote-dev.html#setup","text":"# SSH to your server ssh user@remote-server # Install Amplifier curl -LsSf https://astral.sh/uv/install.sh | sh uv tool install amplifier # Configure provider (on remote) export ANTHROPIC_API_KEY = \"your-key\" # Run amp","title":"Setup"},{"location":"dev-setup/remote-dev.html#port-forwarding","text":"For web UIs or local services: ssh -L 8080 :localhost:8080 user@remote-server","title":"Port Forwarding"},{"location":"dev-setup/remote-dev.html#persistent-sessions","text":"Use tmux to keep sessions alive: # Start tmux ssh user@remote-server tmux new -s amplifier # Run Amplifier amp # Detach: Ctrl+b, then d # Reconnect later ssh user@remote-server tmux attach -t amplifier","title":"Persistent Sessions"},{"location":"dev-setup/remote-dev.html#vs-code-remote","text":"Use VS Code's Remote extensions for seamless experience.","title":"VS Code Remote"},{"location":"dev-setup/remote-dev.html#remote-ssh","text":"# Install extension code --install-extension ms-vscode-remote.remote-ssh # Connect # Ctrl+Shift+P \u2192 \"Remote-SSH: Connect to Host\" # Open terminal in VS Code # Run Amplifier normally amp","title":"Remote - SSH"},{"location":"dev-setup/remote-dev.html#remote-containers","text":"# Install extension code --install-extension ms-vscode-remote.remote-containers # Create devcontainer config mkdir .devcontainer .devcontainer/devcontainer.json : { \"name\" : \"Amplifier Dev\" , \"image\" : \"python:3.12\" , \"postCreateCommand\" : \"curl -LsSf https://astral.sh/uv/install.sh | sh && uv tool install amplifier\" , \"remoteEnv\" : { \"ANTHROPIC_API_KEY\" : \"${localEnv:ANTHROPIC_API_KEY}\" } }","title":"Remote - Containers"},{"location":"dev-setup/remote-dev.html#docker","text":"Run Amplifier in a container.","title":"Docker"},{"location":"dev-setup/remote-dev.html#basic-usage","text":"# Run interactive container docker run -it --rm \\ -v $( pwd ) :/workspace \\ -w /workspace \\ -e ANTHROPIC_API_KEY = \" $ANTHROPIC_API_KEY \" \\ python:3.12 bash # Inside container curl -LsSf https://astral.sh/uv/install.sh | sh source ~/.cargo/env uv tool install amplifier amp","title":"Basic Usage"},{"location":"dev-setup/remote-dev.html#dockerfile","text":"FROM python:3.12-slim # Install uv RUN curl -LsSf https://astral.sh/uv/install.sh | sh # Add uv to PATH ENV PATH = \"/root/.cargo/bin: $PATH \" # Install Amplifier RUN uv tool install amplifier WORKDIR /workspace CMD [ \"amp\" ] Build and run: docker build -t amplifier-dev . docker run -it --rm \\ -v $( pwd ) :/workspace \\ -e ANTHROPIC_API_KEY \\ amplifier-dev","title":"Dockerfile"},{"location":"dev-setup/remote-dev.html#docker-compose","text":"version : '3.8' services : amplifier : build : . volumes : - .:/workspace environment : - ANTHROPIC_API_KEY stdin_open : true tty : true docker compose run amplifier","title":"Docker Compose"},{"location":"dev-setup/remote-dev.html#github-codespaces","text":"Cloud-hosted development environment.","title":"GitHub Codespaces"},{"location":"dev-setup/remote-dev.html#setup_1","text":"Create .devcontainer/devcontainer.json in your repo: { \"name\" : \"Amplifier Workspace\" , \"image\" : \"mcr.microsoft.com/devcontainers/python:3.12\" , \"postCreateCommand\" : \"curl -LsSf https://astral.sh/uv/install.sh | sh && source ~/.cargo/env && uv tool install amplifier\" , \"secrets\" : { \"ANTHROPIC_API_KEY\" : { \"description\" : \"API key for Anthropic Claude\" } }, \"customizations\" : { \"vscode\" : { \"extensions\" : [ \"ms-python.python\" ] } } } Set secret in GitHub repo settings: Settings \u2192 Secrets \u2192 Codespaces Add ANTHROPIC_API_KEY Create Codespace: Code \u2192 Codespaces \u2192 Create on main In terminal: amp","title":"Setup"},{"location":"dev-setup/remote-dev.html#wsl-windows-subsystem-for-linux","text":"Run Amplifier in Linux on Windows.","title":"WSL (Windows Subsystem for Linux)"},{"location":"dev-setup/remote-dev.html#setup_2","text":"# Install WSL (PowerShell Admin) wsl - -install -d Ubuntu # Start WSL wsl In WSL: # Install uv curl -LsSf https://astral.sh/uv/install.sh | sh source ~/.cargo/env # Install Amplifier uv tool install amplifier # Configure export ANTHROPIC_API_KEY = \"your-key\" echo 'export ANTHROPIC_API_KEY=\"your-key\"' >> ~/.bashrc # Run amp","title":"Setup"},{"location":"dev-setup/remote-dev.html#access-windows-files","text":"# Windows drives are mounted at /mnt cd /mnt/c/Users/YourName/Projects # Run Amplifier on Windows project amp","title":"Access Windows Files"},{"location":"dev-setup/remote-dev.html#vs-code-wsl","text":"# From WSL cd /mnt/c/YourProject code . # Opens VS Code connected to WSL","title":"VS Code + WSL"},{"location":"dev-setup/remote-dev.html#environment-variables","text":"Securely handle API keys:","title":"Environment Variables"},{"location":"dev-setup/remote-dev.html#local-env-file","text":"# .env (gitignored!) ANTHROPIC_API_KEY = sk-ant-... OPENAI_API_KEY = sk-... # Load before running source .env amp","title":"Local .env File"},{"location":"dev-setup/remote-dev.html#direnv","text":"Auto-load environment per directory: # Install brew install direnv # Setup echo 'eval \"$(direnv hook bash)\"' >> ~/.bashrc # Create .envrc echo 'export ANTHROPIC_API_KEY=\"sk-ant-...\"' > .envrc direnv allow # Now auto-loads when you cd into directory","title":"direnv"},{"location":"dev-setup/remote-dev.html#try-it-yourself","text":"","title":"Try It Yourself"},{"location":"dev-setup/remote-dev.html#exercise-1-docker","text":"docker run -it --rm \\ -v $( pwd ) :/workspace \\ -e ANTHROPIC_API_KEY \\ python:3.12 bash -c \" curl -LsSf https://astral.sh/uv/install.sh | sh && source ~/.cargo/env && uv tool install amplifier && amp \"","title":"Exercise 1: Docker"},{"location":"dev-setup/remote-dev.html#exercise-2-tmux","text":"# Start tmux tmux new -s dev # Run Amplifier amp # Detach: Ctrl+b, d # Reattach: tmux attach -t dev","title":"Exercise 2: tmux"},{"location":"dev-setup/remote-dev.html#next","text":"Learn debugging techniques: \u2192 Debugging","title":"Next"},{"location":"dev-setup/shadow-workspace.html","text":"Shadow Workspace \u00b6 Work safely with AI-generated changes using a shadow copy of your project. Overview \u00b6 A shadow workspace lets you: Review AI changes before they touch your real code Test in isolation without risk to your project Compare diffs between original and modified Rollback easily if something goes wrong The Problem \u00b6 When Amplifier writes code, it modifies files directly. This can be risky: Changes might break things Hard to see what changed Difficult to undo The Solution \u00b6 Work in a shadow copy: my-project/ # Your real project (read-only to AI) my-project-shadow/ # Shadow copy (AI writes here) Setup Methods \u00b6 Method 1: Manual Copy \u00b6 # Create shadow workspace cp -r my-project my-project-shadow cd my-project-shadow # Start Amplifier amp Method 2: Git Worktree \u00b6 If your project uses git: cd my-project # Create worktree git worktree add ../my-project-shadow -b ai-changes # Work in shadow cd ../my-project-shadow amp Benefits: - Shares git history - Easy to create PR - Clean branch management Method 3: bkrabach's Shadow Script \u00b6 From bkrabach's setup-tools: # Install curl -o ~/bin/shadow https://raw.githubusercontent.com/bkrabach/setup-tools/main/shadow.sh chmod +x ~/bin/shadow # Use shadow my-project # Creates my-project-shadow and cd's into it Workflow \u00b6 Step 1: Create Shadow \u00b6 shadow my-project # or cp -r my-project my-project-shadow cd my-project-shadow Step 2: Work with Amplifier \u00b6 amp > Refactor the authentication module > Add comprehensive tests > Update the documentation Step 3: Review Changes \u00b6 # See what changed diff -r ../my-project . --exclude = .git --exclude = node_modules # Or with git git diff git status Step 4: Accept or Reject \u00b6 Accept changes: # If using git worktree git add . git commit -m \"AI-assisted refactoring\" git checkout main git merge ai-changes # If manual copy cp -r . ../my-project Reject changes: # Just delete the shadow cd .. rm -rf my-project-shadow Best Practices \u00b6 Keep Shadow Fresh \u00b6 Sync periodically: cd my-project-shadow rsync -av --exclude = '.git' ../my-project/ . Use Git Worktrees for Teams \u00b6 # Create feature branch worktree git worktree add ../feature-auth -b feature/auth-refactor # Work with AI cd ../feature-auth amp # Create PR when done gh pr create Exclude Large Directories \u00b6 When copying: rsync -av --exclude = 'node_modules' --exclude = '.venv' \\ --exclude = 'dist' --exclude = 'build' \\ my-project/ my-project-shadow/ Multiple Shadows \u00b6 For comparing approaches: shadow my-project approach-a shadow my-project approach-b # Try different prompts in each cd ../approach-a && amp cd ../approach-b && amp # Compare results diff -r approach-a approach-b Shadow Script \u00b6 Create ~/bin/shadow : #!/bin/bash # Shadow workspace creator if [ -z \" $1 \" ] ; then echo \"Usage: shadow <project-dir> [shadow-name]\" exit 1 fi PROJECT = \" $1 \" SHADOW = \" ${ 2 :- $1 -shadow } \" if [ -d \" $SHADOW \" ] ; then echo \"Shadow already exists: $SHADOW \" cd \" $SHADOW \" else echo \"Creating shadow workspace: $SHADOW \" if [ -d \" $PROJECT /.git\" ] ; then # Use git worktree if possible cd \" $PROJECT \" git worktree add \"../ $SHADOW \" -b \"shadow- $( date +%Y%m%d-%H%M%S ) \" cd \"../ $SHADOW \" else # Fall back to copy cp -r \" $PROJECT \" \" $SHADOW \" cd \" $SHADOW \" fi echo \"Shadow workspace ready: $SHADOW \" fi # Start shell in shadow exec $SHELL Try It Yourself \u00b6 Exercise 1: Create Shadow \u00b6 # Pick any project shadow my-project # Verify you're in shadow pwd Exercise 2: Make AI Changes \u00b6 amp > Add input validation to all API endpoints Exercise 3: Review and Decide \u00b6 # See changes git diff # Accept or reject Troubleshooting \u00b6 \"Directory already exists\" \u00b6 rm -rf my-project-shadow shadow my-project Large Projects Take Too Long \u00b6 Use rsync with exclusions: rsync -av --exclude = 'node_modules' --exclude = '.venv' \\ --progress my-project/ my-project-shadow/ Git Worktree Conflicts \u00b6 # Clean up orphaned worktree git worktree prune git worktree list Next \u00b6 Learn about remote development options: \u2192 Remote Development","title":"Shadow Workspace"},{"location":"dev-setup/shadow-workspace.html#shadow-workspace","text":"Work safely with AI-generated changes using a shadow copy of your project.","title":"Shadow Workspace"},{"location":"dev-setup/shadow-workspace.html#overview","text":"A shadow workspace lets you: Review AI changes before they touch your real code Test in isolation without risk to your project Compare diffs between original and modified Rollback easily if something goes wrong","title":"Overview"},{"location":"dev-setup/shadow-workspace.html#the-problem","text":"When Amplifier writes code, it modifies files directly. This can be risky: Changes might break things Hard to see what changed Difficult to undo","title":"The Problem"},{"location":"dev-setup/shadow-workspace.html#the-solution","text":"Work in a shadow copy: my-project/ # Your real project (read-only to AI) my-project-shadow/ # Shadow copy (AI writes here)","title":"The Solution"},{"location":"dev-setup/shadow-workspace.html#setup-methods","text":"","title":"Setup Methods"},{"location":"dev-setup/shadow-workspace.html#method-1-manual-copy","text":"# Create shadow workspace cp -r my-project my-project-shadow cd my-project-shadow # Start Amplifier amp","title":"Method 1: Manual Copy"},{"location":"dev-setup/shadow-workspace.html#method-2-git-worktree","text":"If your project uses git: cd my-project # Create worktree git worktree add ../my-project-shadow -b ai-changes # Work in shadow cd ../my-project-shadow amp Benefits: - Shares git history - Easy to create PR - Clean branch management","title":"Method 2: Git Worktree"},{"location":"dev-setup/shadow-workspace.html#method-3-bkrabachs-shadow-script","text":"From bkrabach's setup-tools: # Install curl -o ~/bin/shadow https://raw.githubusercontent.com/bkrabach/setup-tools/main/shadow.sh chmod +x ~/bin/shadow # Use shadow my-project # Creates my-project-shadow and cd's into it","title":"Method 3: bkrabach's Shadow Script"},{"location":"dev-setup/shadow-workspace.html#workflow","text":"","title":"Workflow"},{"location":"dev-setup/shadow-workspace.html#step-1-create-shadow","text":"shadow my-project # or cp -r my-project my-project-shadow cd my-project-shadow","title":"Step 1: Create Shadow"},{"location":"dev-setup/shadow-workspace.html#step-2-work-with-amplifier","text":"amp > Refactor the authentication module > Add comprehensive tests > Update the documentation","title":"Step 2: Work with Amplifier"},{"location":"dev-setup/shadow-workspace.html#step-3-review-changes","text":"# See what changed diff -r ../my-project . --exclude = .git --exclude = node_modules # Or with git git diff git status","title":"Step 3: Review Changes"},{"location":"dev-setup/shadow-workspace.html#step-4-accept-or-reject","text":"Accept changes: # If using git worktree git add . git commit -m \"AI-assisted refactoring\" git checkout main git merge ai-changes # If manual copy cp -r . ../my-project Reject changes: # Just delete the shadow cd .. rm -rf my-project-shadow","title":"Step 4: Accept or Reject"},{"location":"dev-setup/shadow-workspace.html#best-practices","text":"","title":"Best Practices"},{"location":"dev-setup/shadow-workspace.html#keep-shadow-fresh","text":"Sync periodically: cd my-project-shadow rsync -av --exclude = '.git' ../my-project/ .","title":"Keep Shadow Fresh"},{"location":"dev-setup/shadow-workspace.html#use-git-worktrees-for-teams","text":"# Create feature branch worktree git worktree add ../feature-auth -b feature/auth-refactor # Work with AI cd ../feature-auth amp # Create PR when done gh pr create","title":"Use Git Worktrees for Teams"},{"location":"dev-setup/shadow-workspace.html#exclude-large-directories","text":"When copying: rsync -av --exclude = 'node_modules' --exclude = '.venv' \\ --exclude = 'dist' --exclude = 'build' \\ my-project/ my-project-shadow/","title":"Exclude Large Directories"},{"location":"dev-setup/shadow-workspace.html#multiple-shadows","text":"For comparing approaches: shadow my-project approach-a shadow my-project approach-b # Try different prompts in each cd ../approach-a && amp cd ../approach-b && amp # Compare results diff -r approach-a approach-b","title":"Multiple Shadows"},{"location":"dev-setup/shadow-workspace.html#shadow-script","text":"Create ~/bin/shadow : #!/bin/bash # Shadow workspace creator if [ -z \" $1 \" ] ; then echo \"Usage: shadow <project-dir> [shadow-name]\" exit 1 fi PROJECT = \" $1 \" SHADOW = \" ${ 2 :- $1 -shadow } \" if [ -d \" $SHADOW \" ] ; then echo \"Shadow already exists: $SHADOW \" cd \" $SHADOW \" else echo \"Creating shadow workspace: $SHADOW \" if [ -d \" $PROJECT /.git\" ] ; then # Use git worktree if possible cd \" $PROJECT \" git worktree add \"../ $SHADOW \" -b \"shadow- $( date +%Y%m%d-%H%M%S ) \" cd \"../ $SHADOW \" else # Fall back to copy cp -r \" $PROJECT \" \" $SHADOW \" cd \" $SHADOW \" fi echo \"Shadow workspace ready: $SHADOW \" fi # Start shell in shadow exec $SHELL","title":"Shadow Script"},{"location":"dev-setup/shadow-workspace.html#try-it-yourself","text":"","title":"Try It Yourself"},{"location":"dev-setup/shadow-workspace.html#exercise-1-create-shadow","text":"# Pick any project shadow my-project # Verify you're in shadow pwd","title":"Exercise 1: Create Shadow"},{"location":"dev-setup/shadow-workspace.html#exercise-2-make-ai-changes","text":"amp > Add input validation to all API endpoints","title":"Exercise 2: Make AI Changes"},{"location":"dev-setup/shadow-workspace.html#exercise-3-review-and-decide","text":"# See changes git diff # Accept or reject","title":"Exercise 3: Review and Decide"},{"location":"dev-setup/shadow-workspace.html#troubleshooting","text":"","title":"Troubleshooting"},{"location":"dev-setup/shadow-workspace.html#directory-already-exists","text":"rm -rf my-project-shadow shadow my-project","title":"\"Directory already exists\""},{"location":"dev-setup/shadow-workspace.html#large-projects-take-too-long","text":"Use rsync with exclusions: rsync -av --exclude = 'node_modules' --exclude = '.venv' \\ --progress my-project/ my-project-shadow/","title":"Large Projects Take Too Long"},{"location":"dev-setup/shadow-workspace.html#git-worktree-conflicts","text":"# Clean up orphaned worktree git worktree prune git worktree list","title":"Git Worktree Conflicts"},{"location":"dev-setup/shadow-workspace.html#next","text":"Learn about remote development options: \u2192 Remote Development","title":"Next"},{"location":"quickstart/index.html","text":"Quickstart Guide \u00b6 Get up and running with Amplifier in minutes. This section walks you through installation, configuration, and building your first agent\u2014no prior AI development experience required. Follow these guides in order for the smoothest learning path, or jump to specific topics as needed. Section Contents \u00b6 Page Description Time Installation Install Amplifier and dependencies 5 min Configuration Set up API keys and preferences 5 min First Agent Build and run your first agent 10 min Using Tools Learn tool basics with hands-on examples 15 min Adding Context Give agents knowledge with context files 10 min Creating Skills Package reusable domain knowledge 15 min Next Steps Where to go from here 5 min Quick Tips \u00b6 API keys required \u2014 You'll need at least one LLM provider key (Anthropic recommended) Python 3.11+ \u2014 Amplifier requires modern Python; check with python --version Start simple \u2014 The first-agent guide uses minimal configuration intentionally Experiment freely \u2014 Sessions are isolated; you can't break anything permanently Use the help \u2014 Run amp --help for CLI options at any time Prerequisites \u00b6 Requirement Version Check Command Python 3.11+ python --version pip or uv Latest pip --version or uv --version API Key Any LLM Set in environment or config Recommended Path \u00b6 Installation \u2500\u2500\u25ba Configuration \u2500\u2500\u25ba First Agent \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u25bc \u25bc \u25bc Using Tools Adding Context Creating Skills \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u25bc Next Steps Where to Start \u00b6 Brand new to Amplifier? Start with Installation and follow the guides in order. The whole quickstart takes about an hour. Already installed? Jump to First Agent to build something immediately. Experienced with AI tools? Skim Configuration for Amplifier-specific settings, then explore Creating Skills . Quick Commands \u00b6 # Install Amplifier pip install amplifier-cli # Verify installation amp --version # Start interactive session amp # Run with specific bundle amp --bundle foundation What You'll Build \u00b6 By the end of this quickstart, you'll have: - A working Amplifier installation - Your first custom agent - Understanding of tools, context, and skills - Foundation for building complex AI applications Related Sections \u00b6 Concepts: Core Architecture Dev Setup: Development Environment Bundles: Using Bundles","title":"Overview"},{"location":"quickstart/index.html#quickstart-guide","text":"Get up and running with Amplifier in minutes. This section walks you through installation, configuration, and building your first agent\u2014no prior AI development experience required. Follow these guides in order for the smoothest learning path, or jump to specific topics as needed.","title":"Quickstart Guide"},{"location":"quickstart/index.html#section-contents","text":"Page Description Time Installation Install Amplifier and dependencies 5 min Configuration Set up API keys and preferences 5 min First Agent Build and run your first agent 10 min Using Tools Learn tool basics with hands-on examples 15 min Adding Context Give agents knowledge with context files 10 min Creating Skills Package reusable domain knowledge 15 min Next Steps Where to go from here 5 min","title":"Section Contents"},{"location":"quickstart/index.html#quick-tips","text":"API keys required \u2014 You'll need at least one LLM provider key (Anthropic recommended) Python 3.11+ \u2014 Amplifier requires modern Python; check with python --version Start simple \u2014 The first-agent guide uses minimal configuration intentionally Experiment freely \u2014 Sessions are isolated; you can't break anything permanently Use the help \u2014 Run amp --help for CLI options at any time","title":"Quick Tips"},{"location":"quickstart/index.html#prerequisites","text":"Requirement Version Check Command Python 3.11+ python --version pip or uv Latest pip --version or uv --version API Key Any LLM Set in environment or config","title":"Prerequisites"},{"location":"quickstart/index.html#recommended-path","text":"Installation \u2500\u2500\u25ba Configuration \u2500\u2500\u25ba First Agent \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u25bc \u25bc \u25bc Using Tools Adding Context Creating Skills \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u25bc Next Steps","title":"Recommended Path"},{"location":"quickstart/index.html#where-to-start","text":"Brand new to Amplifier? Start with Installation and follow the guides in order. The whole quickstart takes about an hour. Already installed? Jump to First Agent to build something immediately. Experienced with AI tools? Skim Configuration for Amplifier-specific settings, then explore Creating Skills .","title":"Where to Start"},{"location":"quickstart/index.html#quick-commands","text":"# Install Amplifier pip install amplifier-cli # Verify installation amp --version # Start interactive session amp # Run with specific bundle amp --bundle foundation","title":"Quick Commands"},{"location":"quickstart/index.html#what-youll-build","text":"By the end of this quickstart, you'll have: - A working Amplifier installation - Your first custom agent - Understanding of tools, context, and skills - Foundation for building complex AI applications","title":"What You'll Build"},{"location":"quickstart/index.html#related-sections","text":"Concepts: Core Architecture Dev Setup: Development Environment Bundles: Using Bundles","title":"Related Sections"},{"location":"quickstart/first-bundle.html","text":"Your First Bundle \u00b6 A bundle is a portable package of AI capabilities that you can share, compose, and reuse. Think of it as a \"plugin\" that gives an AI assistant new skills, knowledge, and behaviors. In this tutorial, you'll create a bundle that transforms any AI assistant into a specialized code review helper. What You'll Build \u00b6 By the end of this tutorial, you'll have: A complete bundle with custom instructions Configured tools for file operations Context files that guide behavior A working code reviewer you can use immediately Time required: 10-15 minutes Prerequisites: - Amplifier installed and working - Completed the \"Hello World\" quickstart - A text editor Step 1: Create the Bundle Directory \u00b6 Every bundle lives in its own directory with a specific structure. Let's create one: # Create the bundle directory mkdir -p ~/.amplifier/bundles/code-reviewer # Navigate into it cd ~/.amplifier/bundles/code-reviewer The bundle directory name ( code-reviewer ) becomes the bundle's identifier. You'll reference it as code-reviewer when composing with other bundles. Bundle Directory Structure \u00b6 Here's what we'll create: code-reviewer/ \u251c\u2500\u2500 bundle.yaml # Bundle manifest (required) \u251c\u2500\u2500 context/ # Context files loaded into AI \u2502 \u2514\u2500\u2500 instructions.md # Main behavior instructions \u2514\u2500\u2500 tools/ # Tool configurations (optional) \u2514\u2500\u2500 tools.yaml # Tool definitions Step 2: Create the Bundle Manifest \u00b6 The bundle.yaml file defines your bundle's metadata and composition: touch bundle.yaml Add this content to bundle.yaml : # Bundle manifest for code-reviewer name : code-reviewer version : 1.0.0 description : \"A focused code review assistant that provides actionable feedback\" # What this bundle provides provides : - code-review - best-practices # Context files to load (order matters) context : - context/instructions.md # Tools this bundle needs tools : - read_file - grep - glob # Optional: bundles this one extends extends : [] Understanding the Manifest \u00b6 Field Purpose name Unique identifier for your bundle version Semantic version for tracking changes description Human-readable explanation provides Capabilities this bundle offers context Files loaded into the AI's context tools Tools the AI can use extends Other bundles to inherit from Step 3: Add Instructions \u00b6 The instructions file is where you define your bundle's personality and behavior. This is the most important file\u2014it shapes how the AI acts. Create the context directory and instructions file: mkdir -p context touch context/instructions.md Add this content to context/instructions.md : # Code Review Assistant You are a focused code review assistant. Your job is to provide clear, actionable feedback that helps developers write better code. ## Review Philosophy - **Be specific** : Point to exact lines and explain why something matters - **Be constructive** : Suggest improvements, don't just criticize - **Be prioritized** : Distinguish critical issues from nice-to-haves - **Be educational** : Explain the \"why\" behind recommendations ## Review Process When asked to review code: 1. **Understand context** : What does this code do? What problem does it solve? 2. **Check correctness** : Does it work? Are there bugs or edge cases? 3. **Evaluate clarity** : Is it readable? Would a new team member understand it? 4. **Assess maintainability** : Is it easy to change? Are there hidden dependencies? 5. **Consider performance** : Are there obvious inefficiencies? ## Response Format Structure your reviews like this: ### Summary One paragraph overview of the code and your overall assessment. ### Critical Issues Problems that must be fixed (bugs, security issues, data loss risks). ### Improvements Suggestions that would meaningfully improve the code. ### Minor Notes Style suggestions, nitpicks, or optional enhancements. ## What NOT to Do - Don't rewrite entire files unprompted - Don't focus on style over substance - Don't be vague (\"this could be better\") - Don't overwhelm with too many comments ## Example Interaction User: \"Review this function for me\" Good response: - Start with what the function does - Identify the most important issue first - Provide a specific fix with explanation - Mention 1-2 secondary concerns - End with what's done well Bad response: - List 20 minor style issues - Rewrite the entire function - Give generic advice without specifics Step 4: Configure Tools \u00b6 Your bundle can specify which tools it needs. Create a tools configuration: mkdir -p tools touch tools/tools.yaml Add this content to tools/tools.yaml : # Tools configuration for code-reviewer bundle # File reading for examining code read_file : enabled : true description : \"Read source files to review\" # Pattern searching for finding issues grep : enabled : true description : \"Search for patterns in code\" # File discovery glob : enabled : true description : \"Find files to review\" # Tools we explicitly don't need write_file : enabled : false reason : \"Review only - no modifications\" bash : enabled : false reason : \"Review only - no execution\" Why Limit Tools? \u00b6 Restricting tools creates a safer, more focused assistant: Principle of least privilege : Only enable what's needed Clear boundaries : Users know what the assistant can/can't do Reduced risk : No accidental file modifications or command execution Step 5: Test Your Bundle \u00b6 Now let's verify everything works. First, validate the bundle structure: # Check that all files exist ls -la ~/.amplifier/bundles/code-reviewer/ You should see: bundle.yaml context/ instructions.md tools/ tools.yaml Run with Your Bundle \u00b6 Start Amplifier with your new bundle: amp --bundle code-reviewer Or add it to an existing configuration: amp --bundle foundation --bundle code-reviewer Test the Behavior \u00b6 Try these prompts to verify it's working: Review this Python function: def get_user(id): users = load_all_users() for u in users: if u.id == id: return u return None Your code reviewer should: 1. Identify the inefficiency (loading all users) 2. Suggest using a dictionary lookup or database query 3. Note the missing error handling 4. Format the response according to your instructions Step 6: Iterate and Improve \u00b6 Your first bundle is working! Now refine it based on usage: Add More Context \u00b6 Create additional context files for specific scenarios: # Security-focused review guidelines touch context/security-review.md # Performance review checklist touch context/performance-review.md Update bundle.yaml to include them: context : - context/instructions.md - context/security-review.md - context/performance-review.md Create Specialized Variants \u00b6 Make language-specific versions: mkdir -p ~/.amplifier/bundles/python-reviewer # Copy and customize for Python-specific guidance Compose with Other Bundles \u00b6 Extend existing bundles to add capabilities: # In a new bundle's bundle.yaml extends : - code-reviewer - python-standards Troubleshooting \u00b6 Bundle Not Loading \u00b6 Check these common issues: File location : Bundle must be in ~/.amplifier/bundles/ or a configured path YAML syntax : Validate with yamllint bundle.yaml File permissions : Ensure files are readable Instructions Not Taking Effect \u00b6 Context files must be listed in bundle.yaml Check file paths are relative to bundle root Verify no syntax errors in markdown Tools Not Available \u00b6 Tools must be enabled in the base configuration Bundle can only restrict, not add new tools Check tool names match exactly Next Steps \u00b6 You've created your first bundle. Here's where to go next: Bundle Composition : Learn to combine bundles effectively Advanced Context : Dynamic context and conditional loading Publishing Bundles : Share your bundles with others Bundle Patterns : Common patterns and best practices Quick Reference \u00b6 Bundle Checklist \u00b6 [ ] bundle.yaml with name, version, description [ ] At least one context file with instructions [ ] Tools configured appropriately [ ] Tested with real prompts [ ] Documentation for users Key Commands \u00b6 # List available bundles amp bundles list # Validate bundle structure amp bundles validate code-reviewer # Run with bundle amp --bundle code-reviewer # Combine bundles amp --bundle foundation --bundle code-reviewer Congratulations! You've built a reusable, composable AI capability. The bundle pattern lets you capture expertise once and apply it everywhere.","title":"Your First Bundle"},{"location":"quickstart/first-bundle.html#your-first-bundle","text":"A bundle is a portable package of AI capabilities that you can share, compose, and reuse. Think of it as a \"plugin\" that gives an AI assistant new skills, knowledge, and behaviors. In this tutorial, you'll create a bundle that transforms any AI assistant into a specialized code review helper.","title":"Your First Bundle"},{"location":"quickstart/first-bundle.html#what-youll-build","text":"By the end of this tutorial, you'll have: A complete bundle with custom instructions Configured tools for file operations Context files that guide behavior A working code reviewer you can use immediately Time required: 10-15 minutes Prerequisites: - Amplifier installed and working - Completed the \"Hello World\" quickstart - A text editor","title":"What You'll Build"},{"location":"quickstart/first-bundle.html#step-1-create-the-bundle-directory","text":"Every bundle lives in its own directory with a specific structure. Let's create one: # Create the bundle directory mkdir -p ~/.amplifier/bundles/code-reviewer # Navigate into it cd ~/.amplifier/bundles/code-reviewer The bundle directory name ( code-reviewer ) becomes the bundle's identifier. You'll reference it as code-reviewer when composing with other bundles.","title":"Step 1: Create the Bundle Directory"},{"location":"quickstart/first-bundle.html#bundle-directory-structure","text":"Here's what we'll create: code-reviewer/ \u251c\u2500\u2500 bundle.yaml # Bundle manifest (required) \u251c\u2500\u2500 context/ # Context files loaded into AI \u2502 \u2514\u2500\u2500 instructions.md # Main behavior instructions \u2514\u2500\u2500 tools/ # Tool configurations (optional) \u2514\u2500\u2500 tools.yaml # Tool definitions","title":"Bundle Directory Structure"},{"location":"quickstart/first-bundle.html#step-2-create-the-bundle-manifest","text":"The bundle.yaml file defines your bundle's metadata and composition: touch bundle.yaml Add this content to bundle.yaml : # Bundle manifest for code-reviewer name : code-reviewer version : 1.0.0 description : \"A focused code review assistant that provides actionable feedback\" # What this bundle provides provides : - code-review - best-practices # Context files to load (order matters) context : - context/instructions.md # Tools this bundle needs tools : - read_file - grep - glob # Optional: bundles this one extends extends : []","title":"Step 2: Create the Bundle Manifest"},{"location":"quickstart/first-bundle.html#understanding-the-manifest","text":"Field Purpose name Unique identifier for your bundle version Semantic version for tracking changes description Human-readable explanation provides Capabilities this bundle offers context Files loaded into the AI's context tools Tools the AI can use extends Other bundles to inherit from","title":"Understanding the Manifest"},{"location":"quickstart/first-bundle.html#step-3-add-instructions","text":"The instructions file is where you define your bundle's personality and behavior. This is the most important file\u2014it shapes how the AI acts. Create the context directory and instructions file: mkdir -p context touch context/instructions.md Add this content to context/instructions.md : # Code Review Assistant You are a focused code review assistant. Your job is to provide clear, actionable feedback that helps developers write better code. ## Review Philosophy - **Be specific** : Point to exact lines and explain why something matters - **Be constructive** : Suggest improvements, don't just criticize - **Be prioritized** : Distinguish critical issues from nice-to-haves - **Be educational** : Explain the \"why\" behind recommendations ## Review Process When asked to review code: 1. **Understand context** : What does this code do? What problem does it solve? 2. **Check correctness** : Does it work? Are there bugs or edge cases? 3. **Evaluate clarity** : Is it readable? Would a new team member understand it? 4. **Assess maintainability** : Is it easy to change? Are there hidden dependencies? 5. **Consider performance** : Are there obvious inefficiencies? ## Response Format Structure your reviews like this: ### Summary One paragraph overview of the code and your overall assessment. ### Critical Issues Problems that must be fixed (bugs, security issues, data loss risks). ### Improvements Suggestions that would meaningfully improve the code. ### Minor Notes Style suggestions, nitpicks, or optional enhancements. ## What NOT to Do - Don't rewrite entire files unprompted - Don't focus on style over substance - Don't be vague (\"this could be better\") - Don't overwhelm with too many comments ## Example Interaction User: \"Review this function for me\" Good response: - Start with what the function does - Identify the most important issue first - Provide a specific fix with explanation - Mention 1-2 secondary concerns - End with what's done well Bad response: - List 20 minor style issues - Rewrite the entire function - Give generic advice without specifics","title":"Step 3: Add Instructions"},{"location":"quickstart/first-bundle.html#step-4-configure-tools","text":"Your bundle can specify which tools it needs. Create a tools configuration: mkdir -p tools touch tools/tools.yaml Add this content to tools/tools.yaml : # Tools configuration for code-reviewer bundle # File reading for examining code read_file : enabled : true description : \"Read source files to review\" # Pattern searching for finding issues grep : enabled : true description : \"Search for patterns in code\" # File discovery glob : enabled : true description : \"Find files to review\" # Tools we explicitly don't need write_file : enabled : false reason : \"Review only - no modifications\" bash : enabled : false reason : \"Review only - no execution\"","title":"Step 4: Configure Tools"},{"location":"quickstart/first-bundle.html#why-limit-tools","text":"Restricting tools creates a safer, more focused assistant: Principle of least privilege : Only enable what's needed Clear boundaries : Users know what the assistant can/can't do Reduced risk : No accidental file modifications or command execution","title":"Why Limit Tools?"},{"location":"quickstart/first-bundle.html#step-5-test-your-bundle","text":"Now let's verify everything works. First, validate the bundle structure: # Check that all files exist ls -la ~/.amplifier/bundles/code-reviewer/ You should see: bundle.yaml context/ instructions.md tools/ tools.yaml","title":"Step 5: Test Your Bundle"},{"location":"quickstart/first-bundle.html#run-with-your-bundle","text":"Start Amplifier with your new bundle: amp --bundle code-reviewer Or add it to an existing configuration: amp --bundle foundation --bundle code-reviewer","title":"Run with Your Bundle"},{"location":"quickstart/first-bundle.html#test-the-behavior","text":"Try these prompts to verify it's working: Review this Python function: def get_user(id): users = load_all_users() for u in users: if u.id == id: return u return None Your code reviewer should: 1. Identify the inefficiency (loading all users) 2. Suggest using a dictionary lookup or database query 3. Note the missing error handling 4. Format the response according to your instructions","title":"Test the Behavior"},{"location":"quickstart/first-bundle.html#step-6-iterate-and-improve","text":"Your first bundle is working! Now refine it based on usage:","title":"Step 6: Iterate and Improve"},{"location":"quickstart/first-bundle.html#add-more-context","text":"Create additional context files for specific scenarios: # Security-focused review guidelines touch context/security-review.md # Performance review checklist touch context/performance-review.md Update bundle.yaml to include them: context : - context/instructions.md - context/security-review.md - context/performance-review.md","title":"Add More Context"},{"location":"quickstart/first-bundle.html#create-specialized-variants","text":"Make language-specific versions: mkdir -p ~/.amplifier/bundles/python-reviewer # Copy and customize for Python-specific guidance","title":"Create Specialized Variants"},{"location":"quickstart/first-bundle.html#compose-with-other-bundles","text":"Extend existing bundles to add capabilities: # In a new bundle's bundle.yaml extends : - code-reviewer - python-standards","title":"Compose with Other Bundles"},{"location":"quickstart/first-bundle.html#troubleshooting","text":"","title":"Troubleshooting"},{"location":"quickstart/first-bundle.html#bundle-not-loading","text":"Check these common issues: File location : Bundle must be in ~/.amplifier/bundles/ or a configured path YAML syntax : Validate with yamllint bundle.yaml File permissions : Ensure files are readable","title":"Bundle Not Loading"},{"location":"quickstart/first-bundle.html#instructions-not-taking-effect","text":"Context files must be listed in bundle.yaml Check file paths are relative to bundle root Verify no syntax errors in markdown","title":"Instructions Not Taking Effect"},{"location":"quickstart/first-bundle.html#tools-not-available","text":"Tools must be enabled in the base configuration Bundle can only restrict, not add new tools Check tool names match exactly","title":"Tools Not Available"},{"location":"quickstart/first-bundle.html#next-steps","text":"You've created your first bundle. Here's where to go next: Bundle Composition : Learn to combine bundles effectively Advanced Context : Dynamic context and conditional loading Publishing Bundles : Share your bundles with others Bundle Patterns : Common patterns and best practices","title":"Next Steps"},{"location":"quickstart/first-bundle.html#quick-reference","text":"","title":"Quick Reference"},{"location":"quickstart/first-bundle.html#bundle-checklist","text":"[ ] bundle.yaml with name, version, description [ ] At least one context file with instructions [ ] Tools configured appropriately [ ] Tested with real prompts [ ] Documentation for users","title":"Bundle Checklist"},{"location":"quickstart/first-bundle.html#key-commands","text":"# List available bundles amp bundles list # Validate bundle structure amp bundles validate code-reviewer # Run with bundle amp --bundle code-reviewer # Combine bundles amp --bundle foundation --bundle code-reviewer Congratulations! You've built a reusable, composable AI capability. The bundle pattern lets you capture expertise once and apply it everywhere.","title":"Key Commands"},{"location":"quickstart/first-conversation.html","text":"Your First Conversation \u00b6 This guide walks you through your first interactive session with Amplifier. You'll learn how to start a conversation, write effective prompts, interpret responses, and understand how Amplifier uses tools to accomplish tasks. Starting a Session \u00b6 Launch Amplifier from your terminal in any project directory: amplifier run You'll see a welcome message and a prompt indicator waiting for your input: Amplifier v1.0.0 Session: abc123-def456 > The session ID helps you reference this conversation later if needed. Starting in a Specific Directory \u00b6 To work on a particular project, navigate there first: cd ~/projects/my-app amplifier run Amplifier automatically gains context about your project structure, making it more effective at helping with your specific codebase. Your First Prompt \u00b6 Start with something simple. Try asking Amplifier to explore your project: > What files are in this project? Or ask for help with a specific task: > Create a Python function that validates email addresses Writing Effective Prompts \u00b6 Good prompts are clear and specific. Compare these examples: Less Effective More Effective \"Fix the bug\" \"Fix the TypeError in auth.py line 42\" \"Make it faster\" \"Optimize the database query in get_users()\" \"Add tests\" \"Add unit tests for the UserService class\" Providing Context \u00b6 You can reference files directly in your prompts: > Review the code in src/utils/helpers.py for potential improvements Or provide inline context: > I'm getting this error when running tests: > > AssertionError: expected 3 but got 5 > > The test is in tests/test_calculator.py Understanding Responses \u00b6 Amplifier responds conversationally while working on your request. A typical response includes several elements: Explanatory Text \u00b6 Amplifier explains what it's doing and why: I'll create an email validation function using regex. This will check for: - A valid local part (before the @) - A valid domain with at least one dot - No invalid characters Code Blocks \u00b6 Code appears in formatted blocks with syntax highlighting: import re def validate_email ( email : str ) -> bool : \"\"\"Validate an email address format.\"\"\" pattern = r '^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$' return bool ( re . match ( pattern , email )) File References \u00b6 When Amplifier references code locations, it uses the format file_path:line_number : The validation logic is in src/validators.py:23 This makes it easy to navigate to the exact location in your editor. Tool Usage \u00b6 Amplifier uses tools to interact with your system. You'll see tool activity as it works. Common Tools \u00b6 Tool Purpose read_file View file contents write_file Create new files edit_file Modify existing files bash Run shell commands grep Search file contents glob Find files by pattern Observing Tool Usage \u00b6 When Amplifier uses tools, you'll see indicators of what's happening: > Add a new endpoint to the API Reading src/api/routes.py... Editing src/api/routes.py... Running tests to verify changes... I've added the new endpoint at /api/users/{id}/profile. The route is defined in src/api/routes.py:45. Tests pass successfully. Tool Permissions \u00b6 Some operations may require confirmation. Amplifier respects your system and won't make destructive changes without appropriate safeguards. Multi-Turn Conversations \u00b6 Sessions maintain context across multiple exchanges. You can build on previous work: > Create a User class with name and email fields [Amplifier creates the class] > Add a method to validate the email [Amplifier adds to the existing class] > Now add unit tests for the validation [Amplifier creates tests referencing the class it built] Referencing Previous Context \u00b6 Use natural language to refer back: > Actually, make that method raise an exception instead of returning False Amplifier understands \"that method\" refers to the validation method from the previous exchange. Handling Errors \u00b6 If something goes wrong, Amplifier will explain and often suggest fixes: > Run the deployment script The deployment script failed with exit code 1: Error: Missing environment variable DATABASE_URL To fix this, you can: 1. Set the variable: export DATABASE_URL=\"your-connection-string\" 2. Create a .env file with the variable 3. Pass it inline: DATABASE_URL=\"...\" ./deploy.sh Asking for Clarification \u00b6 If your request is ambiguous, Amplifier asks for clarification rather than guessing: > Delete the old files I found several potential matches for \"old files\": - backup/ directory (23 files, last modified 30 days ago) - *.bak files (5 files across the project) - deprecated/ folder (12 files) Which would you like me to delete? Ending a Session \u00b6 To end your conversation, simply type: > exit Or use the keyboard shortcut Ctrl+C . Your session is automatically saved. You can resume it later or start fresh. Session Persistence \u00b6 Sessions are stored locally and can be referenced later. To see recent sessions: amplifier sessions list To resume a specific session: amplifier resume <session-id> Next Steps \u00b6 Now that you've had your first conversation, explore these topics: Working with Files - Deep dive into file operations Running Commands - Execute shell commands effectively Project Context - Help Amplifier understand your codebase Advanced Prompting - Write more effective prompts Tips for Success \u00b6 Be specific - Clear requests get better results Provide context - Share error messages, file paths, and background Iterate - Build on responses in multi-turn conversations Ask questions - Amplifier can explain code and concepts Trust but verify - Review generated code before committing Welcome to Amplifier. Happy building.","title":"Your First Conversation"},{"location":"quickstart/first-conversation.html#your-first-conversation","text":"This guide walks you through your first interactive session with Amplifier. You'll learn how to start a conversation, write effective prompts, interpret responses, and understand how Amplifier uses tools to accomplish tasks.","title":"Your First Conversation"},{"location":"quickstart/first-conversation.html#starting-a-session","text":"Launch Amplifier from your terminal in any project directory: amplifier run You'll see a welcome message and a prompt indicator waiting for your input: Amplifier v1.0.0 Session: abc123-def456 > The session ID helps you reference this conversation later if needed.","title":"Starting a Session"},{"location":"quickstart/first-conversation.html#starting-in-a-specific-directory","text":"To work on a particular project, navigate there first: cd ~/projects/my-app amplifier run Amplifier automatically gains context about your project structure, making it more effective at helping with your specific codebase.","title":"Starting in a Specific Directory"},{"location":"quickstart/first-conversation.html#your-first-prompt","text":"Start with something simple. Try asking Amplifier to explore your project: > What files are in this project? Or ask for help with a specific task: > Create a Python function that validates email addresses","title":"Your First Prompt"},{"location":"quickstart/first-conversation.html#writing-effective-prompts","text":"Good prompts are clear and specific. Compare these examples: Less Effective More Effective \"Fix the bug\" \"Fix the TypeError in auth.py line 42\" \"Make it faster\" \"Optimize the database query in get_users()\" \"Add tests\" \"Add unit tests for the UserService class\"","title":"Writing Effective Prompts"},{"location":"quickstart/first-conversation.html#providing-context","text":"You can reference files directly in your prompts: > Review the code in src/utils/helpers.py for potential improvements Or provide inline context: > I'm getting this error when running tests: > > AssertionError: expected 3 but got 5 > > The test is in tests/test_calculator.py","title":"Providing Context"},{"location":"quickstart/first-conversation.html#understanding-responses","text":"Amplifier responds conversationally while working on your request. A typical response includes several elements:","title":"Understanding Responses"},{"location":"quickstart/first-conversation.html#explanatory-text","text":"Amplifier explains what it's doing and why: I'll create an email validation function using regex. This will check for: - A valid local part (before the @) - A valid domain with at least one dot - No invalid characters","title":"Explanatory Text"},{"location":"quickstart/first-conversation.html#code-blocks","text":"Code appears in formatted blocks with syntax highlighting: import re def validate_email ( email : str ) -> bool : \"\"\"Validate an email address format.\"\"\" pattern = r '^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$' return bool ( re . match ( pattern , email ))","title":"Code Blocks"},{"location":"quickstart/first-conversation.html#file-references","text":"When Amplifier references code locations, it uses the format file_path:line_number : The validation logic is in src/validators.py:23 This makes it easy to navigate to the exact location in your editor.","title":"File References"},{"location":"quickstart/first-conversation.html#tool-usage","text":"Amplifier uses tools to interact with your system. You'll see tool activity as it works.","title":"Tool Usage"},{"location":"quickstart/first-conversation.html#common-tools","text":"Tool Purpose read_file View file contents write_file Create new files edit_file Modify existing files bash Run shell commands grep Search file contents glob Find files by pattern","title":"Common Tools"},{"location":"quickstart/first-conversation.html#observing-tool-usage","text":"When Amplifier uses tools, you'll see indicators of what's happening: > Add a new endpoint to the API Reading src/api/routes.py... Editing src/api/routes.py... Running tests to verify changes... I've added the new endpoint at /api/users/{id}/profile. The route is defined in src/api/routes.py:45. Tests pass successfully.","title":"Observing Tool Usage"},{"location":"quickstart/first-conversation.html#tool-permissions","text":"Some operations may require confirmation. Amplifier respects your system and won't make destructive changes without appropriate safeguards.","title":"Tool Permissions"},{"location":"quickstart/first-conversation.html#multi-turn-conversations","text":"Sessions maintain context across multiple exchanges. You can build on previous work: > Create a User class with name and email fields [Amplifier creates the class] > Add a method to validate the email [Amplifier adds to the existing class] > Now add unit tests for the validation [Amplifier creates tests referencing the class it built]","title":"Multi-Turn Conversations"},{"location":"quickstart/first-conversation.html#referencing-previous-context","text":"Use natural language to refer back: > Actually, make that method raise an exception instead of returning False Amplifier understands \"that method\" refers to the validation method from the previous exchange.","title":"Referencing Previous Context"},{"location":"quickstart/first-conversation.html#handling-errors","text":"If something goes wrong, Amplifier will explain and often suggest fixes: > Run the deployment script The deployment script failed with exit code 1: Error: Missing environment variable DATABASE_URL To fix this, you can: 1. Set the variable: export DATABASE_URL=\"your-connection-string\" 2. Create a .env file with the variable 3. Pass it inline: DATABASE_URL=\"...\" ./deploy.sh","title":"Handling Errors"},{"location":"quickstart/first-conversation.html#asking-for-clarification","text":"If your request is ambiguous, Amplifier asks for clarification rather than guessing: > Delete the old files I found several potential matches for \"old files\": - backup/ directory (23 files, last modified 30 days ago) - *.bak files (5 files across the project) - deprecated/ folder (12 files) Which would you like me to delete?","title":"Asking for Clarification"},{"location":"quickstart/first-conversation.html#ending-a-session","text":"To end your conversation, simply type: > exit Or use the keyboard shortcut Ctrl+C . Your session is automatically saved. You can resume it later or start fresh.","title":"Ending a Session"},{"location":"quickstart/first-conversation.html#session-persistence","text":"Sessions are stored locally and can be referenced later. To see recent sessions: amplifier sessions list To resume a specific session: amplifier resume <session-id>","title":"Session Persistence"},{"location":"quickstart/first-conversation.html#next-steps","text":"Now that you've had your first conversation, explore these topics: Working with Files - Deep dive into file operations Running Commands - Execute shell commands effectively Project Context - Help Amplifier understand your codebase Advanced Prompting - Write more effective prompts","title":"Next Steps"},{"location":"quickstart/first-conversation.html#tips-for-success","text":"Be specific - Clear requests get better results Provide context - Share error messages, file paths, and background Iterate - Build on responses in multi-turn conversations Ask questions - Amplifier can explain code and concepts Trust but verify - Review generated code before committing Welcome to Amplifier. Happy building.","title":"Tips for Success"},{"location":"quickstart/how-its-different.html","text":"How Amplifier is Different \u00b6 Amplifier represents a fundamentally different approach to building AI-powered applications. Rather than treating AI as a black box to be wrapped in layers of abstraction, Amplifier embraces simplicity, modularity, and developer control. Comparison Overview \u00b6 Most AI frameworks fall into two categories: either they're too opinionated and lock you into specific patterns, or they're too low-level and require you to build everything from scratch. Amplifier charts a middle path. Aspect Traditional Frameworks Amplifier Architecture Monolithic, tightly coupled Modular, composable Extensibility Plugin systems, inheritance First-class module contracts Multi-Agent Bolted on, complex Native, simple Customization Configuration files Behavior composition Learning Curve Steep, framework-specific Gradual, principle-based What We're Not \u00b6 Amplifier is not: A wrapper around a single LLM provider An opinionated application framework A no-code/low-code platform A managed service with vendor lock-in What We Are \u00b6 Amplifier is: A kernel for AI agent orchestration A collection of composable behaviors A philosophy of building with AI An open platform for innovation Modular Architecture \u00b6 At the heart of Amplifier is the \"bricks and studs\" philosophy. Like interlocking building blocks, every component has well-defined connection points that allow them to snap together predictably. The Kernel \u00b6 The Amplifier kernel is intentionally minimal. It provides: Session lifecycle management - Creating, persisting, and resuming conversations Module orchestration - Loading and coordinating modules at runtime Event dispatch - A simple pub/sub system for cross-cutting concerns Provider abstraction - A thin layer over LLM providers What it doesn't do is equally important. The kernel has no opinions about: How you structure your prompts What tools you expose to agents How agents communicate with each other Where you store your data Modules Over Plugins \u00b6 Traditional plugin systems are often afterthoughts. They expose limited hooks and require you to work around the framework's assumptions. Amplifier modules are different. Every capability in Amplifier is a module: amplifier-core/ modules/ providers/ # LLM provider implementations tools/ # Tool definitions and handlers hooks/ # Lifecycle event handlers context/ # Context providers Modules follow explicit contracts. A provider module must implement the Provider protocol. A tool module must implement the Tool protocol. There's no magic, no hidden behavior. Thin Bundles \u00b6 Bundles are curated collections of modules composed for specific use cases. The key insight is that bundles should be thin - they compose behaviors rather than implementing them. # A bundle is mostly composition name : code-assistant extends : foundation modules : - tool-bash - tool-file-ops - tool-lsp behaviors : - code-review - test-runner This approach means you can understand exactly what a bundle does by reading its manifest. There's no hidden complexity buried in base classes or inherited configurations. Extensibility \u00b6 Extensibility in Amplifier isn't a feature - it's the foundation. Protocol-Based Design \u00b6 Every extension point is defined by a protocol (interface). Want to add a new LLM provider? Implement the Provider protocol: class Provider ( Protocol ): async def generate ( self , messages : list [ Message ]) -> Response : ... async def stream ( self , messages : list [ Message ]) -> AsyncIterator [ Chunk ]: ... Want to add a new tool? Implement the Tool protocol: class Tool ( Protocol ): name : str description : str parameters : JsonSchema async def execute ( self , params : dict ) -> ToolResult : ... The protocols are minimal and stable. They define the contract, not the implementation. Hooks for Cross-Cutting Concerns \u00b6 Need to log every tool call? Add a hook. Need to filter responses? Add a hook. Need to inject context? Add a hook. @hook ( \"tool.before_call\" ) async def log_tool_calls ( event : ToolCallEvent ): logger . info ( f \"Calling { event . tool_name } with { event . arguments } \" ) Hooks are non-invasive. They observe and optionally modify behavior without requiring changes to the core system. No Framework Lock-In \u00b6 Amplifier doesn't require you to adopt it entirely. You can: Use just the kernel for agent orchestration Use individual modules in your existing application Gradually adopt more capabilities as needed Replace any component with your own implementation Multi-Agent \u00b6 Multi-agent systems are notoriously complex. Amplifier makes them simple by design. Agents Are Sessions \u00b6 In Amplifier, an agent is just a session with a specific configuration. There's no special \"Agent\" class or complex initialization: # Create an agent by creating a session with behaviors research_agent = await amplifier . session ( behaviors = [ \"web-research\" , \"summarization\" ] ) # Create another agent with different capabilities code_agent = await amplifier . session ( behaviors = [ \"code-analysis\" , \"refactoring\" ] ) Simple Delegation \u00b6 Agents delegate to other agents through the task tool. The pattern is straightforward: Parent agent decides to delegate Child agent receives instruction and context Child agent works independently Child agent returns a result Parent agent continues There's no complex message-passing infrastructure, no shared state to synchronize, no race conditions to handle. Each agent session is independent. Parallel Execution \u00b6 Because agents are independent sessions, parallel execution is natural: # Launch multiple agents in parallel results = await asyncio . gather ( research_agent . run ( \"Find information about X\" ), code_agent . run ( \"Analyze the authentication module\" ), ) Hierarchical Composition \u00b6 Complex workflows emerge from simple compositions: main-agent \u251c\u2500\u2500 planning-agent \u2502 \u2514\u2500\u2500 estimation-agent \u251c\u2500\u2500 implementation-agent \u2502 \u251c\u2500\u2500 frontend-agent \u2502 \u2514\u2500\u2500 backend-agent \u2514\u2500\u2500 review-agent Each level only knows about its immediate children. The planning agent doesn't know or care how the implementation agent structures its work internally. Open Source \u00b6 Amplifier is fully open source under a permissive license. But open source means more than just \"code is available.\" Transparent Development \u00b6 All development happens in the open. Issues, discussions, and roadmap decisions are visible and participatory. There are no private feature branches or surprise releases. Community-Driven Evolution \u00b6 The module system means the community can extend Amplifier without waiting for core changes. New providers, tools, and behaviors can be developed and shared independently. No Artificial Limitations \u00b6 There are no \"enterprise\" features held back, no usage limits, no telemetry requirements. You get the complete system, and you can deploy it however you want. Sustainable Ecosystem \u00b6 The modular architecture means: Core remains stable and maintained Community modules can evolve independently Breaking changes are isolated to specific modules You can lock versions of individual components The Amplifier Philosophy \u00b6 Beyond technical differences, Amplifier embodies a philosophy: Simplicity over features - We'd rather do fewer things well Composition over inheritance - Build by combining, not extending Explicit over implicit - No magic, no hidden behavior Trust the developer - You know your domain better than we do Embrace AI as a partner - AI builds the code, humans guide the vision This philosophy permeates every design decision. When evaluating new features, we ask: Does this make things simpler? Does it compose well? Is it explicit? Does it trust developers? If the answer is no, we find a different approach or don't add the feature at all. Next Steps \u00b6 Ready to experience the difference? Installation Guide - Get Amplifier running in minutes Your First Agent - Build something real Core Concepts - Understand the foundations Module Development - Extend Amplifier yourself","title":"How It's Different"},{"location":"quickstart/how-its-different.html#how-amplifier-is-different","text":"Amplifier represents a fundamentally different approach to building AI-powered applications. Rather than treating AI as a black box to be wrapped in layers of abstraction, Amplifier embraces simplicity, modularity, and developer control.","title":"How Amplifier is Different"},{"location":"quickstart/how-its-different.html#comparison-overview","text":"Most AI frameworks fall into two categories: either they're too opinionated and lock you into specific patterns, or they're too low-level and require you to build everything from scratch. Amplifier charts a middle path. Aspect Traditional Frameworks Amplifier Architecture Monolithic, tightly coupled Modular, composable Extensibility Plugin systems, inheritance First-class module contracts Multi-Agent Bolted on, complex Native, simple Customization Configuration files Behavior composition Learning Curve Steep, framework-specific Gradual, principle-based","title":"Comparison Overview"},{"location":"quickstart/how-its-different.html#what-were-not","text":"Amplifier is not: A wrapper around a single LLM provider An opinionated application framework A no-code/low-code platform A managed service with vendor lock-in","title":"What We're Not"},{"location":"quickstart/how-its-different.html#what-we-are","text":"Amplifier is: A kernel for AI agent orchestration A collection of composable behaviors A philosophy of building with AI An open platform for innovation","title":"What We Are"},{"location":"quickstart/how-its-different.html#modular-architecture","text":"At the heart of Amplifier is the \"bricks and studs\" philosophy. Like interlocking building blocks, every component has well-defined connection points that allow them to snap together predictably.","title":"Modular Architecture"},{"location":"quickstart/how-its-different.html#the-kernel","text":"The Amplifier kernel is intentionally minimal. It provides: Session lifecycle management - Creating, persisting, and resuming conversations Module orchestration - Loading and coordinating modules at runtime Event dispatch - A simple pub/sub system for cross-cutting concerns Provider abstraction - A thin layer over LLM providers What it doesn't do is equally important. The kernel has no opinions about: How you structure your prompts What tools you expose to agents How agents communicate with each other Where you store your data","title":"The Kernel"},{"location":"quickstart/how-its-different.html#modules-over-plugins","text":"Traditional plugin systems are often afterthoughts. They expose limited hooks and require you to work around the framework's assumptions. Amplifier modules are different. Every capability in Amplifier is a module: amplifier-core/ modules/ providers/ # LLM provider implementations tools/ # Tool definitions and handlers hooks/ # Lifecycle event handlers context/ # Context providers Modules follow explicit contracts. A provider module must implement the Provider protocol. A tool module must implement the Tool protocol. There's no magic, no hidden behavior.","title":"Modules Over Plugins"},{"location":"quickstart/how-its-different.html#thin-bundles","text":"Bundles are curated collections of modules composed for specific use cases. The key insight is that bundles should be thin - they compose behaviors rather than implementing them. # A bundle is mostly composition name : code-assistant extends : foundation modules : - tool-bash - tool-file-ops - tool-lsp behaviors : - code-review - test-runner This approach means you can understand exactly what a bundle does by reading its manifest. There's no hidden complexity buried in base classes or inherited configurations.","title":"Thin Bundles"},{"location":"quickstart/how-its-different.html#extensibility","text":"Extensibility in Amplifier isn't a feature - it's the foundation.","title":"Extensibility"},{"location":"quickstart/how-its-different.html#protocol-based-design","text":"Every extension point is defined by a protocol (interface). Want to add a new LLM provider? Implement the Provider protocol: class Provider ( Protocol ): async def generate ( self , messages : list [ Message ]) -> Response : ... async def stream ( self , messages : list [ Message ]) -> AsyncIterator [ Chunk ]: ... Want to add a new tool? Implement the Tool protocol: class Tool ( Protocol ): name : str description : str parameters : JsonSchema async def execute ( self , params : dict ) -> ToolResult : ... The protocols are minimal and stable. They define the contract, not the implementation.","title":"Protocol-Based Design"},{"location":"quickstart/how-its-different.html#hooks-for-cross-cutting-concerns","text":"Need to log every tool call? Add a hook. Need to filter responses? Add a hook. Need to inject context? Add a hook. @hook ( \"tool.before_call\" ) async def log_tool_calls ( event : ToolCallEvent ): logger . info ( f \"Calling { event . tool_name } with { event . arguments } \" ) Hooks are non-invasive. They observe and optionally modify behavior without requiring changes to the core system.","title":"Hooks for Cross-Cutting Concerns"},{"location":"quickstart/how-its-different.html#no-framework-lock-in","text":"Amplifier doesn't require you to adopt it entirely. You can: Use just the kernel for agent orchestration Use individual modules in your existing application Gradually adopt more capabilities as needed Replace any component with your own implementation","title":"No Framework Lock-In"},{"location":"quickstart/how-its-different.html#multi-agent","text":"Multi-agent systems are notoriously complex. Amplifier makes them simple by design.","title":"Multi-Agent"},{"location":"quickstart/how-its-different.html#agents-are-sessions","text":"In Amplifier, an agent is just a session with a specific configuration. There's no special \"Agent\" class or complex initialization: # Create an agent by creating a session with behaviors research_agent = await amplifier . session ( behaviors = [ \"web-research\" , \"summarization\" ] ) # Create another agent with different capabilities code_agent = await amplifier . session ( behaviors = [ \"code-analysis\" , \"refactoring\" ] )","title":"Agents Are Sessions"},{"location":"quickstart/how-its-different.html#simple-delegation","text":"Agents delegate to other agents through the task tool. The pattern is straightforward: Parent agent decides to delegate Child agent receives instruction and context Child agent works independently Child agent returns a result Parent agent continues There's no complex message-passing infrastructure, no shared state to synchronize, no race conditions to handle. Each agent session is independent.","title":"Simple Delegation"},{"location":"quickstart/how-its-different.html#parallel-execution","text":"Because agents are independent sessions, parallel execution is natural: # Launch multiple agents in parallel results = await asyncio . gather ( research_agent . run ( \"Find information about X\" ), code_agent . run ( \"Analyze the authentication module\" ), )","title":"Parallel Execution"},{"location":"quickstart/how-its-different.html#hierarchical-composition","text":"Complex workflows emerge from simple compositions: main-agent \u251c\u2500\u2500 planning-agent \u2502 \u2514\u2500\u2500 estimation-agent \u251c\u2500\u2500 implementation-agent \u2502 \u251c\u2500\u2500 frontend-agent \u2502 \u2514\u2500\u2500 backend-agent \u2514\u2500\u2500 review-agent Each level only knows about its immediate children. The planning agent doesn't know or care how the implementation agent structures its work internally.","title":"Hierarchical Composition"},{"location":"quickstart/how-its-different.html#open-source","text":"Amplifier is fully open source under a permissive license. But open source means more than just \"code is available.\"","title":"Open Source"},{"location":"quickstart/how-its-different.html#transparent-development","text":"All development happens in the open. Issues, discussions, and roadmap decisions are visible and participatory. There are no private feature branches or surprise releases.","title":"Transparent Development"},{"location":"quickstart/how-its-different.html#community-driven-evolution","text":"The module system means the community can extend Amplifier without waiting for core changes. New providers, tools, and behaviors can be developed and shared independently.","title":"Community-Driven Evolution"},{"location":"quickstart/how-its-different.html#no-artificial-limitations","text":"There are no \"enterprise\" features held back, no usage limits, no telemetry requirements. You get the complete system, and you can deploy it however you want.","title":"No Artificial Limitations"},{"location":"quickstart/how-its-different.html#sustainable-ecosystem","text":"The modular architecture means: Core remains stable and maintained Community modules can evolve independently Breaking changes are isolated to specific modules You can lock versions of individual components","title":"Sustainable Ecosystem"},{"location":"quickstart/how-its-different.html#the-amplifier-philosophy","text":"Beyond technical differences, Amplifier embodies a philosophy: Simplicity over features - We'd rather do fewer things well Composition over inheritance - Build by combining, not extending Explicit over implicit - No magic, no hidden behavior Trust the developer - You know your domain better than we do Embrace AI as a partner - AI builds the code, humans guide the vision This philosophy permeates every design decision. When evaluating new features, we ask: Does this make things simpler? Does it compose well? Is it explicit? Does it trust developers? If the answer is no, we find a different approach or don't add the feature at all.","title":"The Amplifier Philosophy"},{"location":"quickstart/how-its-different.html#next-steps","text":"Ready to experience the difference? Installation Guide - Get Amplifier running in minutes Your First Agent - Build something real Core Concepts - Understand the foundations Module Development - Extend Amplifier yourself","title":"Next Steps"},{"location":"quickstart/installation.html","text":"Installation \u00b6 This guide walks you through installing Amplifier on your system. The process takes about 5 minutes and requires minimal setup. Prerequisites \u00b6 Before installing Amplifier, ensure your system meets these requirements: Python Version \u00b6 Amplifier requires Python 3.10 or higher . Check your Python version: python --version If you need to install or upgrade Python: macOS : brew install python@3.12 Ubuntu/Debian : sudo apt install python3.12 Windows : Download from python.org Operating System Support \u00b6 Amplifier runs on: macOS 12 (Monterey) or later Linux (Ubuntu 20.04+, Debian 11+, Fedora 36+) Windows 10/11 with WSL2 Additional Requirements \u00b6 Terminal access (bash, zsh, or PowerShell with WSL) Internet connection for package downloads At least 500MB of free disk space Step 1: Install UV \u00b6 UV is the recommended package manager for Amplifier. It's fast, reliable, and handles dependencies automatically. macOS and Linux \u00b6 Run the installation script: curl -LsSf https://astral.sh/uv/install.sh | sh After installation, restart your terminal or run: source ~/.bashrc # or ~/.zshrc for zsh Windows (WSL) \u00b6 Open your WSL terminal and run: curl -LsSf https://astral.sh/uv/install.sh | sh Alternative: Install via Homebrew \u00b6 If you prefer Homebrew on macOS: brew install uv Verify UV Installation \u00b6 Confirm UV is installed correctly: uv --version You should see output like: uv 0.5.x Step 2: Install Amplifier \u00b6 With UV installed, getting Amplifier is a single command: uvx amplifier This command: Downloads the latest Amplifier release Creates an isolated environment Installs all dependencies Makes amplifier available globally What Happens During Installation \u00b6 UV creates a tool environment at ~/.local/share/uv/tools/amplifier/ containing: The Amplifier CLI application All required Python packages Configuration templates Installation Location \u00b6 By default, the amplifier command is installed to: macOS/Linux : ~/.local/bin/amplifier Windows WSL : ~/.local/bin/amplifier Ensure this directory is in your PATH. UV typically handles this automatically. Step 3: Setup Wizard \u00b6 Run the interactive setup wizard to configure Amplifier: amplifier init The wizard guides you through: Provider Configuration \u00b6 Select your AI provider(s): ? Select AI providers to configure: [x] Anthropic (Claude) [ ] OpenAI (GPT-4) [ ] Azure OpenAI [ ] Google (Gemini) API Key Setup \u00b6 Enter your API key when prompted: ? Enter your Anthropic API key: sk-ant-... Your keys are stored securely in ~/.amplifier/settings.yaml . Default Model Selection \u00b6 Choose your preferred model: ? Select default model: > claude-sonnet-4-20250514 claude-3-5-haiku-20241022 claude-3-opus-20240229 Configuration File \u00b6 The wizard creates ~/.amplifier/settings.yaml : providers : anthropic : api_key : ${ANTHROPIC_API_KEY} default_model : claude-sonnet-4-20250514 defaults : provider : anthropic temperature : 0.7 Skip Interactive Mode \u00b6 For automated setups, use environment variables: export ANTHROPIC_API_KEY = \"your-key-here\" amplifier init --non-interactive Step 4: Verify Installation \u00b6 Confirm everything is working: amplifier version Expected output: Amplifier v0.x.x Python: 3.12.x UV: 0.5.x Config: ~/.amplifier/settings.yaml Quick Test \u00b6 Start an interactive session: amplifier You should see the Amplifier prompt: Amplifier v0.x.x | claude-sonnet-4-20250514 Type /help for commands, /quit to exit > Type a simple query to confirm everything works: > Hello, can you hear me? Press /quit to exit. Common Issues \u00b6 UV Not Found \u00b6 Symptom : command not found: uv Solution : Add UV to your PATH: export PATH = \" $HOME /.local/bin: $PATH \" Add this line to your ~/.bashrc or ~/.zshrc for persistence. Python Version Too Old \u00b6 Symptom : Python 3.10+ required, found 3.8.x Solution : Install a newer Python version or use pyenv: # Install pyenv curl https://pyenv.run | bash # Install Python 3.12 pyenv install 3 .12 pyenv global 3 .12 API Key Invalid \u00b6 Symptom : Authentication failed: Invalid API key Solution : Verify your API key is correct: # Check the stored key cat ~/.amplifier/settings.yaml | grep api_key # Re-run setup amplifier init Permission Denied \u00b6 Symptom : Permission denied: ~/.local/bin/amplifier Solution : Fix permissions: chmod +x ~/.local/bin/amplifier SSL Certificate Errors \u00b6 Symptom : SSL: CERTIFICATE_VERIFY_FAILED Solution : Update certificates: # macOS /Applications/Python \\ 3 .12/Install \\ Certificates.command # Linux sudo apt install ca-certificates sudo update-ca-certificates Proxy Configuration \u00b6 If you're behind a corporate proxy: export HTTP_PROXY = \"http://proxy.company.com:8080\" export HTTPS_PROXY = \"http://proxy.company.com:8080\" uvx amplifier WSL-Specific Issues \u00b6 Symptom : Slow performance or networking issues in WSL Solution : Ensure WSL2 is being used: # In PowerShell wsl - -set-default-version 2 Updating Amplifier \u00b6 Keep Amplifier current with: uvx amplifier@latest Or specify a version: uvx amplifier@0.5.0 Check for Updates \u00b6 See if a newer version is available: amplifier version --check-updates Uninstalling \u00b6 To remove Amplifier: uv tool uninstall amplifier To also remove configuration: rm -rf ~/.amplifier Next Steps \u00b6 Now that Amplifier is installed, continue with: First Session - Start your first AI-assisted coding session Configuration Guide - Customize Amplifier settings Provider Setup - Configure additional AI providers Bundles Overview - Extend functionality with bundles Quick Commands Reference \u00b6 Command Description amplifier Start interactive session amplifier init Run setup wizard amplifier version Show version info amplifier --help Show all commands Getting Help \u00b6 If you encounter issues not covered here: Check the FAQ Search GitHub Issues Join the community discussions Welcome to Amplifier!","title":"Installation"},{"location":"quickstart/installation.html#installation","text":"This guide walks you through installing Amplifier on your system. The process takes about 5 minutes and requires minimal setup.","title":"Installation"},{"location":"quickstart/installation.html#prerequisites","text":"Before installing Amplifier, ensure your system meets these requirements:","title":"Prerequisites"},{"location":"quickstart/installation.html#python-version","text":"Amplifier requires Python 3.10 or higher . Check your Python version: python --version If you need to install or upgrade Python: macOS : brew install python@3.12 Ubuntu/Debian : sudo apt install python3.12 Windows : Download from python.org","title":"Python Version"},{"location":"quickstart/installation.html#operating-system-support","text":"Amplifier runs on: macOS 12 (Monterey) or later Linux (Ubuntu 20.04+, Debian 11+, Fedora 36+) Windows 10/11 with WSL2","title":"Operating System Support"},{"location":"quickstart/installation.html#additional-requirements","text":"Terminal access (bash, zsh, or PowerShell with WSL) Internet connection for package downloads At least 500MB of free disk space","title":"Additional Requirements"},{"location":"quickstart/installation.html#step-1-install-uv","text":"UV is the recommended package manager for Amplifier. It's fast, reliable, and handles dependencies automatically.","title":"Step 1: Install UV"},{"location":"quickstart/installation.html#macos-and-linux","text":"Run the installation script: curl -LsSf https://astral.sh/uv/install.sh | sh After installation, restart your terminal or run: source ~/.bashrc # or ~/.zshrc for zsh","title":"macOS and Linux"},{"location":"quickstart/installation.html#windows-wsl","text":"Open your WSL terminal and run: curl -LsSf https://astral.sh/uv/install.sh | sh","title":"Windows (WSL)"},{"location":"quickstart/installation.html#alternative-install-via-homebrew","text":"If you prefer Homebrew on macOS: brew install uv","title":"Alternative: Install via Homebrew"},{"location":"quickstart/installation.html#verify-uv-installation","text":"Confirm UV is installed correctly: uv --version You should see output like: uv 0.5.x","title":"Verify UV Installation"},{"location":"quickstart/installation.html#step-2-install-amplifier","text":"With UV installed, getting Amplifier is a single command: uvx amplifier This command: Downloads the latest Amplifier release Creates an isolated environment Installs all dependencies Makes amplifier available globally","title":"Step 2: Install Amplifier"},{"location":"quickstart/installation.html#what-happens-during-installation","text":"UV creates a tool environment at ~/.local/share/uv/tools/amplifier/ containing: The Amplifier CLI application All required Python packages Configuration templates","title":"What Happens During Installation"},{"location":"quickstart/installation.html#installation-location","text":"By default, the amplifier command is installed to: macOS/Linux : ~/.local/bin/amplifier Windows WSL : ~/.local/bin/amplifier Ensure this directory is in your PATH. UV typically handles this automatically.","title":"Installation Location"},{"location":"quickstart/installation.html#step-3-setup-wizard","text":"Run the interactive setup wizard to configure Amplifier: amplifier init The wizard guides you through:","title":"Step 3: Setup Wizard"},{"location":"quickstart/installation.html#provider-configuration","text":"Select your AI provider(s): ? Select AI providers to configure: [x] Anthropic (Claude) [ ] OpenAI (GPT-4) [ ] Azure OpenAI [ ] Google (Gemini)","title":"Provider Configuration"},{"location":"quickstart/installation.html#api-key-setup","text":"Enter your API key when prompted: ? Enter your Anthropic API key: sk-ant-... Your keys are stored securely in ~/.amplifier/settings.yaml .","title":"API Key Setup"},{"location":"quickstart/installation.html#default-model-selection","text":"Choose your preferred model: ? Select default model: > claude-sonnet-4-20250514 claude-3-5-haiku-20241022 claude-3-opus-20240229","title":"Default Model Selection"},{"location":"quickstart/installation.html#configuration-file","text":"The wizard creates ~/.amplifier/settings.yaml : providers : anthropic : api_key : ${ANTHROPIC_API_KEY} default_model : claude-sonnet-4-20250514 defaults : provider : anthropic temperature : 0.7","title":"Configuration File"},{"location":"quickstart/installation.html#skip-interactive-mode","text":"For automated setups, use environment variables: export ANTHROPIC_API_KEY = \"your-key-here\" amplifier init --non-interactive","title":"Skip Interactive Mode"},{"location":"quickstart/installation.html#step-4-verify-installation","text":"Confirm everything is working: amplifier version Expected output: Amplifier v0.x.x Python: 3.12.x UV: 0.5.x Config: ~/.amplifier/settings.yaml","title":"Step 4: Verify Installation"},{"location":"quickstart/installation.html#quick-test","text":"Start an interactive session: amplifier You should see the Amplifier prompt: Amplifier v0.x.x | claude-sonnet-4-20250514 Type /help for commands, /quit to exit > Type a simple query to confirm everything works: > Hello, can you hear me? Press /quit to exit.","title":"Quick Test"},{"location":"quickstart/installation.html#common-issues","text":"","title":"Common Issues"},{"location":"quickstart/installation.html#uv-not-found","text":"Symptom : command not found: uv Solution : Add UV to your PATH: export PATH = \" $HOME /.local/bin: $PATH \" Add this line to your ~/.bashrc or ~/.zshrc for persistence.","title":"UV Not Found"},{"location":"quickstart/installation.html#python-version-too-old","text":"Symptom : Python 3.10+ required, found 3.8.x Solution : Install a newer Python version or use pyenv: # Install pyenv curl https://pyenv.run | bash # Install Python 3.12 pyenv install 3 .12 pyenv global 3 .12","title":"Python Version Too Old"},{"location":"quickstart/installation.html#api-key-invalid","text":"Symptom : Authentication failed: Invalid API key Solution : Verify your API key is correct: # Check the stored key cat ~/.amplifier/settings.yaml | grep api_key # Re-run setup amplifier init","title":"API Key Invalid"},{"location":"quickstart/installation.html#permission-denied","text":"Symptom : Permission denied: ~/.local/bin/amplifier Solution : Fix permissions: chmod +x ~/.local/bin/amplifier","title":"Permission Denied"},{"location":"quickstart/installation.html#ssl-certificate-errors","text":"Symptom : SSL: CERTIFICATE_VERIFY_FAILED Solution : Update certificates: # macOS /Applications/Python \\ 3 .12/Install \\ Certificates.command # Linux sudo apt install ca-certificates sudo update-ca-certificates","title":"SSL Certificate Errors"},{"location":"quickstart/installation.html#proxy-configuration","text":"If you're behind a corporate proxy: export HTTP_PROXY = \"http://proxy.company.com:8080\" export HTTPS_PROXY = \"http://proxy.company.com:8080\" uvx amplifier","title":"Proxy Configuration"},{"location":"quickstart/installation.html#wsl-specific-issues","text":"Symptom : Slow performance or networking issues in WSL Solution : Ensure WSL2 is being used: # In PowerShell wsl - -set-default-version 2","title":"WSL-Specific Issues"},{"location":"quickstart/installation.html#updating-amplifier","text":"Keep Amplifier current with: uvx amplifier@latest Or specify a version: uvx amplifier@0.5.0","title":"Updating Amplifier"},{"location":"quickstart/installation.html#check-for-updates","text":"See if a newer version is available: amplifier version --check-updates","title":"Check for Updates"},{"location":"quickstart/installation.html#uninstalling","text":"To remove Amplifier: uv tool uninstall amplifier To also remove configuration: rm -rf ~/.amplifier","title":"Uninstalling"},{"location":"quickstart/installation.html#next-steps","text":"Now that Amplifier is installed, continue with: First Session - Start your first AI-assisted coding session Configuration Guide - Customize Amplifier settings Provider Setup - Configure additional AI providers Bundles Overview - Extend functionality with bundles","title":"Next Steps"},{"location":"quickstart/installation.html#quick-commands-reference","text":"Command Description amplifier Start interactive session amplifier init Run setup wizard amplifier version Show version info amplifier --help Show all commands","title":"Quick Commands Reference"},{"location":"quickstart/installation.html#getting-help","text":"If you encounter issues not covered here: Check the FAQ Search GitHub Issues Join the community discussions Welcome to Amplifier!","title":"Getting Help"},{"location":"quickstart/key-commands.html","text":"Key Commands \u00b6 This reference covers the essential commands you'll use every day with Amplifier. Master these three commands and you'll have complete control over your sessions. Command Overview \u00b6 Command Purpose When to Use amplifier run Start a new session Beginning fresh work amplifier continue Resume the last session Picking up where you left off amplifier resume Choose from session history Returning to older work Quick Reference \u00b6 # Start fresh amplifier run # Continue last session amplifier continue # Pick a specific session amplifier resume amplifier run \u00b6 The run command starts a new Amplifier session in your current directory. Basic Usage \u00b6 amplifier run This launches an interactive session where you can start working with the AI assistant immediately. Common Options \u00b6 # Start with a specific prompt amplifier run \"Explain the architecture of this project\" # Use a specific bundle configuration amplifier run --bundle my-bundle # Start in a different directory amplifier run --cwd /path/to/project # Enable verbose output for debugging amplifier run --verbose With Initial Prompt \u00b6 Pass your first message directly to skip the initial prompt: amplifier run \"Review the authentication module for security issues\" This immediately starts working on your request without waiting for input. Working Directory \u00b6 Amplifier runs in your current directory by default. The working directory determines: Which AGENTS.md configuration files are loaded The scope of file operations Git repository context # Run in current directory cd my-project amplifier run # Or specify explicitly amplifier run --cwd ~/projects/my-app Bundle Selection \u00b6 Bundles define what tools and agents are available: # Use the default foundation bundle amplifier run # Use a specific bundle amplifier run --bundle developer # Use a custom bundle from your project amplifier run --bundle .amplifier/bundles/custom.yaml amplifier continue \u00b6 The continue command resumes your most recent session. This is your go-to command when returning to work. Basic Usage \u00b6 amplifier continue This picks up exactly where you left off, with full conversation history intact. How It Works \u00b6 Amplifier finds your most recent session in the current directory Loads the complete conversation history Restores the session state You can continue the conversation seamlessly Typical Workflow \u00b6 # Morning: Start working amplifier run \"Let's build the user dashboard\" # ... work for a while, then close terminal ... # Afternoon: Pick up where you left off amplifier continue Session Context \u00b6 When you continue a session: All previous messages are available File changes made during the session are remembered The AI retains context about what you were working on You can reference earlier parts of the conversation With Additional Prompt \u00b6 Resume and immediately send a new message: amplifier continue \"Now let's add the export feature we discussed\" Directory Matters \u00b6 continue looks for sessions started in your current directory: cd my-project amplifier continue # Continues last session in my-project cd other-project amplifier continue # Continues last session in other-project amplifier resume \u00b6 The resume command lets you choose from your session history. Use this when you need to return to an older session or switch between projects. Basic Usage \u00b6 amplifier resume This displays an interactive session picker showing recent sessions. Session List \u00b6 The picker shows: Session start time Working directory First message or topic Session duration Navigate with arrow keys and press Enter to select. Resume by ID \u00b6 If you know the session ID, resume directly: amplifier resume abc123 Session IDs are shown in the session picker and in session logs. Filtering Sessions \u00b6 Find sessions more easily: # Show more sessions amplifier resume --limit 20 # Filter by directory amplifier resume --cwd ~/projects/api When to Use Resume vs Continue \u00b6 Scenario Command Return to what you were just doing continue Switch to a different project's session resume Find a session from earlier today resume Access a session from a different directory resume Slash Commands \u00b6 During an active session, use slash commands for quick actions. /help \u00b6 Display available commands and usage information: /help Shows: - All available slash commands - Brief description of each - Usage examples /compact \u00b6 Compress the conversation to save context space: /compact This summarizes earlier messages while preserving important context. Use when: The conversation is getting long You're hitting context limits You want to focus on recent work After compacting: - Key decisions and context are preserved - Detailed earlier messages are summarized - You have more room for new conversation /tools \u00b6 List available tools in the current session: /tools Shows all tools the AI can use, including: - File operations (read, write, edit) - Search tools (grep, glob) - Shell commands (bash) - Web tools (search, fetch) - Agent delegation (task) Other Useful Commands \u00b6 Command Purpose /status Show session status /clear Clear the screen /exit End the session /undo Undo last action Keyboard Shortcuts \u00b6 While in a session, these shortcuts help navigation: Shortcut Action Ctrl+C Cancel current operation Ctrl+D End session (EOF) Up/Down Navigate input history Tab Auto-complete file paths Command Cheat Sheet \u00b6 # === Starting Sessions === amplifier run # New session amplifier run \"prompt\" # New session with initial prompt amplifier run --bundle dev # New session with specific bundle # === Resuming Sessions === amplifier continue # Resume last session amplifier continue \"prompt\" # Resume with new message amplifier resume # Pick from history amplifier resume <id> # Resume specific session # === In-Session Commands === /help # Show help /compact # Compress context /tools # List available tools /exit # End session Troubleshooting \u00b6 \"No session found to continue\" \u00b6 You haven't started a session in this directory yet: # Start a new session instead amplifier run Session won't resume \u00b6 If a session is corrupted or won't load: # Start fresh amplifier run # Or try a different session amplifier resume Context getting too long \u00b6 Use the compact command to summarize: /compact Next Steps \u00b6 Now that you know the key commands: Your First Session - Put these commands into practice Slash Commands Deep Dive - Learn all in-session commands Session Management - Advanced session workflows","title":"Key Commands"},{"location":"quickstart/key-commands.html#key-commands","text":"This reference covers the essential commands you'll use every day with Amplifier. Master these three commands and you'll have complete control over your sessions.","title":"Key Commands"},{"location":"quickstart/key-commands.html#command-overview","text":"Command Purpose When to Use amplifier run Start a new session Beginning fresh work amplifier continue Resume the last session Picking up where you left off amplifier resume Choose from session history Returning to older work","title":"Command Overview"},{"location":"quickstart/key-commands.html#quick-reference","text":"# Start fresh amplifier run # Continue last session amplifier continue # Pick a specific session amplifier resume","title":"Quick Reference"},{"location":"quickstart/key-commands.html#amplifier-run","text":"The run command starts a new Amplifier session in your current directory.","title":"amplifier run"},{"location":"quickstart/key-commands.html#basic-usage","text":"amplifier run This launches an interactive session where you can start working with the AI assistant immediately.","title":"Basic Usage"},{"location":"quickstart/key-commands.html#common-options","text":"# Start with a specific prompt amplifier run \"Explain the architecture of this project\" # Use a specific bundle configuration amplifier run --bundle my-bundle # Start in a different directory amplifier run --cwd /path/to/project # Enable verbose output for debugging amplifier run --verbose","title":"Common Options"},{"location":"quickstart/key-commands.html#with-initial-prompt","text":"Pass your first message directly to skip the initial prompt: amplifier run \"Review the authentication module for security issues\" This immediately starts working on your request without waiting for input.","title":"With Initial Prompt"},{"location":"quickstart/key-commands.html#working-directory","text":"Amplifier runs in your current directory by default. The working directory determines: Which AGENTS.md configuration files are loaded The scope of file operations Git repository context # Run in current directory cd my-project amplifier run # Or specify explicitly amplifier run --cwd ~/projects/my-app","title":"Working Directory"},{"location":"quickstart/key-commands.html#bundle-selection","text":"Bundles define what tools and agents are available: # Use the default foundation bundle amplifier run # Use a specific bundle amplifier run --bundle developer # Use a custom bundle from your project amplifier run --bundle .amplifier/bundles/custom.yaml","title":"Bundle Selection"},{"location":"quickstart/key-commands.html#amplifier-continue","text":"The continue command resumes your most recent session. This is your go-to command when returning to work.","title":"amplifier continue"},{"location":"quickstart/key-commands.html#basic-usage_1","text":"amplifier continue This picks up exactly where you left off, with full conversation history intact.","title":"Basic Usage"},{"location":"quickstart/key-commands.html#how-it-works","text":"Amplifier finds your most recent session in the current directory Loads the complete conversation history Restores the session state You can continue the conversation seamlessly","title":"How It Works"},{"location":"quickstart/key-commands.html#typical-workflow","text":"# Morning: Start working amplifier run \"Let's build the user dashboard\" # ... work for a while, then close terminal ... # Afternoon: Pick up where you left off amplifier continue","title":"Typical Workflow"},{"location":"quickstart/key-commands.html#session-context","text":"When you continue a session: All previous messages are available File changes made during the session are remembered The AI retains context about what you were working on You can reference earlier parts of the conversation","title":"Session Context"},{"location":"quickstart/key-commands.html#with-additional-prompt","text":"Resume and immediately send a new message: amplifier continue \"Now let's add the export feature we discussed\"","title":"With Additional Prompt"},{"location":"quickstart/key-commands.html#directory-matters","text":"continue looks for sessions started in your current directory: cd my-project amplifier continue # Continues last session in my-project cd other-project amplifier continue # Continues last session in other-project","title":"Directory Matters"},{"location":"quickstart/key-commands.html#amplifier-resume","text":"The resume command lets you choose from your session history. Use this when you need to return to an older session or switch between projects.","title":"amplifier resume"},{"location":"quickstart/key-commands.html#basic-usage_2","text":"amplifier resume This displays an interactive session picker showing recent sessions.","title":"Basic Usage"},{"location":"quickstart/key-commands.html#session-list","text":"The picker shows: Session start time Working directory First message or topic Session duration Navigate with arrow keys and press Enter to select.","title":"Session List"},{"location":"quickstart/key-commands.html#resume-by-id","text":"If you know the session ID, resume directly: amplifier resume abc123 Session IDs are shown in the session picker and in session logs.","title":"Resume by ID"},{"location":"quickstart/key-commands.html#filtering-sessions","text":"Find sessions more easily: # Show more sessions amplifier resume --limit 20 # Filter by directory amplifier resume --cwd ~/projects/api","title":"Filtering Sessions"},{"location":"quickstart/key-commands.html#when-to-use-resume-vs-continue","text":"Scenario Command Return to what you were just doing continue Switch to a different project's session resume Find a session from earlier today resume Access a session from a different directory resume","title":"When to Use Resume vs Continue"},{"location":"quickstart/key-commands.html#slash-commands","text":"During an active session, use slash commands for quick actions.","title":"Slash Commands"},{"location":"quickstart/key-commands.html#help","text":"Display available commands and usage information: /help Shows: - All available slash commands - Brief description of each - Usage examples","title":"/help"},{"location":"quickstart/key-commands.html#compact","text":"Compress the conversation to save context space: /compact This summarizes earlier messages while preserving important context. Use when: The conversation is getting long You're hitting context limits You want to focus on recent work After compacting: - Key decisions and context are preserved - Detailed earlier messages are summarized - You have more room for new conversation","title":"/compact"},{"location":"quickstart/key-commands.html#tools","text":"List available tools in the current session: /tools Shows all tools the AI can use, including: - File operations (read, write, edit) - Search tools (grep, glob) - Shell commands (bash) - Web tools (search, fetch) - Agent delegation (task)","title":"/tools"},{"location":"quickstart/key-commands.html#other-useful-commands","text":"Command Purpose /status Show session status /clear Clear the screen /exit End the session /undo Undo last action","title":"Other Useful Commands"},{"location":"quickstart/key-commands.html#keyboard-shortcuts","text":"While in a session, these shortcuts help navigation: Shortcut Action Ctrl+C Cancel current operation Ctrl+D End session (EOF) Up/Down Navigate input history Tab Auto-complete file paths","title":"Keyboard Shortcuts"},{"location":"quickstart/key-commands.html#command-cheat-sheet","text":"# === Starting Sessions === amplifier run # New session amplifier run \"prompt\" # New session with initial prompt amplifier run --bundle dev # New session with specific bundle # === Resuming Sessions === amplifier continue # Resume last session amplifier continue \"prompt\" # Resume with new message amplifier resume # Pick from history amplifier resume <id> # Resume specific session # === In-Session Commands === /help # Show help /compact # Compress context /tools # List available tools /exit # End session","title":"Command Cheat Sheet"},{"location":"quickstart/key-commands.html#troubleshooting","text":"","title":"Troubleshooting"},{"location":"quickstart/key-commands.html#no-session-found-to-continue","text":"You haven't started a session in this directory yet: # Start a new session instead amplifier run","title":"\"No session found to continue\""},{"location":"quickstart/key-commands.html#session-wont-resume","text":"If a session is corrupted or won't load: # Start fresh amplifier run # Or try a different session amplifier resume","title":"Session won't resume"},{"location":"quickstart/key-commands.html#context-getting-too-long","text":"Use the compact command to summarize: /compact","title":"Context getting too long"},{"location":"quickstart/key-commands.html#next-steps","text":"Now that you know the key commands: Your First Session - Put these commands into practice Slash Commands Deep Dive - Learn all in-session commands Session Management - Advanced session workflows","title":"Next Steps"},{"location":"quickstart/what-is-amplifier.html","text":"What is Amplifier? \u00b6 Overview \u00b6 Amplifier is a modular AI agent framework designed to help developers build powerful, composable AI applications. Rather than providing a monolithic solution, Amplifier embraces a \"bricks and studs\" philosophy where self-contained modules snap together to create sophisticated agent systems. At its core, Amplifier provides: A minimal kernel that handles the essential agent loop, session management, and tool execution A module system with well-defined contracts for extending functionality A bundle architecture for packaging and sharing agent configurations Built-in support for multiple LLM providers, tools, and agent patterns Amplifier is built for developers who want full control over their AI agents without drowning in boilerplate or fighting framework constraints. Key Features \u00b6 Modular Architecture \u00b6 Every component in Amplifier is a self-contained module with clear boundaries: \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 Amplifier Kernel \u2502 \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 \u2502 \u2502 Provider \u2502 \u2502 Tools \u2502 \u2502 Hooks \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 \u2502 \u2502 Context \u2502 \u2502 Skills \u2502 \u2502 Agents \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 Modules communicate through stable interfaces, allowing you to: Swap providers (Anthropic, OpenAI, Azure, local models) Add or remove tools without touching other code Create custom hooks for observability and control Package everything into shareable bundles Bundle System \u00b6 Bundles are the primary unit of composition in Amplifier. A bundle packages: Agent definitions and configurations Tool collections for specific capabilities Context files and instructions Skills and domain knowledge # Example bundle structure my-bundle/ \u251c\u2500\u2500 bundle.yaml # Bundle manifest \u251c\u2500\u2500 agents/ # Agent definitions \u251c\u2500\u2500 tools/ # Custom tools \u251c\u2500\u2500 context/ # Instructions and context \u2514\u2500\u2500 skills/ # Domain knowledge Bundles can compose other bundles, enabling a layered architecture where specialized capabilities build on foundational ones. Multi-Agent Support \u00b6 Amplifier supports sophisticated multi-agent patterns: Task delegation : Spawn specialized agents for focused work Parallel execution : Run multiple agents concurrently Agent hierarchies : Build orchestration patterns Session continuity : Resume and branch conversations Rich Tool Ecosystem \u00b6 Built-in tools cover common development needs: File operations (read, write, edit, search) Shell command execution Web search and content fetching Git and GitHub operations LSP integration for code intelligence Custom tools are straightforward to create and package. Session Management \u00b6 Amplifier provides robust session handling: Automatic checkpointing and resumability Event logging for debugging and analysis Context management across long conversations Sub-session spawning for agent delegation Philosophy \u00b6 Amplifier is built on three core principles: 1. Ruthless Simplicity \u00b6 \"The best code is often the simplest.\" Amplifier resists the urge to over-engineer. Every abstraction must justify its existence. The framework provides what's essential and stays out of your way for everything else. This means: Minimal magic and hidden behavior Clear, predictable execution paths Easy-to-understand source code Simple extension patterns 2. Composability Over Configuration \u00b6 Rather than exposing hundreds of configuration options, Amplifier achieves flexibility through composition. Small, focused modules combine to create exactly the agent system you need. Think of it like building blocks: Each block does one thing well Blocks connect through standard interfaces Complex systems emerge from simple parts Any block can be replaced or regenerated 3. AI-Native Development \u00b6 Amplifier embraces the reality that AI is changing how we build software. The framework is designed to work with AI assistants: Modules are sized for AI comprehension Specifications drive implementation Regeneration is preferred over patching Clear contracts enable reliable generation Who It's For \u00b6 AI Application Developers \u00b6 If you're building AI-powered applications and want: Full control over agent behavior Easy integration with multiple providers Extensible tool and capability systems Clean separation of concerns Amplifier provides the foundation without imposing unnecessary constraints. Teams Building Internal Tools \u00b6 For organizations creating internal AI assistants: Package domain knowledge into bundles Define organization-specific tools Control security and access patterns Share capabilities across teams Researchers and Experimenters \u00b6 If you're exploring agent architectures: Easily swap components to test hypotheses Clear extension points for custom behavior Observable execution for analysis Minimal overhead for rapid iteration Open Source Contributors \u00b6 Amplifier's modular design makes contribution straightforward: Work on isolated modules without deep framework knowledge Clear contracts define expected behavior Test modules independently Share bundles with the community Core Concepts \u00b6 Before diving deeper, familiarize yourself with these key terms: Concept Description Kernel The minimal core that runs the agent loop Module A self-contained unit of functionality Bundle A package of agents, tools, and configuration Provider An LLM backend (Anthropic, OpenAI, etc.) Tool A capability the agent can invoke Hook An extension point for observing or modifying behavior Skill Loadable domain knowledge and best practices Session A conversation instance with state and history Agent A configured AI assistant with specific capabilities Next Steps \u00b6 Ready to get started? Here's your path forward: Installation - Set up Amplifier in your environment Your First Agent - Build and run a simple agent Understanding Bundles - Learn the composition model Core Concepts Deep Dive - Explore the architecture Building Tools - Extend agent capabilities Amplifier is open source and actively developed. Join the community to ask questions, share bundles, and contribute to the framework's evolution.","title":"What is Amplifier?"},{"location":"quickstart/what-is-amplifier.html#what-is-amplifier","text":"","title":"What is Amplifier?"},{"location":"quickstart/what-is-amplifier.html#overview","text":"Amplifier is a modular AI agent framework designed to help developers build powerful, composable AI applications. Rather than providing a monolithic solution, Amplifier embraces a \"bricks and studs\" philosophy where self-contained modules snap together to create sophisticated agent systems. At its core, Amplifier provides: A minimal kernel that handles the essential agent loop, session management, and tool execution A module system with well-defined contracts for extending functionality A bundle architecture for packaging and sharing agent configurations Built-in support for multiple LLM providers, tools, and agent patterns Amplifier is built for developers who want full control over their AI agents without drowning in boilerplate or fighting framework constraints.","title":"Overview"},{"location":"quickstart/what-is-amplifier.html#key-features","text":"","title":"Key Features"},{"location":"quickstart/what-is-amplifier.html#modular-architecture","text":"Every component in Amplifier is a self-contained module with clear boundaries: \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 Amplifier Kernel \u2502 \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 \u2502 \u2502 Provider \u2502 \u2502 Tools \u2502 \u2502 Hooks \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 \u2502 \u2502 Context \u2502 \u2502 Skills \u2502 \u2502 Agents \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 Modules communicate through stable interfaces, allowing you to: Swap providers (Anthropic, OpenAI, Azure, local models) Add or remove tools without touching other code Create custom hooks for observability and control Package everything into shareable bundles","title":"Modular Architecture"},{"location":"quickstart/what-is-amplifier.html#bundle-system","text":"Bundles are the primary unit of composition in Amplifier. A bundle packages: Agent definitions and configurations Tool collections for specific capabilities Context files and instructions Skills and domain knowledge # Example bundle structure my-bundle/ \u251c\u2500\u2500 bundle.yaml # Bundle manifest \u251c\u2500\u2500 agents/ # Agent definitions \u251c\u2500\u2500 tools/ # Custom tools \u251c\u2500\u2500 context/ # Instructions and context \u2514\u2500\u2500 skills/ # Domain knowledge Bundles can compose other bundles, enabling a layered architecture where specialized capabilities build on foundational ones.","title":"Bundle System"},{"location":"quickstart/what-is-amplifier.html#multi-agent-support","text":"Amplifier supports sophisticated multi-agent patterns: Task delegation : Spawn specialized agents for focused work Parallel execution : Run multiple agents concurrently Agent hierarchies : Build orchestration patterns Session continuity : Resume and branch conversations","title":"Multi-Agent Support"},{"location":"quickstart/what-is-amplifier.html#rich-tool-ecosystem","text":"Built-in tools cover common development needs: File operations (read, write, edit, search) Shell command execution Web search and content fetching Git and GitHub operations LSP integration for code intelligence Custom tools are straightforward to create and package.","title":"Rich Tool Ecosystem"},{"location":"quickstart/what-is-amplifier.html#session-management","text":"Amplifier provides robust session handling: Automatic checkpointing and resumability Event logging for debugging and analysis Context management across long conversations Sub-session spawning for agent delegation","title":"Session Management"},{"location":"quickstart/what-is-amplifier.html#philosophy","text":"Amplifier is built on three core principles:","title":"Philosophy"},{"location":"quickstart/what-is-amplifier.html#1-ruthless-simplicity","text":"\"The best code is often the simplest.\" Amplifier resists the urge to over-engineer. Every abstraction must justify its existence. The framework provides what's essential and stays out of your way for everything else. This means: Minimal magic and hidden behavior Clear, predictable execution paths Easy-to-understand source code Simple extension patterns","title":"1. Ruthless Simplicity"},{"location":"quickstart/what-is-amplifier.html#2-composability-over-configuration","text":"Rather than exposing hundreds of configuration options, Amplifier achieves flexibility through composition. Small, focused modules combine to create exactly the agent system you need. Think of it like building blocks: Each block does one thing well Blocks connect through standard interfaces Complex systems emerge from simple parts Any block can be replaced or regenerated","title":"2. Composability Over Configuration"},{"location":"quickstart/what-is-amplifier.html#3-ai-native-development","text":"Amplifier embraces the reality that AI is changing how we build software. The framework is designed to work with AI assistants: Modules are sized for AI comprehension Specifications drive implementation Regeneration is preferred over patching Clear contracts enable reliable generation","title":"3. AI-Native Development"},{"location":"quickstart/what-is-amplifier.html#who-its-for","text":"","title":"Who It's For"},{"location":"quickstart/what-is-amplifier.html#ai-application-developers","text":"If you're building AI-powered applications and want: Full control over agent behavior Easy integration with multiple providers Extensible tool and capability systems Clean separation of concerns Amplifier provides the foundation without imposing unnecessary constraints.","title":"AI Application Developers"},{"location":"quickstart/what-is-amplifier.html#teams-building-internal-tools","text":"For organizations creating internal AI assistants: Package domain knowledge into bundles Define organization-specific tools Control security and access patterns Share capabilities across teams","title":"Teams Building Internal Tools"},{"location":"quickstart/what-is-amplifier.html#researchers-and-experimenters","text":"If you're exploring agent architectures: Easily swap components to test hypotheses Clear extension points for custom behavior Observable execution for analysis Minimal overhead for rapid iteration","title":"Researchers and Experimenters"},{"location":"quickstart/what-is-amplifier.html#open-source-contributors","text":"Amplifier's modular design makes contribution straightforward: Work on isolated modules without deep framework knowledge Clear contracts define expected behavior Test modules independently Share bundles with the community","title":"Open Source Contributors"},{"location":"quickstart/what-is-amplifier.html#core-concepts","text":"Before diving deeper, familiarize yourself with these key terms: Concept Description Kernel The minimal core that runs the agent loop Module A self-contained unit of functionality Bundle A package of agents, tools, and configuration Provider An LLM backend (Anthropic, OpenAI, etc.) Tool A capability the agent can invoke Hook An extension point for observing or modifying behavior Skill Loadable domain knowledge and best practices Session A conversation instance with state and history Agent A configured AI assistant with specific capabilities","title":"Core Concepts"},{"location":"quickstart/what-is-amplifier.html#next-steps","text":"Ready to get started? Here's your path forward: Installation - Set up Amplifier in your environment Your First Agent - Build and run a simple agent Understanding Bundles - Learn the composition model Core Concepts Deep Dive - Explore the architecture Building Tools - Extend agent capabilities Amplifier is open source and actively developed. Join the community to ask questions, share bundles, and contribute to the framework's evolution.","title":"Next Steps"},{"location":"skills/index.html","text":"Skills Reference \u00b6 Skills are packages of domain knowledge that agents can load on demand. Unlike context files that are always present, skills provide specialized expertise that's loaded only when relevant. This section covers skill creation, discovery, and effective use patterns. Section Contents \u00b6 Page Description Skill Basics What skills are and how they work Built-in Skills Available skills in the foundation bundle Creating Skills Build your own domain-specific skills Skill Structure Anatomy of a skill package Discovery How agents find and load skills Companion Files Including examples and templates Best Practices Patterns for effective skills Publishing Sharing skills with the community Quick Tips \u00b6 Skills are lazy-loaded \u2014 They only consume context when actually needed One domain per skill \u2014 Keep skills focused on a single area of expertise Include examples \u2014 Companion files with working code help agents apply knowledge Version carefully \u2014 Skills become dependencies; changes affect users Search first \u2014 Use load_skill(search=\"term\") to find relevant skills Skill Architecture \u00b6 skills/ \u2514\u2500\u2500 my-skill/ \u251c\u2500\u2500 skill.yaml # Skill manifest (name, description, version) \u251c\u2500\u2500 skill.md # Main knowledge content \u2514\u2500\u2500 examples/ # Companion files \u251c\u2500\u2500 basic.py \u2514\u2500\u2500 advanced.py Skill Operations \u00b6 Operation Description Example List Show available skills load_skill(list=True) Search Find by name/description load_skill(search=\"python\") Info Get metadata only load_skill(info=\"curl\") Load Load full content load_skill(skill_name=\"curl\") Where to Start \u00b6 New to skills? Begin with Skill Basics to understand the skill system and when to use it. Want to create skills? Follow Creating Skills for a hands-on guide to building your first skill. Looking for existing skills? Check Built-in Skills for what's already available. Built-in Skills Overview \u00b6 Skill Domain Use Case curl HTTP/APIs Testing REST endpoints playwright Browser Web automation and scraping image-vision Vision Analyzing images with LLMs Skill vs Context \u00b6 Aspect Skills Context Files Loading On-demand Always present Scope Specialized domain General guidance Size Can be large Should be concise Updates Versioned Part of bundle Common Patterns \u00b6 # In an agent's workflow: 1. Recognize domain-specific task 2. Search for relevant skill 3. Load skill into context 4. Apply skill knowledge 5. Reference companion files if needed Related Sections \u00b6 Quickstart: Creating Skills Bundles: Context Files Advanced: Skill Development","title":"Overview"},{"location":"skills/index.html#skills-reference","text":"Skills are packages of domain knowledge that agents can load on demand. Unlike context files that are always present, skills provide specialized expertise that's loaded only when relevant. This section covers skill creation, discovery, and effective use patterns.","title":"Skills Reference"},{"location":"skills/index.html#section-contents","text":"Page Description Skill Basics What skills are and how they work Built-in Skills Available skills in the foundation bundle Creating Skills Build your own domain-specific skills Skill Structure Anatomy of a skill package Discovery How agents find and load skills Companion Files Including examples and templates Best Practices Patterns for effective skills Publishing Sharing skills with the community","title":"Section Contents"},{"location":"skills/index.html#quick-tips","text":"Skills are lazy-loaded \u2014 They only consume context when actually needed One domain per skill \u2014 Keep skills focused on a single area of expertise Include examples \u2014 Companion files with working code help agents apply knowledge Version carefully \u2014 Skills become dependencies; changes affect users Search first \u2014 Use load_skill(search=\"term\") to find relevant skills","title":"Quick Tips"},{"location":"skills/index.html#skill-architecture","text":"skills/ \u2514\u2500\u2500 my-skill/ \u251c\u2500\u2500 skill.yaml # Skill manifest (name, description, version) \u251c\u2500\u2500 skill.md # Main knowledge content \u2514\u2500\u2500 examples/ # Companion files \u251c\u2500\u2500 basic.py \u2514\u2500\u2500 advanced.py","title":"Skill Architecture"},{"location":"skills/index.html#skill-operations","text":"Operation Description Example List Show available skills load_skill(list=True) Search Find by name/description load_skill(search=\"python\") Info Get metadata only load_skill(info=\"curl\") Load Load full content load_skill(skill_name=\"curl\")","title":"Skill Operations"},{"location":"skills/index.html#where-to-start","text":"New to skills? Begin with Skill Basics to understand the skill system and when to use it. Want to create skills? Follow Creating Skills for a hands-on guide to building your first skill. Looking for existing skills? Check Built-in Skills for what's already available.","title":"Where to Start"},{"location":"skills/index.html#built-in-skills-overview","text":"Skill Domain Use Case curl HTTP/APIs Testing REST endpoints playwright Browser Web automation and scraping image-vision Vision Analyzing images with LLMs","title":"Built-in Skills Overview"},{"location":"skills/index.html#skill-vs-context","text":"Aspect Skills Context Files Loading On-demand Always present Scope Specialized domain General guidance Size Can be large Should be concise Updates Versioned Part of bundle","title":"Skill vs Context"},{"location":"skills/index.html#common-patterns","text":"# In an agent's workflow: 1. Recognize domain-specific task 2. Search for relevant skill 3. Load skill into context 4. Apply skill knowledge 5. Reference companion files if needed","title":"Common Patterns"},{"location":"skills/index.html#related-sections","text":"Quickstart: Creating Skills Bundles: Context Files Advanced: Skill Development","title":"Related Sections"},{"location":"skills/curl.html","text":"Curl Skill \u00b6 HTTP client for API testing, validation, and debugging. Overview \u00b6 The curl skill teaches Amplifier how to: Test REST APIs Validate responses Debug HTTP requests Send webhooks Handle authentication Loading the Skill \u00b6 > Load the curl skill Once loaded, Amplifier knows HTTP best practices. When to Use \u00b6 Task Use Curl Test API endpoint \u2705 Send webhook \u2705 Debug HTTP issue \u2705 Validate JSON response \u2705 Navigate website \u274c Use playwright Fill web form \u274c Use playwright Core Patterns \u00b6 Basic GET \u00b6 curl https://api.example.com/users POST with JSON \u00b6 curl -X POST https://api.example.com/users \\ -H \"Content-Type: application/json\" \\ -d '{\"name\": \"Alice\", \"email\": \"alice@example.com\"}' With Authentication \u00b6 # Bearer token curl https://api.example.com/me \\ -H \"Authorization: Bearer $TOKEN \" # Basic auth curl -u username:password https://api.example.com/private Show Headers \u00b6 curl -I https://api.example.com/health # Headers only curl -i https://api.example.com/users # Headers + body Verbose Mode \u00b6 curl -v https://api.example.com/debug Response Validation \u00b6 Check Status Code \u00b6 # Get just the status code curl -o /dev/null -s -w \"%{http_code}\" https://api.example.com/health Validate JSON \u00b6 # Pretty print JSON curl https://api.example.com/users | jq . # Extract specific field curl https://api.example.com/users/1 | jq '.name' # Check array length curl https://api.example.com/users | jq 'length' Check Response Time \u00b6 curl -o /dev/null -s -w \"Time: %{time_total}s\\n\" https://api.example.com/ Common Methods \u00b6 GET \u00b6 curl https://api.example.com/resource curl \"https://api.example.com/search?q=term\" POST \u00b6 curl -X POST https://api.example.com/resource \\ -H \"Content-Type: application/json\" \\ -d '{\"key\": \"value\"}' PUT \u00b6 curl -X PUT https://api.example.com/resource/1 \\ -H \"Content-Type: application/json\" \\ -d '{\"name\": \"Updated\"}' DELETE \u00b6 curl -X DELETE https://api.example.com/resource/1 PATCH \u00b6 curl -X PATCH https://api.example.com/resource/1 \\ -H \"Content-Type: application/json\" \\ -d '{\"status\": \"active\"}' Headers \u00b6 Common Headers \u00b6 # Content-Type -H \"Content-Type: application/json\" -H \"Content-Type: application/x-www-form-urlencoded\" # Accept -H \"Accept: application/json\" # Authorization -H \"Authorization: Bearer TOKEN\" -H \"Authorization: Basic BASE64\" # Custom -H \"X-API-Key: your-key\" Multiple Headers \u00b6 curl https://api.example.com/ \\ -H \"Content-Type: application/json\" \\ -H \"Authorization: Bearer $TOKEN \" \\ -H \"Accept: application/json\" File Operations \u00b6 Upload File \u00b6 curl -X POST https://api.example.com/upload \\ -F \"file=@document.pdf\" Download File \u00b6 curl -o output.pdf https://example.com/document.pdf Error Handling \u00b6 Follow Redirects \u00b6 curl -L https://example.com/redirecting-url Retry on Failure \u00b6 curl --retry 3 https://api.example.com/flaky Timeout \u00b6 curl --connect-timeout 5 --max-time 10 https://api.example.com/slow Debugging \u00b6 Verbose Output \u00b6 curl -v https://api.example.com/debug Shows: - DNS resolution - TCP connection - TLS handshake - Request headers - Response headers Trace \u00b6 curl --trace - https://api.example.com/debug Full byte-level trace. Try It Yourself \u00b6 Exercise 1: Test an API \u00b6 > Load curl skill > Test the GitHub API: GET https://api.github.com/users/octocat Exercise 2: POST Request \u00b6 > Send a POST to httpbin.org/post with JSON body {\"test\": \"data\"} Exercise 3: Validate Response \u00b6 > Check if https://api.github.com is returning 200 OK Common Errors \u00b6 \"Connection refused\" \u00b6 Server not running Wrong port Firewall blocking \"SSL certificate problem\" \u00b6 # Skip verification (only for testing!) curl -k https://self-signed.example.com \"401 Unauthorized\" \u00b6 Check authentication header Verify token is valid Check token format Source \u00b6 robotdad/skills/curl/ \u251c\u2500\u2500 SKILL.md # Core patterns \u251c\u2500\u2500 patterns.md # Advanced usage \u2514\u2500\u2500 troubleshooting.md # Common issues","title":"Curl"},{"location":"skills/curl.html#curl-skill","text":"HTTP client for API testing, validation, and debugging.","title":"Curl Skill"},{"location":"skills/curl.html#overview","text":"The curl skill teaches Amplifier how to: Test REST APIs Validate responses Debug HTTP requests Send webhooks Handle authentication","title":"Overview"},{"location":"skills/curl.html#loading-the-skill","text":"> Load the curl skill Once loaded, Amplifier knows HTTP best practices.","title":"Loading the Skill"},{"location":"skills/curl.html#when-to-use","text":"Task Use Curl Test API endpoint \u2705 Send webhook \u2705 Debug HTTP issue \u2705 Validate JSON response \u2705 Navigate website \u274c Use playwright Fill web form \u274c Use playwright","title":"When to Use"},{"location":"skills/curl.html#core-patterns","text":"","title":"Core Patterns"},{"location":"skills/curl.html#basic-get","text":"curl https://api.example.com/users","title":"Basic GET"},{"location":"skills/curl.html#post-with-json","text":"curl -X POST https://api.example.com/users \\ -H \"Content-Type: application/json\" \\ -d '{\"name\": \"Alice\", \"email\": \"alice@example.com\"}'","title":"POST with JSON"},{"location":"skills/curl.html#with-authentication","text":"# Bearer token curl https://api.example.com/me \\ -H \"Authorization: Bearer $TOKEN \" # Basic auth curl -u username:password https://api.example.com/private","title":"With Authentication"},{"location":"skills/curl.html#show-headers","text":"curl -I https://api.example.com/health # Headers only curl -i https://api.example.com/users # Headers + body","title":"Show Headers"},{"location":"skills/curl.html#verbose-mode","text":"curl -v https://api.example.com/debug","title":"Verbose Mode"},{"location":"skills/curl.html#response-validation","text":"","title":"Response Validation"},{"location":"skills/curl.html#check-status-code","text":"# Get just the status code curl -o /dev/null -s -w \"%{http_code}\" https://api.example.com/health","title":"Check Status Code"},{"location":"skills/curl.html#validate-json","text":"# Pretty print JSON curl https://api.example.com/users | jq . # Extract specific field curl https://api.example.com/users/1 | jq '.name' # Check array length curl https://api.example.com/users | jq 'length'","title":"Validate JSON"},{"location":"skills/curl.html#check-response-time","text":"curl -o /dev/null -s -w \"Time: %{time_total}s\\n\" https://api.example.com/","title":"Check Response Time"},{"location":"skills/curl.html#common-methods","text":"","title":"Common Methods"},{"location":"skills/curl.html#get","text":"curl https://api.example.com/resource curl \"https://api.example.com/search?q=term\"","title":"GET"},{"location":"skills/curl.html#post","text":"curl -X POST https://api.example.com/resource \\ -H \"Content-Type: application/json\" \\ -d '{\"key\": \"value\"}'","title":"POST"},{"location":"skills/curl.html#put","text":"curl -X PUT https://api.example.com/resource/1 \\ -H \"Content-Type: application/json\" \\ -d '{\"name\": \"Updated\"}'","title":"PUT"},{"location":"skills/curl.html#delete","text":"curl -X DELETE https://api.example.com/resource/1","title":"DELETE"},{"location":"skills/curl.html#patch","text":"curl -X PATCH https://api.example.com/resource/1 \\ -H \"Content-Type: application/json\" \\ -d '{\"status\": \"active\"}'","title":"PATCH"},{"location":"skills/curl.html#headers","text":"","title":"Headers"},{"location":"skills/curl.html#common-headers","text":"# Content-Type -H \"Content-Type: application/json\" -H \"Content-Type: application/x-www-form-urlencoded\" # Accept -H \"Accept: application/json\" # Authorization -H \"Authorization: Bearer TOKEN\" -H \"Authorization: Basic BASE64\" # Custom -H \"X-API-Key: your-key\"","title":"Common Headers"},{"location":"skills/curl.html#multiple-headers","text":"curl https://api.example.com/ \\ -H \"Content-Type: application/json\" \\ -H \"Authorization: Bearer $TOKEN \" \\ -H \"Accept: application/json\"","title":"Multiple Headers"},{"location":"skills/curl.html#file-operations","text":"","title":"File Operations"},{"location":"skills/curl.html#upload-file","text":"curl -X POST https://api.example.com/upload \\ -F \"file=@document.pdf\"","title":"Upload File"},{"location":"skills/curl.html#download-file","text":"curl -o output.pdf https://example.com/document.pdf","title":"Download File"},{"location":"skills/curl.html#error-handling","text":"","title":"Error Handling"},{"location":"skills/curl.html#follow-redirects","text":"curl -L https://example.com/redirecting-url","title":"Follow Redirects"},{"location":"skills/curl.html#retry-on-failure","text":"curl --retry 3 https://api.example.com/flaky","title":"Retry on Failure"},{"location":"skills/curl.html#timeout","text":"curl --connect-timeout 5 --max-time 10 https://api.example.com/slow","title":"Timeout"},{"location":"skills/curl.html#debugging","text":"","title":"Debugging"},{"location":"skills/curl.html#verbose-output","text":"curl -v https://api.example.com/debug Shows: - DNS resolution - TCP connection - TLS handshake - Request headers - Response headers","title":"Verbose Output"},{"location":"skills/curl.html#trace","text":"curl --trace - https://api.example.com/debug Full byte-level trace.","title":"Trace"},{"location":"skills/curl.html#try-it-yourself","text":"","title":"Try It Yourself"},{"location":"skills/curl.html#exercise-1-test-an-api","text":"> Load curl skill > Test the GitHub API: GET https://api.github.com/users/octocat","title":"Exercise 1: Test an API"},{"location":"skills/curl.html#exercise-2-post-request","text":"> Send a POST to httpbin.org/post with JSON body {\"test\": \"data\"}","title":"Exercise 2: POST Request"},{"location":"skills/curl.html#exercise-3-validate-response","text":"> Check if https://api.github.com is returning 200 OK","title":"Exercise 3: Validate Response"},{"location":"skills/curl.html#common-errors","text":"","title":"Common Errors"},{"location":"skills/curl.html#connection-refused","text":"Server not running Wrong port Firewall blocking","title":"\"Connection refused\""},{"location":"skills/curl.html#ssl-certificate-problem","text":"# Skip verification (only for testing!) curl -k https://self-signed.example.com","title":"\"SSL certificate problem\""},{"location":"skills/curl.html#401-unauthorized","text":"Check authentication header Verify token is valid Check token format","title":"\"401 Unauthorized\""},{"location":"skills/curl.html#source","text":"robotdad/skills/curl/ \u251c\u2500\u2500 SKILL.md # Core patterns \u251c\u2500\u2500 patterns.md # Advanced usage \u2514\u2500\u2500 troubleshooting.md # Common issues","title":"Source"},{"location":"skills/image-vision.html","text":"Image Vision Skill \u00b6 Analyze images using LLM vision APIs. Overview \u00b6 The Image Vision skill teaches Amplifier how to: Understand image content Describe visual elements Answer questions about images Compare multiple images Extract text (OCR) Loading the Skill \u00b6 > Load the image-vision skill Once loaded, Amplifier knows how to work with images. When to Use \u00b6 Task Use Image Vision Describe what's in an image \u2705 Extract text from screenshot \u2705 Compare two images \u2705 Answer questions about image \u2705 Edit or modify images \u274c Different tools Generate images \u274c Different tools Supported Providers \u00b6 Provider Model Vision Capable Anthropic Claude 3+ \u2705 OpenAI GPT-4V, GPT-4o \u2705 Google Gemini Pro Vision \u2705 Azure OpenAI GPT-4V \u2705 Core Patterns \u00b6 Describe Image \u00b6 > What's in this image? [attach: screenshot.png] Extract Text (OCR) \u00b6 > Extract all text from this image [attach: document-scan.png] Answer Questions \u00b6 > How many people are in this photo? [attach: group-photo.jpg] Compare Images \u00b6 > What's different between these two screenshots? [attach: before.png] [attach: after.png] Image Sources \u00b6 Local Files \u00b6 > Analyze the image at ./screenshots/error.png URLs \u00b6 > Describe the image at https://example.com/photo.jpg Base64 \u00b6 For programmatic use: import base64 with open ( \"image.png\" , \"rb\" ) as f : image_data = base64 . b64encode ( f . read ()) . decode () # Include in prompt with data URI Best Practices \u00b6 Be Specific \u00b6 # Vague > What's this? # Specific > What error message is shown in this screenshot? Provide Context \u00b6 > This is a screenshot of our checkout page. > Is the \"Complete Purchase\" button visible? Ask Focused Questions \u00b6 # Too broad > Tell me everything about this image # Focused > What color is the submit button in this form? Common Tasks \u00b6 UI Validation \u00b6 > Does this screenshot show a successful login? > Is the error message displayed in red? > Are all form fields filled in? Content Understanding \u00b6 > What products are shown in this catalog image? > Summarize the key points from this infographic > What's the main headline on this webpage? Data Extraction \u00b6 > Extract the table data from this spreadsheet screenshot > What are the values in the pie chart? > Read the receipt amounts from this photo Comparison \u00b6 > Has the layout changed between these two versions? > What elements are missing in the second screenshot? > Which design looks more professional? Limitations \u00b6 Cannot Do \u00b6 Edit or modify images Generate new images Process video (frame by frame only) Guarantee 100% accurate OCR Image Size \u00b6 Large images may be resized. For text extraction: - Use highest resolution available - Ensure text is readable at smaller sizes Complex Documents \u00b6 For complex documents with many elements: - Ask about specific sections - Break into multiple queries Try It Yourself \u00b6 Exercise 1: Describe Image \u00b6 > Load image-vision skill > Describe what you see at https://picsum.photos/800/600 Exercise 2: Extract Text \u00b6 Take a screenshot of any webpage and ask: > Extract the main heading from this screenshot Exercise 3: Compare \u00b6 Take two screenshots and ask: > What changed between these two screenshots? Provider Configuration \u00b6 Ensure your provider supports vision: providers : - module : provider-anthropic config : model : claude-sonnet-4-20250514 # Supports vision Troubleshooting \u00b6 \"Vision not supported\" \u00b6 Check model supports vision Update to vision-capable model \"Image too large\" \u00b6 Reduce image resolution Crop to relevant area \"Cannot read text\" \u00b6 Improve image quality Increase contrast Try different angle/lighting Source \u00b6 robotdad/skills/image-vision/ \u251c\u2500\u2500 SKILL.md # Core workflow \u251c\u2500\u2500 patterns.md # Advanced patterns \u2514\u2500\u2500 setup.md # Provider setup","title":"Image Vision"},{"location":"skills/image-vision.html#image-vision-skill","text":"Analyze images using LLM vision APIs.","title":"Image Vision Skill"},{"location":"skills/image-vision.html#overview","text":"The Image Vision skill teaches Amplifier how to: Understand image content Describe visual elements Answer questions about images Compare multiple images Extract text (OCR)","title":"Overview"},{"location":"skills/image-vision.html#loading-the-skill","text":"> Load the image-vision skill Once loaded, Amplifier knows how to work with images.","title":"Loading the Skill"},{"location":"skills/image-vision.html#when-to-use","text":"Task Use Image Vision Describe what's in an image \u2705 Extract text from screenshot \u2705 Compare two images \u2705 Answer questions about image \u2705 Edit or modify images \u274c Different tools Generate images \u274c Different tools","title":"When to Use"},{"location":"skills/image-vision.html#supported-providers","text":"Provider Model Vision Capable Anthropic Claude 3+ \u2705 OpenAI GPT-4V, GPT-4o \u2705 Google Gemini Pro Vision \u2705 Azure OpenAI GPT-4V \u2705","title":"Supported Providers"},{"location":"skills/image-vision.html#core-patterns","text":"","title":"Core Patterns"},{"location":"skills/image-vision.html#describe-image","text":"> What's in this image? [attach: screenshot.png]","title":"Describe Image"},{"location":"skills/image-vision.html#extract-text-ocr","text":"> Extract all text from this image [attach: document-scan.png]","title":"Extract Text (OCR)"},{"location":"skills/image-vision.html#answer-questions","text":"> How many people are in this photo? [attach: group-photo.jpg]","title":"Answer Questions"},{"location":"skills/image-vision.html#compare-images","text":"> What's different between these two screenshots? [attach: before.png] [attach: after.png]","title":"Compare Images"},{"location":"skills/image-vision.html#image-sources","text":"","title":"Image Sources"},{"location":"skills/image-vision.html#local-files","text":"> Analyze the image at ./screenshots/error.png","title":"Local Files"},{"location":"skills/image-vision.html#urls","text":"> Describe the image at https://example.com/photo.jpg","title":"URLs"},{"location":"skills/image-vision.html#base64","text":"For programmatic use: import base64 with open ( \"image.png\" , \"rb\" ) as f : image_data = base64 . b64encode ( f . read ()) . decode () # Include in prompt with data URI","title":"Base64"},{"location":"skills/image-vision.html#best-practices","text":"","title":"Best Practices"},{"location":"skills/image-vision.html#be-specific","text":"# Vague > What's this? # Specific > What error message is shown in this screenshot?","title":"Be Specific"},{"location":"skills/image-vision.html#provide-context","text":"> This is a screenshot of our checkout page. > Is the \"Complete Purchase\" button visible?","title":"Provide Context"},{"location":"skills/image-vision.html#ask-focused-questions","text":"# Too broad > Tell me everything about this image # Focused > What color is the submit button in this form?","title":"Ask Focused Questions"},{"location":"skills/image-vision.html#common-tasks","text":"","title":"Common Tasks"},{"location":"skills/image-vision.html#ui-validation","text":"> Does this screenshot show a successful login? > Is the error message displayed in red? > Are all form fields filled in?","title":"UI Validation"},{"location":"skills/image-vision.html#content-understanding","text":"> What products are shown in this catalog image? > Summarize the key points from this infographic > What's the main headline on this webpage?","title":"Content Understanding"},{"location":"skills/image-vision.html#data-extraction","text":"> Extract the table data from this spreadsheet screenshot > What are the values in the pie chart? > Read the receipt amounts from this photo","title":"Data Extraction"},{"location":"skills/image-vision.html#comparison","text":"> Has the layout changed between these two versions? > What elements are missing in the second screenshot? > Which design looks more professional?","title":"Comparison"},{"location":"skills/image-vision.html#limitations","text":"","title":"Limitations"},{"location":"skills/image-vision.html#cannot-do","text":"Edit or modify images Generate new images Process video (frame by frame only) Guarantee 100% accurate OCR","title":"Cannot Do"},{"location":"skills/image-vision.html#image-size","text":"Large images may be resized. For text extraction: - Use highest resolution available - Ensure text is readable at smaller sizes","title":"Image Size"},{"location":"skills/image-vision.html#complex-documents","text":"For complex documents with many elements: - Ask about specific sections - Break into multiple queries","title":"Complex Documents"},{"location":"skills/image-vision.html#try-it-yourself","text":"","title":"Try It Yourself"},{"location":"skills/image-vision.html#exercise-1-describe-image","text":"> Load image-vision skill > Describe what you see at https://picsum.photos/800/600","title":"Exercise 1: Describe Image"},{"location":"skills/image-vision.html#exercise-2-extract-text","text":"Take a screenshot of any webpage and ask: > Extract the main heading from this screenshot","title":"Exercise 2: Extract Text"},{"location":"skills/image-vision.html#exercise-3-compare","text":"Take two screenshots and ask: > What changed between these two screenshots?","title":"Exercise 3: Compare"},{"location":"skills/image-vision.html#provider-configuration","text":"Ensure your provider supports vision: providers : - module : provider-anthropic config : model : claude-sonnet-4-20250514 # Supports vision","title":"Provider Configuration"},{"location":"skills/image-vision.html#troubleshooting","text":"","title":"Troubleshooting"},{"location":"skills/image-vision.html#vision-not-supported","text":"Check model supports vision Update to vision-capable model","title":"\"Vision not supported\""},{"location":"skills/image-vision.html#image-too-large","text":"Reduce image resolution Crop to relevant area","title":"\"Image too large\""},{"location":"skills/image-vision.html#cannot-read-text","text":"Improve image quality Increase contrast Try different angle/lighting","title":"\"Cannot read text\""},{"location":"skills/image-vision.html#source","text":"robotdad/skills/image-vision/ \u251c\u2500\u2500 SKILL.md # Core workflow \u251c\u2500\u2500 patterns.md # Advanced patterns \u2514\u2500\u2500 setup.md # Provider setup","title":"Source"},{"location":"skills/playwright.html","text":"Playwright Skill \u00b6 Browser automation for testing, validation, and web interaction. Overview \u00b6 The Playwright skill teaches Amplifier how to: Navigate websites Fill forms and click elements Extract data from pages Capture screenshots Run headless (no visible browser) Loading the Skill \u00b6 > Load the playwright skill Once loaded, Amplifier knows browser automation best practices. When to Use \u00b6 Task Use Playwright Test a login flow \u2705 Capture page screenshot \u2705 Fill and submit forms \u2705 Extract data from pages \u2705 Test REST API \u274c Use curl Fetch static content \u274c Use web_fetch Core Workflow \u00b6 The skill teaches this decision flow: START \u251c\u2500\u2500 Check if Playwright installed \u2502 \u2514\u2500\u2500 No \u2192 Run setup \u251c\u2500\u2500 Determine task type \u2502 \u251c\u2500\u2500 Screenshot \u2192 Capture flow \u2502 \u251c\u2500\u2500 Form fill \u2192 Interaction flow \u2502 \u251c\u2500\u2500 Scraping \u2192 Extraction flow \u2502 \u2514\u2500\u2500 Testing \u2192 Validation flow \u2514\u2500\u2500 Execute with best practices \u251c\u2500\u2500 Headless mode (default) \u251c\u2500\u2500 Role-based selectors \u251c\u2500\u2500 Explicit waits \u2514\u2500\u2500 Diagnostic capture Key Patterns \u00b6 Headless First \u00b6 Always run without visible browser: browser = playwright . chromium . launch ( headless = True ) This ensures: - No focus stealing - Works in CI/CD - Faster execution Role-Based Selectors \u00b6 Prefer accessibility selectors: # Good - role-based page . get_by_role ( \"button\" , name = \"Submit\" ) page . get_by_label ( \"Email\" ) page . get_by_placeholder ( \"Enter password\" ) # Avoid - fragile page . locator ( \".btn-primary\" ) page . locator ( \"#email-input\" ) Explicit Waits \u00b6 Wait for specific conditions: # Wait for element page . wait_for_selector ( \"[data-loaded='true']\" ) # Wait for navigation page . wait_for_url ( \"**/dashboard\" ) # Wait for network idle page . wait_for_load_state ( \"networkidle\" ) Diagnostic Capture \u00b6 On failure, capture context: try : # Test steps except Exception as e : page . screenshot ( path = \"failure.png\" ) print ( page . content ()) raise Examples \u00b6 Take Screenshot \u00b6 > Take a screenshot of https://example.com from playwright.sync_api import sync_playwright with sync_playwright () as p : browser = p . chromium . launch ( headless = True ) page = browser . new_page () page . goto ( \"https://example.com\" ) page . screenshot ( path = \"screenshot.png\" ) browser . close () Login Flow \u00b6 > Test logging into the admin panel from playwright.sync_api import sync_playwright with sync_playwright () as p : browser = p . chromium . launch ( headless = True ) page = browser . new_page () # Navigate page . goto ( \"https://example.com/login\" ) # Fill form page . get_by_label ( \"Email\" ) . fill ( \"admin@example.com\" ) page . get_by_label ( \"Password\" ) . fill ( \"password123\" ) # Submit page . get_by_role ( \"button\" , name = \"Sign in\" ) . click () # Verify success page . wait_for_url ( \"**/dashboard\" ) assert \"Dashboard\" in page . title () browser . close () Extract Data \u00b6 > Get all product prices from the catalog page from playwright.sync_api import sync_playwright with sync_playwright () as p : browser = p . chromium . launch ( headless = True ) page = browser . new_page () page . goto ( \"https://example.com/products\" ) # Extract prices prices = page . locator ( \".product-price\" ) . all_text_contents () for price in prices : print ( price ) browser . close () Setup \u00b6 If Playwright isn't installed: # Install package pip install playwright # Install browsers playwright install chromium Troubleshooting \u00b6 \"Browser not found\" \u00b6 playwright install chromium \"Element not found\" \u00b6 Check selector syntax Add explicit wait Verify element exists in page \"Timeout\" \u00b6 # Increase timeout page . wait_for_selector ( \".element\" , timeout = 10000 ) # 10 seconds Debugging \u00b6 Run with visible browser: browser = p . chromium . launch ( headless = False , slow_mo = 500 ) Anti-patterns \u00b6 The skill warns against: Visible browser mode - Use headless Arbitrary sleeps - Use explicit waits CSS selectors first - Use role-based No error capture - Always capture diagnostics Try It Yourself \u00b6 Exercise 1: Screenshot \u00b6 > Load playwright skill > Take a screenshot of https://github.com Exercise 2: Form Test \u00b6 > Test the search functionality on https://duckduckgo.com Exercise 3: Data Extraction \u00b6 > Extract all headlines from https://news.ycombinator.com Source \u00b6 robotdad/skills/playwright/ \u251c\u2500\u2500 SKILL.md # Core workflow \u251c\u2500\u2500 patterns.md # Advanced patterns \u251c\u2500\u2500 setup.md # Installation \u2514\u2500\u2500 troubleshooting.md # Common issues","title":"Playwright"},{"location":"skills/playwright.html#playwright-skill","text":"Browser automation for testing, validation, and web interaction.","title":"Playwright Skill"},{"location":"skills/playwright.html#overview","text":"The Playwright skill teaches Amplifier how to: Navigate websites Fill forms and click elements Extract data from pages Capture screenshots Run headless (no visible browser)","title":"Overview"},{"location":"skills/playwright.html#loading-the-skill","text":"> Load the playwright skill Once loaded, Amplifier knows browser automation best practices.","title":"Loading the Skill"},{"location":"skills/playwright.html#when-to-use","text":"Task Use Playwright Test a login flow \u2705 Capture page screenshot \u2705 Fill and submit forms \u2705 Extract data from pages \u2705 Test REST API \u274c Use curl Fetch static content \u274c Use web_fetch","title":"When to Use"},{"location":"skills/playwright.html#core-workflow","text":"The skill teaches this decision flow: START \u251c\u2500\u2500 Check if Playwright installed \u2502 \u2514\u2500\u2500 No \u2192 Run setup \u251c\u2500\u2500 Determine task type \u2502 \u251c\u2500\u2500 Screenshot \u2192 Capture flow \u2502 \u251c\u2500\u2500 Form fill \u2192 Interaction flow \u2502 \u251c\u2500\u2500 Scraping \u2192 Extraction flow \u2502 \u2514\u2500\u2500 Testing \u2192 Validation flow \u2514\u2500\u2500 Execute with best practices \u251c\u2500\u2500 Headless mode (default) \u251c\u2500\u2500 Role-based selectors \u251c\u2500\u2500 Explicit waits \u2514\u2500\u2500 Diagnostic capture","title":"Core Workflow"},{"location":"skills/playwright.html#key-patterns","text":"","title":"Key Patterns"},{"location":"skills/playwright.html#headless-first","text":"Always run without visible browser: browser = playwright . chromium . launch ( headless = True ) This ensures: - No focus stealing - Works in CI/CD - Faster execution","title":"Headless First"},{"location":"skills/playwright.html#role-based-selectors","text":"Prefer accessibility selectors: # Good - role-based page . get_by_role ( \"button\" , name = \"Submit\" ) page . get_by_label ( \"Email\" ) page . get_by_placeholder ( \"Enter password\" ) # Avoid - fragile page . locator ( \".btn-primary\" ) page . locator ( \"#email-input\" )","title":"Role-Based Selectors"},{"location":"skills/playwright.html#explicit-waits","text":"Wait for specific conditions: # Wait for element page . wait_for_selector ( \"[data-loaded='true']\" ) # Wait for navigation page . wait_for_url ( \"**/dashboard\" ) # Wait for network idle page . wait_for_load_state ( \"networkidle\" )","title":"Explicit Waits"},{"location":"skills/playwright.html#diagnostic-capture","text":"On failure, capture context: try : # Test steps except Exception as e : page . screenshot ( path = \"failure.png\" ) print ( page . content ()) raise","title":"Diagnostic Capture"},{"location":"skills/playwright.html#examples","text":"","title":"Examples"},{"location":"skills/playwright.html#take-screenshot","text":"> Take a screenshot of https://example.com from playwright.sync_api import sync_playwright with sync_playwright () as p : browser = p . chromium . launch ( headless = True ) page = browser . new_page () page . goto ( \"https://example.com\" ) page . screenshot ( path = \"screenshot.png\" ) browser . close ()","title":"Take Screenshot"},{"location":"skills/playwright.html#login-flow","text":"> Test logging into the admin panel from playwright.sync_api import sync_playwright with sync_playwright () as p : browser = p . chromium . launch ( headless = True ) page = browser . new_page () # Navigate page . goto ( \"https://example.com/login\" ) # Fill form page . get_by_label ( \"Email\" ) . fill ( \"admin@example.com\" ) page . get_by_label ( \"Password\" ) . fill ( \"password123\" ) # Submit page . get_by_role ( \"button\" , name = \"Sign in\" ) . click () # Verify success page . wait_for_url ( \"**/dashboard\" ) assert \"Dashboard\" in page . title () browser . close ()","title":"Login Flow"},{"location":"skills/playwright.html#extract-data","text":"> Get all product prices from the catalog page from playwright.sync_api import sync_playwright with sync_playwright () as p : browser = p . chromium . launch ( headless = True ) page = browser . new_page () page . goto ( \"https://example.com/products\" ) # Extract prices prices = page . locator ( \".product-price\" ) . all_text_contents () for price in prices : print ( price ) browser . close ()","title":"Extract Data"},{"location":"skills/playwright.html#setup","text":"If Playwright isn't installed: # Install package pip install playwright # Install browsers playwright install chromium","title":"Setup"},{"location":"skills/playwright.html#troubleshooting","text":"","title":"Troubleshooting"},{"location":"skills/playwright.html#browser-not-found","text":"playwright install chromium","title":"\"Browser not found\""},{"location":"skills/playwright.html#element-not-found","text":"Check selector syntax Add explicit wait Verify element exists in page","title":"\"Element not found\""},{"location":"skills/playwright.html#timeout","text":"# Increase timeout page . wait_for_selector ( \".element\" , timeout = 10000 ) # 10 seconds","title":"\"Timeout\""},{"location":"skills/playwright.html#debugging","text":"Run with visible browser: browser = p . chromium . launch ( headless = False , slow_mo = 500 )","title":"Debugging"},{"location":"skills/playwright.html#anti-patterns","text":"The skill warns against: Visible browser mode - Use headless Arbitrary sleeps - Use explicit waits CSS selectors first - Use role-based No error capture - Always capture diagnostics","title":"Anti-patterns"},{"location":"skills/playwright.html#try-it-yourself","text":"","title":"Try It Yourself"},{"location":"skills/playwright.html#exercise-1-screenshot","text":"> Load playwright skill > Take a screenshot of https://github.com","title":"Exercise 1: Screenshot"},{"location":"skills/playwright.html#exercise-2-form-test","text":"> Test the search functionality on https://duckduckgo.com","title":"Exercise 2: Form Test"},{"location":"skills/playwright.html#exercise-3-data-extraction","text":"> Extract all headlines from https://news.ycombinator.com","title":"Exercise 3: Data Extraction"},{"location":"skills/playwright.html#source","text":"robotdad/skills/playwright/ \u251c\u2500\u2500 SKILL.md # Core workflow \u251c\u2500\u2500 patterns.md # Advanced patterns \u251c\u2500\u2500 setup.md # Installation \u2514\u2500\u2500 troubleshooting.md # Common issues","title":"Source"},{"location":"tools/index.html","text":"Tools Reference \u00b6 Tools are the primary way Amplifier agents interact with the world. Each tool provides a specific capability\u2014from reading files to executing commands to searching the web. Understanding tools is essential for building effective agents. This section covers all built-in tools, their parameters, and best practices for tool usage. Section Contents \u00b6 Page Description File Operations Reading, writing, and editing files Search Tools Grep, glob, and content discovery Shell Execution Running bash commands safely Web Tools Fetching URLs and web search LSP Integration Language Server Protocol for code intelligence Task Delegation Spawning sub-agents for complex work Todo Management Tracking multi-step tasks Custom Tools Creating your own tools Quick Tips \u00b6 Prefer specialized tools over bash \u2014 Use read_file instead of cat , edit_file instead of sed Parallel calls \u2014 Independent tool calls can be made simultaneously for efficiency Error handling \u2014 Tools return structured errors; always check for failure conditions Context limits \u2014 Large file reads are automatically truncated; use pagination for big files LSP vs grep \u2014 Use LSP for semantic code understanding, grep for text pattern matching Tool Categories \u00b6 Category Tools Use Case File I/O read_file, write_file, edit_file Direct file manipulation Search grep, glob Finding files and content Execution bash System commands and scripts Web web_fetch, web_search External information Code Intel LSP operations Semantic code navigation Orchestration task, todo Multi-step coordination Where to Start \u00b6 New to Amplifier? Begin with File Operations \u2014 it's the most commonly used tool and establishes patterns you'll use everywhere. Building agents? Jump to Task Delegation to understand how agents can spawn sub-agents for complex workflows. Coming from other AI tools? Check Shell Execution to understand Amplifier's safety guardrails and execution model. Common Patterns \u00b6 # Reading before editing (required pattern) 1. read_file \u2192 understand current content 2. edit_file \u2192 make precise changes # Search then navigate 1. grep \u2192 find relevant files 2. read_file \u2192 examine matches 3. LSP \u2192 understand code structure Related Sections \u00b6 Concepts: Tool Architecture Advanced: Custom Tool Development Bundles: Tool Bundles","title":"Overview"},{"location":"tools/index.html#tools-reference","text":"Tools are the primary way Amplifier agents interact with the world. Each tool provides a specific capability\u2014from reading files to executing commands to searching the web. Understanding tools is essential for building effective agents. This section covers all built-in tools, their parameters, and best practices for tool usage.","title":"Tools Reference"},{"location":"tools/index.html#section-contents","text":"Page Description File Operations Reading, writing, and editing files Search Tools Grep, glob, and content discovery Shell Execution Running bash commands safely Web Tools Fetching URLs and web search LSP Integration Language Server Protocol for code intelligence Task Delegation Spawning sub-agents for complex work Todo Management Tracking multi-step tasks Custom Tools Creating your own tools","title":"Section Contents"},{"location":"tools/index.html#quick-tips","text":"Prefer specialized tools over bash \u2014 Use read_file instead of cat , edit_file instead of sed Parallel calls \u2014 Independent tool calls can be made simultaneously for efficiency Error handling \u2014 Tools return structured errors; always check for failure conditions Context limits \u2014 Large file reads are automatically truncated; use pagination for big files LSP vs grep \u2014 Use LSP for semantic code understanding, grep for text pattern matching","title":"Quick Tips"},{"location":"tools/index.html#tool-categories","text":"Category Tools Use Case File I/O read_file, write_file, edit_file Direct file manipulation Search grep, glob Finding files and content Execution bash System commands and scripts Web web_fetch, web_search External information Code Intel LSP operations Semantic code navigation Orchestration task, todo Multi-step coordination","title":"Tool Categories"},{"location":"tools/index.html#where-to-start","text":"New to Amplifier? Begin with File Operations \u2014 it's the most commonly used tool and establishes patterns you'll use everywhere. Building agents? Jump to Task Delegation to understand how agents can spawn sub-agents for complex workflows. Coming from other AI tools? Check Shell Execution to understand Amplifier's safety guardrails and execution model.","title":"Where to Start"},{"location":"tools/index.html#common-patterns","text":"# Reading before editing (required pattern) 1. read_file \u2192 understand current content 2. edit_file \u2192 make precise changes # Search then navigate 1. grep \u2192 find relevant files 2. read_file \u2192 examine matches 3. LSP \u2192 understand code structure","title":"Common Patterns"},{"location":"tools/index.html#related-sections","text":"Concepts: Tool Architecture Advanced: Custom Tool Development Bundles: Tool Bundles","title":"Related Sections"},{"location":"tools/bash.html","text":"Bash Tool \u00b6 The Bash tool provides direct shell command execution, giving you access to your system's full command-line capabilities. This is your gateway to build systems, package managers, version control, and any other terminal operation. While specialized tools exist for many tasks, bash serves as the universal fallback when you need raw shell power. Operations \u00b6 Operation Purpose Example Run command Execute shell command synchronously pytest tests/ Background Start long-running process npm run dev Chain commands Run dependent operations mkdir build && cd build && cmake .. Pipeline Process output through filters cat log.txt \\| grep ERROR Redirect Save output to file npm test > results.txt 2>&1 Basic Usage \u00b6 Interactive Prompt Format \u00b6 Using the > prompt in conversation: > pytest tests/unit/ > npm install express > git status Tool Call Format \u00b6 How Amplifier executes bash internally: [Tool: bash] command: pytest tests/unit/ [Tool: bash] command: npm install express Background Process Format \u00b6 For long-running processes that shouldn't block: [Tool: bash] command: npm run dev run_in_background: true Common Commands \u00b6 Build Commands \u00b6 # Python > pip install -e . > python setup.py build > poetry build # Node.js > npm install > npm run build > yarn build # Rust > cargo build > cargo build --release # Go > go build ./... > go build -o myapp main.go # Make > make > make clean && make all Test Commands \u00b6 # Python > pytest > pytest tests/unit/ -v > pytest --cov = src tests/ > python -m unittest discover # Node.js > npm test > npm run test:unit > jest --coverage # Rust > cargo test > cargo test -- --nocapture # Go > go test ./... > go test -v -cover ./... Git Commands \u00b6 # Status and info > git status > git log --oneline -10 > git diff > git branch -a # Staging and commits > git add . > git commit -m \"Fix authentication bug\" > git push origin main # Branching > git checkout -b feature/new-login > git merge develop > git rebase main Package Management \u00b6 # Python (pip) > pip install requests > pip install -r requirements.txt > pip freeze > requirements.txt # Python (poetry) > poetry add pandas > poetry install > poetry update # Node.js (npm) > npm install lodash > npm install --save-dev jest > npm update # Node.js (yarn) > yarn add axios > yarn add -D typescript # System (apt) > sudo apt update > sudo apt install jq Container Operations \u00b6 # Docker > docker build -t myapp . > docker run -p 8080 :8080 myapp > docker-compose up -d > docker ps > docker logs container_name # Kubernetes > kubectl get pods > kubectl apply -f deployment.yaml > kubectl logs pod-name GitHub CLI \u00b6 # Pull requests > gh pr create --title \"Add feature\" --body \"Description\" > gh pr list > gh pr checkout 123 > gh pr merge 123 # Issues > gh issue create --title \"Bug report\" > gh issue list --state open > gh issue close 42 Background Processes \u00b6 Use run_in_background: true for processes that run continuously: Development Servers \u00b6 [Tool: bash] command: npm run dev run_in_background: true [Tool: bash] command: python -m http.server 8000 run_in_background: true [Tool: bash] command: cargo watch -x run run_in_background: true File Watchers \u00b6 [Tool: bash] command: npm run watch run_in_background: true What Happens with Background Processes \u00b6 The command starts in a separate process Amplifier returns immediately with the process ID (PID) The process continues running independently Output is not captured in the response When to Use Background Mode \u00b6 Scenario Use Background? Dev server ( npm run dev ) Yes File watcher Yes Running tests No Building project No Git operations No Installing packages No Safety Features \u00b6 Blocked Commands \u00b6 Dangerous commands are automatically blocked to prevent accidents: # These will be rejected: > rm -rf / > sudo rm -rf /* > dd if = /dev/zero of = /dev/sda > mkfs.ext4 /dev/sda1 Interactive Commands Not Supported \u00b6 Commands requiring user input will fail: # These won't work: > vim file.txt # Requires interactive editor > ssh user@host # May require password input > mysql -u root -p # Prompts for password > python # Interactive REPL Output Truncation \u00b6 Long outputs are automatically truncated to prevent context overflow: First portion of output is shown [...truncated...] marker appears Final portion of output is shown Byte counts indicate total size Warning: Truncation may break JSON, XML, or other structured output. For large structured data: # Redirect to file instead > npm test --json > test-results.json # Then read portions as needed using read_file Timeouts \u00b6 Commands have execution time limits. Long-running commands should use background mode or be broken into smaller operations. Best Practices \u00b6 1. Use Absolute Paths \u00b6 Maintain clear working directory context: # Preferred > pytest /home/user/project/tests/ # Instead of > cd /home/user/project && pytest tests/ 2. Quote Paths with Spaces \u00b6 # Correct > cd \"/path/with spaces/project\" # Will fail > cd /path/with spaces/project 3. Chain Dependent Commands \u00b6 Use && to run commands only if previous succeeds: > mkdir -p build && cd build && cmake .. && make 4. Prefer Specialized Tools \u00b6 Use bash as a fallback, not first choice: Task Use Instead Read file read_file tool Edit file edit_file tool Find files glob tool Search content grep tool 5. Capture Important Output \u00b6 For output you need to process later: > command > output.txt 2 > & 1 6. Check Exit Status \u00b6 Chain with && to stop on failure: > npm install && npm test && npm run build Try It Yourself \u00b6 Exercise 1: Basic Commands \u00b6 Try running these commands: > echo \"Hello from bash\" > pwd > ls -la > date Exercise 2: Project Setup \u00b6 Initialize a new project: > mkdir -p /tmp/demo-project > cd /tmp/demo-project && git init > echo \"# Demo Project\" > README.md > git add . && git commit -m \"Initial commit\" Exercise 3: Background Server \u00b6 Start a simple server in background: [Tool: bash] command: cd /tmp/demo-project && python -m http.server 8080 run_in_background: true Then verify it's running: > curl http://localhost:8080 Exercise 4: Build and Test \u00b6 Run a typical development workflow: > pip install pytest > pytest --version Errors and Troubleshooting \u00b6 Command Not Found \u00b6 bash: npm: command not found Solution: The command isn't in PATH. Install the required tool or use full path. Permission Denied \u00b6 bash: ./script.sh: Permission denied Solution: Make the script executable: > chmod +x ./script.sh No Such File or Directory \u00b6 bash: cd: /nonexistent/path: No such file or directory Solution: Verify the path exists. Use ls or glob to find correct path. Interactive Command Fails \u00b6 Error: Command requires interactive input Solution: Use non-interactive flags: # Instead of: git commit > git commit -m \"message\" # Instead of: npm init > npm init -y Output Too Large \u00b6 [Output truncated - 1.2MB total] Solution: Redirect to file and read portions: > long-command > output.txt # Then use read_file with offset/limit Timeout Exceeded \u00b6 Error: Command timed out after 60 seconds Solution: Use background mode for long-running processes, or break into smaller operations. Blocked Command \u00b6 Error: Command blocked for safety reasons Solution: This command is restricted. Find an alternative approach or use more targeted commands. Summary \u00b6 The Bash tool provides: Direct shell command execution Background process support for servers and watchers Safety features to prevent dangerous operations Access to build tools, package managers, and system utilities Remember: prefer specialized tools when available, but bash is always there when you need raw command-line power.","title":"Bash"},{"location":"tools/bash.html#bash-tool","text":"The Bash tool provides direct shell command execution, giving you access to your system's full command-line capabilities. This is your gateway to build systems, package managers, version control, and any other terminal operation. While specialized tools exist for many tasks, bash serves as the universal fallback when you need raw shell power.","title":"Bash Tool"},{"location":"tools/bash.html#operations","text":"Operation Purpose Example Run command Execute shell command synchronously pytest tests/ Background Start long-running process npm run dev Chain commands Run dependent operations mkdir build && cd build && cmake .. Pipeline Process output through filters cat log.txt \\| grep ERROR Redirect Save output to file npm test > results.txt 2>&1","title":"Operations"},{"location":"tools/bash.html#basic-usage","text":"","title":"Basic Usage"},{"location":"tools/bash.html#interactive-prompt-format","text":"Using the > prompt in conversation: > pytest tests/unit/ > npm install express > git status","title":"Interactive Prompt Format"},{"location":"tools/bash.html#tool-call-format","text":"How Amplifier executes bash internally: [Tool: bash] command: pytest tests/unit/ [Tool: bash] command: npm install express","title":"Tool Call Format"},{"location":"tools/bash.html#background-process-format","text":"For long-running processes that shouldn't block: [Tool: bash] command: npm run dev run_in_background: true","title":"Background Process Format"},{"location":"tools/bash.html#common-commands","text":"","title":"Common Commands"},{"location":"tools/bash.html#build-commands","text":"# Python > pip install -e . > python setup.py build > poetry build # Node.js > npm install > npm run build > yarn build # Rust > cargo build > cargo build --release # Go > go build ./... > go build -o myapp main.go # Make > make > make clean && make all","title":"Build Commands"},{"location":"tools/bash.html#test-commands","text":"# Python > pytest > pytest tests/unit/ -v > pytest --cov = src tests/ > python -m unittest discover # Node.js > npm test > npm run test:unit > jest --coverage # Rust > cargo test > cargo test -- --nocapture # Go > go test ./... > go test -v -cover ./...","title":"Test Commands"},{"location":"tools/bash.html#git-commands","text":"# Status and info > git status > git log --oneline -10 > git diff > git branch -a # Staging and commits > git add . > git commit -m \"Fix authentication bug\" > git push origin main # Branching > git checkout -b feature/new-login > git merge develop > git rebase main","title":"Git Commands"},{"location":"tools/bash.html#package-management","text":"# Python (pip) > pip install requests > pip install -r requirements.txt > pip freeze > requirements.txt # Python (poetry) > poetry add pandas > poetry install > poetry update # Node.js (npm) > npm install lodash > npm install --save-dev jest > npm update # Node.js (yarn) > yarn add axios > yarn add -D typescript # System (apt) > sudo apt update > sudo apt install jq","title":"Package Management"},{"location":"tools/bash.html#container-operations","text":"# Docker > docker build -t myapp . > docker run -p 8080 :8080 myapp > docker-compose up -d > docker ps > docker logs container_name # Kubernetes > kubectl get pods > kubectl apply -f deployment.yaml > kubectl logs pod-name","title":"Container Operations"},{"location":"tools/bash.html#github-cli","text":"# Pull requests > gh pr create --title \"Add feature\" --body \"Description\" > gh pr list > gh pr checkout 123 > gh pr merge 123 # Issues > gh issue create --title \"Bug report\" > gh issue list --state open > gh issue close 42","title":"GitHub CLI"},{"location":"tools/bash.html#background-processes","text":"Use run_in_background: true for processes that run continuously:","title":"Background Processes"},{"location":"tools/bash.html#development-servers","text":"[Tool: bash] command: npm run dev run_in_background: true [Tool: bash] command: python -m http.server 8000 run_in_background: true [Tool: bash] command: cargo watch -x run run_in_background: true","title":"Development Servers"},{"location":"tools/bash.html#file-watchers","text":"[Tool: bash] command: npm run watch run_in_background: true","title":"File Watchers"},{"location":"tools/bash.html#what-happens-with-background-processes","text":"The command starts in a separate process Amplifier returns immediately with the process ID (PID) The process continues running independently Output is not captured in the response","title":"What Happens with Background Processes"},{"location":"tools/bash.html#when-to-use-background-mode","text":"Scenario Use Background? Dev server ( npm run dev ) Yes File watcher Yes Running tests No Building project No Git operations No Installing packages No","title":"When to Use Background Mode"},{"location":"tools/bash.html#safety-features","text":"","title":"Safety Features"},{"location":"tools/bash.html#blocked-commands","text":"Dangerous commands are automatically blocked to prevent accidents: # These will be rejected: > rm -rf / > sudo rm -rf /* > dd if = /dev/zero of = /dev/sda > mkfs.ext4 /dev/sda1","title":"Blocked Commands"},{"location":"tools/bash.html#interactive-commands-not-supported","text":"Commands requiring user input will fail: # These won't work: > vim file.txt # Requires interactive editor > ssh user@host # May require password input > mysql -u root -p # Prompts for password > python # Interactive REPL","title":"Interactive Commands Not Supported"},{"location":"tools/bash.html#output-truncation","text":"Long outputs are automatically truncated to prevent context overflow: First portion of output is shown [...truncated...] marker appears Final portion of output is shown Byte counts indicate total size Warning: Truncation may break JSON, XML, or other structured output. For large structured data: # Redirect to file instead > npm test --json > test-results.json # Then read portions as needed using read_file","title":"Output Truncation"},{"location":"tools/bash.html#timeouts","text":"Commands have execution time limits. Long-running commands should use background mode or be broken into smaller operations.","title":"Timeouts"},{"location":"tools/bash.html#best-practices","text":"","title":"Best Practices"},{"location":"tools/bash.html#1-use-absolute-paths","text":"Maintain clear working directory context: # Preferred > pytest /home/user/project/tests/ # Instead of > cd /home/user/project && pytest tests/","title":"1. Use Absolute Paths"},{"location":"tools/bash.html#2-quote-paths-with-spaces","text":"# Correct > cd \"/path/with spaces/project\" # Will fail > cd /path/with spaces/project","title":"2. Quote Paths with Spaces"},{"location":"tools/bash.html#3-chain-dependent-commands","text":"Use && to run commands only if previous succeeds: > mkdir -p build && cd build && cmake .. && make","title":"3. Chain Dependent Commands"},{"location":"tools/bash.html#4-prefer-specialized-tools","text":"Use bash as a fallback, not first choice: Task Use Instead Read file read_file tool Edit file edit_file tool Find files glob tool Search content grep tool","title":"4. Prefer Specialized Tools"},{"location":"tools/bash.html#5-capture-important-output","text":"For output you need to process later: > command > output.txt 2 > & 1","title":"5. Capture Important Output"},{"location":"tools/bash.html#6-check-exit-status","text":"Chain with && to stop on failure: > npm install && npm test && npm run build","title":"6. Check Exit Status"},{"location":"tools/bash.html#try-it-yourself","text":"","title":"Try It Yourself"},{"location":"tools/bash.html#exercise-1-basic-commands","text":"Try running these commands: > echo \"Hello from bash\" > pwd > ls -la > date","title":"Exercise 1: Basic Commands"},{"location":"tools/bash.html#exercise-2-project-setup","text":"Initialize a new project: > mkdir -p /tmp/demo-project > cd /tmp/demo-project && git init > echo \"# Demo Project\" > README.md > git add . && git commit -m \"Initial commit\"","title":"Exercise 2: Project Setup"},{"location":"tools/bash.html#exercise-3-background-server","text":"Start a simple server in background: [Tool: bash] command: cd /tmp/demo-project && python -m http.server 8080 run_in_background: true Then verify it's running: > curl http://localhost:8080","title":"Exercise 3: Background Server"},{"location":"tools/bash.html#exercise-4-build-and-test","text":"Run a typical development workflow: > pip install pytest > pytest --version","title":"Exercise 4: Build and Test"},{"location":"tools/bash.html#errors-and-troubleshooting","text":"","title":"Errors and Troubleshooting"},{"location":"tools/bash.html#command-not-found","text":"bash: npm: command not found Solution: The command isn't in PATH. Install the required tool or use full path.","title":"Command Not Found"},{"location":"tools/bash.html#permission-denied","text":"bash: ./script.sh: Permission denied Solution: Make the script executable: > chmod +x ./script.sh","title":"Permission Denied"},{"location":"tools/bash.html#no-such-file-or-directory","text":"bash: cd: /nonexistent/path: No such file or directory Solution: Verify the path exists. Use ls or glob to find correct path.","title":"No Such File or Directory"},{"location":"tools/bash.html#interactive-command-fails","text":"Error: Command requires interactive input Solution: Use non-interactive flags: # Instead of: git commit > git commit -m \"message\" # Instead of: npm init > npm init -y","title":"Interactive Command Fails"},{"location":"tools/bash.html#output-too-large","text":"[Output truncated - 1.2MB total] Solution: Redirect to file and read portions: > long-command > output.txt # Then use read_file with offset/limit","title":"Output Too Large"},{"location":"tools/bash.html#timeout-exceeded","text":"Error: Command timed out after 60 seconds Solution: Use background mode for long-running processes, or break into smaller operations.","title":"Timeout Exceeded"},{"location":"tools/bash.html#blocked-command","text":"Error: Command blocked for safety reasons Solution: This command is restricted. Find an alternative approach or use more targeted commands.","title":"Blocked Command"},{"location":"tools/bash.html#summary","text":"The Bash tool provides: Direct shell command execution Background process support for servers and watchers Safety features to prevent dangerous operations Access to build tools, package managers, and system utilities Remember: prefer specialized tools when available, but bash is always there when you need raw command-line power.","title":"Summary"},{"location":"tools/filesystem.html","text":"Filesystem Tool \u00b6 The Filesystem Tool provides direct access to read, write, and edit files on your local system. Unlike shell commands that require parsing text output, these tools offer structured, reliable file operations with built-in safety features. Overview \u00b6 The filesystem capabilities are split across three specialized tools, each optimized for a specific operation type: Operation Tool Purpose Read read_file Read file contents or list directories Write write_file Create new files or overwrite existing ones Edit edit_file Make surgical string replacements in existing files This separation ensures clarity of intent and enables appropriate safety checks for each operation type. Reading Files \u00b6 The read_file tool retrieves file contents with line numbers, making it easy to reference specific locations in code. Basic Usage \u00b6 read_file(\"src/config.py\") Output format uses cat -n style with line numbers: 1 import os 2 from pathlib import Path 3 4 CONFIG_DIR = Path(\"~/.config/myapp\").expanduser() 5 DEBUG = os.getenv(\"DEBUG\", \"false\").lower() == \"true\" Reading Large Files \u00b6 For files too large to read at once, use offset and limit parameters: # Read lines 100-200 of a large log file read_file(\"logs/application.log\", offset=100, limit=100) Parameter Description Default file_path Path to the file (required) - offset Starting line number (1-indexed) 1 limit Maximum lines to read 2000 Line Length Truncation \u00b6 Lines longer than 2000 characters are automatically truncated to prevent context overflow. This is common with: Minified JavaScript/CSS files Generated code with long lines Log files with embedded JSON Reading Directories \u00b6 When given a directory path, read_file returns a formatted listing: read_file(\"src/components\") Output: DIR Button/ DIR Form/ FILE index.ts FILE types.ts Writing Files \u00b6 The write_file tool creates new files or completely overwrites existing ones. Basic Usage \u00b6 write_file(\"src/utils/helpers.py\", \"\"\" def format_date(dt): return dt.strftime(\"%Y-%m-%d\") def slugify(text): return text.lower().replace(\" \", \"-\") \"\"\") When to Use write_file \u00b6 Use write_file when: Creating a new file that doesn't exist Completely replacing a file's contents The file is small enough to rewrite entirely You've already read the file and need to restructure it significantly Avoid write_file when: Making small changes to existing files (use edit_file instead) You haven't read the current contents first The file is large and you only need to change a few lines Safety Requirements \u00b6 The tool enforces a critical safety rule: You must read a file before you can write to it. This prevents accidental overwrites of files you haven't examined. The tool will fail if you attempt to write to an existing file without reading it first in the conversation. Editing Files \u00b6 The edit_file tool performs precise string replacements, making it ideal for surgical changes to existing code. Basic Usage \u00b6 edit_file( file_path=\"src/config.py\", old_string=\"DEBUG = False\", new_string=\"DEBUG = True\" ) How It Works \u00b6 The tool searches for old_string in the file If found exactly once, it replaces with new_string If not found or found multiple times, the operation fails Handling Non-Unique Strings \u00b6 If your old_string appears multiple times, you have two options: Option 1: Add Context Include surrounding lines to make the match unique: edit_file( file_path=\"src/handlers.py\", old_string=\"\"\"def process_user(user): return user.name\"\"\", new_string=\"\"\"def process_user(user): return user.display_name\"\"\" ) Option 2: Replace All Occurrences Use replace_all=True to replace every instance: edit_file( file_path=\"src/handlers.py\", old_string=\"user.name\", new_string=\"user.display_name\", replace_all=True ) Preserving Indentation \u00b6 When copying text from read_file output, preserve the exact indentation. The line number prefix format is: 5 def method(self): Everything after the tab following the line number is actual file content. Match this exactly in your old_string . Multi-Line Edits \u00b6 For changes spanning multiple lines, include all relevant lines: edit_file( file_path=\"src/api.py\", old_string=\"\"\"@app.route(\"/users\") def get_users(): return jsonify(users)\"\"\", new_string=\"\"\"@app.route(\"/users\") @require_auth def get_users(): return jsonify(users)\"\"\" ) Directory Listing \u00b6 The read_file tool doubles as a directory lister when given a directory path. Basic Listing \u00b6 read_file(\"src/\") Understanding Output \u00b6 DIR components/ DIR utils/ FILE app.py FILE config.py FILE __init__.py DIR entries are subdirectories (shown with trailing / ) FILE entries are regular files Results are sorted with directories first Navigating Deep Structures \u00b6 To explore nested directories, make multiple calls: read_file(\"src/\") # See top-level structure read_file(\"src/components\") # Dive into components read_file(\"src/components/Button\") # Explore specific component Best Practices \u00b6 1. Always Read Before Editing \u00b6 Never attempt to edit a file you haven't read in the current conversation: # Correct workflow read_file(\"config.yaml\") # First, understand current state edit_file(\"config.yaml\", old_string=\"...\", new_string=\"...\") # Incorrect - will fail edit_file(\"config.yaml\", old_string=\"...\", new_string=\"...\") # Haven't read it! 2. Prefer edit_file Over write_file \u00b6 For existing files, edit_file is safer and more precise: Scenario Recommended Tool Change one function edit_file Update a config value edit_file Rename a variable throughout edit_file with replace_all Create new file write_file Complete rewrite write_file (after reading) 3. Use Exact Matches \u00b6 The old_string must match exactly, including: Whitespace (spaces, tabs, newlines) Indentation Line endings 4. Handle Large Files Strategically \u00b6 For files exceeding 2000 lines: Use offset and limit to read in chunks Identify the specific section needing changes Use edit_file for targeted modifications 5. Verify After Writing \u00b6 After significant changes, read the file to confirm: write_file(\"new_module.py\", content) read_file(\"new_module.py\") # Verify it looks correct Try It Yourself \u00b6 Exercise 1: Read and Explore \u00b6 Explore a project structure: \"List the contents of the src directory\" \"Show me what's in src/utils\" \"Read the first 50 lines of src/main.py\" Exercise 2: Create a New File \u00b6 Create a configuration file: \"Create a file called config.json with database settings\" Verify: \"Read config.json to confirm\" Exercise 3: Make Surgical Edits \u00b6 Practice precise editing: \"Read src/constants.py\" \"Change MAX_RETRIES from 3 to 5\" \"Replace all occurrences of 'localhost' with '127.0.0.1'\" Exercise 4: Multi-Line Edit \u00b6 Try editing across lines: \"Read the authenticate function in src/auth.py\" \"Add a logging statement at the start of the function\" Errors and Troubleshooting \u00b6 \"File not found\" \u00b6 The specified path doesn't exist. Check: Spelling and case sensitivity (Linux is case-sensitive) Relative vs absolute paths Whether you're in the expected working directory \"old_string not found in file\" \u00b6 Your search string doesn't match the file contents exactly: Re-read the file to see current contents Check for whitespace differences Verify indentation matches exactly Look for invisible characters or different line endings \"old_string appears multiple times\" \u00b6 The string isn't unique. Solutions: Add surrounding context to make it unique Use replace_all=True if you want to replace all occurrences \"Must read file before writing\" \u00b6 You attempted to overwrite a file without reading it first: Read the file first: read_file(\"path/to/file\") Then proceed with your write or edit operation \"Line truncated at 2000 characters\" \u00b6 The file contains very long lines: This is informational, not an error Consider if the file is minified or generated You can still edit the file, but may need to work with truncated content \"Permission denied\" \u00b6 The file or directory has restrictive permissions: Check file ownership and permissions Some system files require elevated privileges Consider whether you should be modifying this file Summary \u00b6 Tool Use For Key Parameters read_file Reading contents, listing directories offset , limit write_file Creating new files, complete rewrites content edit_file Precise string replacements old_string , new_string , replace_all The filesystem tools provide a safe, structured approach to file operations. By separating read, write, and edit operations, each action has appropriate safeguards while remaining straightforward to use. Next: Search Tool - Finding files and content across your codebase","title":"Filesystem"},{"location":"tools/filesystem.html#filesystem-tool","text":"The Filesystem Tool provides direct access to read, write, and edit files on your local system. Unlike shell commands that require parsing text output, these tools offer structured, reliable file operations with built-in safety features.","title":"Filesystem Tool"},{"location":"tools/filesystem.html#overview","text":"The filesystem capabilities are split across three specialized tools, each optimized for a specific operation type: Operation Tool Purpose Read read_file Read file contents or list directories Write write_file Create new files or overwrite existing ones Edit edit_file Make surgical string replacements in existing files This separation ensures clarity of intent and enables appropriate safety checks for each operation type.","title":"Overview"},{"location":"tools/filesystem.html#reading-files","text":"The read_file tool retrieves file contents with line numbers, making it easy to reference specific locations in code.","title":"Reading Files"},{"location":"tools/filesystem.html#basic-usage","text":"read_file(\"src/config.py\") Output format uses cat -n style with line numbers: 1 import os 2 from pathlib import Path 3 4 CONFIG_DIR = Path(\"~/.config/myapp\").expanduser() 5 DEBUG = os.getenv(\"DEBUG\", \"false\").lower() == \"true\"","title":"Basic Usage"},{"location":"tools/filesystem.html#reading-large-files","text":"For files too large to read at once, use offset and limit parameters: # Read lines 100-200 of a large log file read_file(\"logs/application.log\", offset=100, limit=100) Parameter Description Default file_path Path to the file (required) - offset Starting line number (1-indexed) 1 limit Maximum lines to read 2000","title":"Reading Large Files"},{"location":"tools/filesystem.html#line-length-truncation","text":"Lines longer than 2000 characters are automatically truncated to prevent context overflow. This is common with: Minified JavaScript/CSS files Generated code with long lines Log files with embedded JSON","title":"Line Length Truncation"},{"location":"tools/filesystem.html#reading-directories","text":"When given a directory path, read_file returns a formatted listing: read_file(\"src/components\") Output: DIR Button/ DIR Form/ FILE index.ts FILE types.ts","title":"Reading Directories"},{"location":"tools/filesystem.html#writing-files","text":"The write_file tool creates new files or completely overwrites existing ones.","title":"Writing Files"},{"location":"tools/filesystem.html#basic-usage_1","text":"write_file(\"src/utils/helpers.py\", \"\"\" def format_date(dt): return dt.strftime(\"%Y-%m-%d\") def slugify(text): return text.lower().replace(\" \", \"-\") \"\"\")","title":"Basic Usage"},{"location":"tools/filesystem.html#when-to-use-write_file","text":"Use write_file when: Creating a new file that doesn't exist Completely replacing a file's contents The file is small enough to rewrite entirely You've already read the file and need to restructure it significantly Avoid write_file when: Making small changes to existing files (use edit_file instead) You haven't read the current contents first The file is large and you only need to change a few lines","title":"When to Use write_file"},{"location":"tools/filesystem.html#safety-requirements","text":"The tool enforces a critical safety rule: You must read a file before you can write to it. This prevents accidental overwrites of files you haven't examined. The tool will fail if you attempt to write to an existing file without reading it first in the conversation.","title":"Safety Requirements"},{"location":"tools/filesystem.html#editing-files","text":"The edit_file tool performs precise string replacements, making it ideal for surgical changes to existing code.","title":"Editing Files"},{"location":"tools/filesystem.html#basic-usage_2","text":"edit_file( file_path=\"src/config.py\", old_string=\"DEBUG = False\", new_string=\"DEBUG = True\" )","title":"Basic Usage"},{"location":"tools/filesystem.html#how-it-works","text":"The tool searches for old_string in the file If found exactly once, it replaces with new_string If not found or found multiple times, the operation fails","title":"How It Works"},{"location":"tools/filesystem.html#handling-non-unique-strings","text":"If your old_string appears multiple times, you have two options: Option 1: Add Context Include surrounding lines to make the match unique: edit_file( file_path=\"src/handlers.py\", old_string=\"\"\"def process_user(user): return user.name\"\"\", new_string=\"\"\"def process_user(user): return user.display_name\"\"\" ) Option 2: Replace All Occurrences Use replace_all=True to replace every instance: edit_file( file_path=\"src/handlers.py\", old_string=\"user.name\", new_string=\"user.display_name\", replace_all=True )","title":"Handling Non-Unique Strings"},{"location":"tools/filesystem.html#preserving-indentation","text":"When copying text from read_file output, preserve the exact indentation. The line number prefix format is: 5 def method(self): Everything after the tab following the line number is actual file content. Match this exactly in your old_string .","title":"Preserving Indentation"},{"location":"tools/filesystem.html#multi-line-edits","text":"For changes spanning multiple lines, include all relevant lines: edit_file( file_path=\"src/api.py\", old_string=\"\"\"@app.route(\"/users\") def get_users(): return jsonify(users)\"\"\", new_string=\"\"\"@app.route(\"/users\") @require_auth def get_users(): return jsonify(users)\"\"\" )","title":"Multi-Line Edits"},{"location":"tools/filesystem.html#directory-listing","text":"The read_file tool doubles as a directory lister when given a directory path.","title":"Directory Listing"},{"location":"tools/filesystem.html#basic-listing","text":"read_file(\"src/\")","title":"Basic Listing"},{"location":"tools/filesystem.html#understanding-output","text":"DIR components/ DIR utils/ FILE app.py FILE config.py FILE __init__.py DIR entries are subdirectories (shown with trailing / ) FILE entries are regular files Results are sorted with directories first","title":"Understanding Output"},{"location":"tools/filesystem.html#navigating-deep-structures","text":"To explore nested directories, make multiple calls: read_file(\"src/\") # See top-level structure read_file(\"src/components\") # Dive into components read_file(\"src/components/Button\") # Explore specific component","title":"Navigating Deep Structures"},{"location":"tools/filesystem.html#best-practices","text":"","title":"Best Practices"},{"location":"tools/filesystem.html#1-always-read-before-editing","text":"Never attempt to edit a file you haven't read in the current conversation: # Correct workflow read_file(\"config.yaml\") # First, understand current state edit_file(\"config.yaml\", old_string=\"...\", new_string=\"...\") # Incorrect - will fail edit_file(\"config.yaml\", old_string=\"...\", new_string=\"...\") # Haven't read it!","title":"1. Always Read Before Editing"},{"location":"tools/filesystem.html#2-prefer-edit_file-over-write_file","text":"For existing files, edit_file is safer and more precise: Scenario Recommended Tool Change one function edit_file Update a config value edit_file Rename a variable throughout edit_file with replace_all Create new file write_file Complete rewrite write_file (after reading)","title":"2. Prefer edit_file Over write_file"},{"location":"tools/filesystem.html#3-use-exact-matches","text":"The old_string must match exactly, including: Whitespace (spaces, tabs, newlines) Indentation Line endings","title":"3. Use Exact Matches"},{"location":"tools/filesystem.html#4-handle-large-files-strategically","text":"For files exceeding 2000 lines: Use offset and limit to read in chunks Identify the specific section needing changes Use edit_file for targeted modifications","title":"4. Handle Large Files Strategically"},{"location":"tools/filesystem.html#5-verify-after-writing","text":"After significant changes, read the file to confirm: write_file(\"new_module.py\", content) read_file(\"new_module.py\") # Verify it looks correct","title":"5. Verify After Writing"},{"location":"tools/filesystem.html#try-it-yourself","text":"","title":"Try It Yourself"},{"location":"tools/filesystem.html#exercise-1-read-and-explore","text":"Explore a project structure: \"List the contents of the src directory\" \"Show me what's in src/utils\" \"Read the first 50 lines of src/main.py\"","title":"Exercise 1: Read and Explore"},{"location":"tools/filesystem.html#exercise-2-create-a-new-file","text":"Create a configuration file: \"Create a file called config.json with database settings\" Verify: \"Read config.json to confirm\"","title":"Exercise 2: Create a New File"},{"location":"tools/filesystem.html#exercise-3-make-surgical-edits","text":"Practice precise editing: \"Read src/constants.py\" \"Change MAX_RETRIES from 3 to 5\" \"Replace all occurrences of 'localhost' with '127.0.0.1'\"","title":"Exercise 3: Make Surgical Edits"},{"location":"tools/filesystem.html#exercise-4-multi-line-edit","text":"Try editing across lines: \"Read the authenticate function in src/auth.py\" \"Add a logging statement at the start of the function\"","title":"Exercise 4: Multi-Line Edit"},{"location":"tools/filesystem.html#errors-and-troubleshooting","text":"","title":"Errors and Troubleshooting"},{"location":"tools/filesystem.html#file-not-found","text":"The specified path doesn't exist. Check: Spelling and case sensitivity (Linux is case-sensitive) Relative vs absolute paths Whether you're in the expected working directory","title":"\"File not found\""},{"location":"tools/filesystem.html#old_string-not-found-in-file","text":"Your search string doesn't match the file contents exactly: Re-read the file to see current contents Check for whitespace differences Verify indentation matches exactly Look for invisible characters or different line endings","title":"\"old_string not found in file\""},{"location":"tools/filesystem.html#old_string-appears-multiple-times","text":"The string isn't unique. Solutions: Add surrounding context to make it unique Use replace_all=True if you want to replace all occurrences","title":"\"old_string appears multiple times\""},{"location":"tools/filesystem.html#must-read-file-before-writing","text":"You attempted to overwrite a file without reading it first: Read the file first: read_file(\"path/to/file\") Then proceed with your write or edit operation","title":"\"Must read file before writing\""},{"location":"tools/filesystem.html#line-truncated-at-2000-characters","text":"The file contains very long lines: This is informational, not an error Consider if the file is minified or generated You can still edit the file, but may need to work with truncated content","title":"\"Line truncated at 2000 characters\""},{"location":"tools/filesystem.html#permission-denied","text":"The file or directory has restrictive permissions: Check file ownership and permissions Some system files require elevated privileges Consider whether you should be modifying this file","title":"\"Permission denied\""},{"location":"tools/filesystem.html#summary","text":"Tool Use For Key Parameters read_file Reading contents, listing directories offset , limit write_file Creating new files, complete rewrites content edit_file Precise string replacements old_string , new_string , replace_all The filesystem tools provide a safe, structured approach to file operations. By separating read, write, and edit operations, each action has appropriate safeguards while remaining straightforward to use. Next: Search Tool - Finding files and content across your codebase","title":"Summary"},{"location":"tools/lsp.html","text":"LSP Tool (Code Intelligence) \u00b6 The LSP tool provides semantic code understanding through the Language Server Protocol. Unlike text-based search tools, LSP understands your code's actual structure\u2014types, references, call hierarchies, and more. What is LSP? \u00b6 The Language Server Protocol (LSP) is a standardized protocol for providing programming language features like: Go to definition Find all references Hover information (types, documentation) Call hierarchy analysis Symbol navigation Amplifier integrates with language servers to give you precise, semantic code intelligence. Instead of matching text patterns, LSP understands what your code actually means. Why Semantic Understanding Matters \u00b6 Consider searching for a function called process : Text search (grep): Finds every occurrence of \"process\" including comments, strings, variable names, and unrelated functions LSP: Finds the exact function definition and its actual callers\u2014nothing more, nothing less This precision becomes critical in large codebases where text matches produce hundreds of false positives. LSP vs Grep: When to Use Each \u00b6 Task Use LSP Use Grep Find all callers of a function incomingCalls - semantic, precise May match strings, comments, false positives Find where a symbol is defined goToDefinition - exact location Multiple matches, manual filtering needed Get type info or signature hover - full type data Not possible with text search Find text pattern anywhere Use grep instead Faster for bulk text search Search across many files Use grep instead Better for pattern matching The Rule of Thumb \u00b6 LSP: Semantic code understanding (types, references, call chains) Grep: Text pattern matching (fast, broad searches) Available Operations \u00b6 The LSP tool supports these operations: goToDefinition \u00b6 Jump to where a symbol is defined. Works for functions, classes, variables, imports, and more. Operation: goToDefinition File: src/auth/session.py Line: 45 Character: 12 Result: src/auth/base.py:23 - class SessionManager Use when: You see a function call and want to see its implementation. findReferences \u00b6 Find all locations where a symbol is used throughout the codebase. Operation: findReferences File: src/models/user.py Line: 15 Character: 7 Result: - src/api/routes.py:34 - src/services/auth.py:78 - src/utils/validation.py:12 - tests/test_user.py:45 Use when: You're refactoring and need to know everywhere a symbol is used. hover \u00b6 Get type information, documentation, and signatures for any symbol. Operation: hover File: src/database/connection.py Line: 28 Character: 15 Result: def get_connection( pool_name: str, timeout: float = 30.0 ) -> AsyncConnection \"Retrieve a connection from the specified pool.\" Use when: You need to understand a function's signature or a variable's type. documentSymbol \u00b6 List all symbols defined in a single file\u2014functions, classes, variables, constants. Operation: documentSymbol File: src/models/user.py Result: - class User (line 10) - def __init__ (line 15) - def validate (line 28) - def to_dict (line 45) - USER_ROLES: list (line 5) Use when: You want an overview of a file's structure. workspaceSymbol \u00b6 Search for symbols across the entire workspace by name. Operation: workspaceSymbol Query: \"Session\" Result: - class Session (src/auth/session.py:12) - class SessionManager (src/auth/manager.py:8) - def create_session (src/api/auth.py:34) - SESSION_TIMEOUT (src/config.py:15) Use when: You know a symbol's name but not its location. goToImplementation \u00b6 Find concrete implementations of an interface or abstract method. Operation: goToImplementation File: src/providers/base.py Line: 12 Character: 8 Result: - src/providers/openai.py:15 - class OpenAIProvider - src/providers/anthropic.py:18 - class AnthropicProvider Use when: You have an abstract class and want to find all implementations. prepareCallHierarchy \u00b6 Initialize call hierarchy analysis for a function. This prepares for incomingCalls or outgoingCalls operations. incomingCalls \u00b6 Find all functions that call a specific function (who calls this?). Operation: incomingCalls File: src/auth/validate.py Line: 20 Character: 5 Result: - login_user (src/api/auth.py:45) calls validate_token - refresh_session (src/api/auth.py:78) calls validate_token - middleware_check (src/middleware/auth.py:12) calls validate_token Use when: You're changing a function and need to know what might break. outgoingCalls \u00b6 Find all functions that a specific function calls (what does this call?). Operation: outgoingCalls File: src/api/auth.py Line: 45 Character: 5 Result: - login_user calls: - validate_token (src/auth/validate.py:20) - create_session (src/auth/session.py:35) - log_event (src/utils/logging.py:12) Use when: You want to understand a function's dependencies. Python-Specific Intelligence \u00b6 Amplifier uses Pyright for Python language support, providing: Type Inference \u00b6 Even without type annotations, Pyright infers types from your code: # No annotations here def get_users ( limit ): return db . query ( User ) . limit ( limit ) . all () # LSP hover reveals: # def get_users(limit: int) -> list[User] Import Resolution \u00b6 LSP resolves imports correctly, even for: - Relative imports ( from .utils import helper ) - Package imports ( from mypackage.submodule import func ) - Conditional imports - Dynamic imports (where possible) Type Hierarchy \u00b6 Navigate class inheritance chains: - Find all subclasses of a base class - Trace method overrides through inheritance - Understand mixin compositions Stub Files \u00b6 Pyright uses type stubs ( .pyi files) for standard library and third-party packages, providing accurate type information even for untyped libraries. Best Practices \u00b6 1. Start with LSP for Code Understanding \u00b6 When investigating unfamiliar code: Use hover to understand types and signatures Use goToDefinition to see implementations Use incomingCalls to understand usage patterns 2. Use Call Hierarchy for Impact Analysis \u00b6 Before refactoring: Run incomingCalls on the function you're changing Trace the full call tree to understand blast radius Check all callers to ensure your changes are safe 3. Combine with Grep Strategically \u00b6 Some workflows benefit from both tools: # First, find all files with \"authenticate\" (fast, broad) grep pattern=\"authenticate\" type=\"py\" # Then, use LSP on specific hits for semantic analysis LSP operation=\"findReferences\" file=\"src/auth.py\" line=45 character=8 4. Position Matters \u00b6 LSP operations require precise positions: - Line: 1-indexed (first line is 1) - Character: 1-indexed (first character is 1) - Position your cursor ON the symbol you're querying 5. Delegate Complex Navigation \u00b6 For multi-step navigation tasks, use specialized agents: - lsp:code-navigator for general code navigation - lsp-python:python-code-intel for Python-specific analysis Try It Yourself \u00b6 Exercise 1: Trace a Function \u00b6 Pick any function in your codebase: Use hover to see its signature Use goToDefinition to find its implementation Use incomingCalls to see who calls it Use outgoingCalls to see what it depends on Exercise 2: Understand a Type \u00b6 Find a class you're curious about: Use documentSymbol to see all its methods Use goToImplementation to find subclasses Use findReferences on the class name to see usage Exercise 3: Impact Analysis \u00b6 Before making a change: Identify the function you'll modify Use incomingCalls recursively to build the call tree Count how many locations might be affected Decide if the change is safe Common Errors and Solutions \u00b6 \"No result found\" \u00b6 Cause: LSP couldn't find semantic information at that position. Solutions: - Ensure cursor is exactly on the symbol (not whitespace) - Check that the file has valid syntax - The language server may not have indexed yet\u2014try again \"Language server not available\" \u00b6 Cause: No language server configured for this file type. Solutions: - Check if the language is supported (Python is built-in) - Ensure the language server is properly configured - Some file types don't have LSP support \"Position out of range\" \u00b6 Cause: Line or character number exceeds file bounds. Solutions: - Remember: lines and characters are 1-indexed - Verify the file hasn't changed since you got the position - Double-check your line/character values Stale Results \u00b6 Cause: Language server hasn't processed recent changes. Solutions: - Save the file to trigger re-analysis - Wait a moment for indexing to complete - For large changes, the server may need time to catch up Summary \u00b6 The LSP tool provides semantic code intelligence that text search cannot match: Capability What It Does Key Benefit goToDefinition Jump to source No more searching findReferences All usages Complete picture hover Type info Understand without reading incomingCalls Who calls this Impact analysis outgoingCalls What this calls Dependency mapping Remember: Use LSP for understanding code relationships. Use grep for finding text patterns. Together, they're a powerful combination for navigating any codebase.","title":"LSP (Code Intelligence)"},{"location":"tools/lsp.html#lsp-tool-code-intelligence","text":"The LSP tool provides semantic code understanding through the Language Server Protocol. Unlike text-based search tools, LSP understands your code's actual structure\u2014types, references, call hierarchies, and more.","title":"LSP Tool (Code Intelligence)"},{"location":"tools/lsp.html#what-is-lsp","text":"The Language Server Protocol (LSP) is a standardized protocol for providing programming language features like: Go to definition Find all references Hover information (types, documentation) Call hierarchy analysis Symbol navigation Amplifier integrates with language servers to give you precise, semantic code intelligence. Instead of matching text patterns, LSP understands what your code actually means.","title":"What is LSP?"},{"location":"tools/lsp.html#why-semantic-understanding-matters","text":"Consider searching for a function called process : Text search (grep): Finds every occurrence of \"process\" including comments, strings, variable names, and unrelated functions LSP: Finds the exact function definition and its actual callers\u2014nothing more, nothing less This precision becomes critical in large codebases where text matches produce hundreds of false positives.","title":"Why Semantic Understanding Matters"},{"location":"tools/lsp.html#lsp-vs-grep-when-to-use-each","text":"Task Use LSP Use Grep Find all callers of a function incomingCalls - semantic, precise May match strings, comments, false positives Find where a symbol is defined goToDefinition - exact location Multiple matches, manual filtering needed Get type info or signature hover - full type data Not possible with text search Find text pattern anywhere Use grep instead Faster for bulk text search Search across many files Use grep instead Better for pattern matching","title":"LSP vs Grep: When to Use Each"},{"location":"tools/lsp.html#the-rule-of-thumb","text":"LSP: Semantic code understanding (types, references, call chains) Grep: Text pattern matching (fast, broad searches)","title":"The Rule of Thumb"},{"location":"tools/lsp.html#available-operations","text":"The LSP tool supports these operations:","title":"Available Operations"},{"location":"tools/lsp.html#gotodefinition","text":"Jump to where a symbol is defined. Works for functions, classes, variables, imports, and more. Operation: goToDefinition File: src/auth/session.py Line: 45 Character: 12 Result: src/auth/base.py:23 - class SessionManager Use when: You see a function call and want to see its implementation.","title":"goToDefinition"},{"location":"tools/lsp.html#findreferences","text":"Find all locations where a symbol is used throughout the codebase. Operation: findReferences File: src/models/user.py Line: 15 Character: 7 Result: - src/api/routes.py:34 - src/services/auth.py:78 - src/utils/validation.py:12 - tests/test_user.py:45 Use when: You're refactoring and need to know everywhere a symbol is used.","title":"findReferences"},{"location":"tools/lsp.html#hover","text":"Get type information, documentation, and signatures for any symbol. Operation: hover File: src/database/connection.py Line: 28 Character: 15 Result: def get_connection( pool_name: str, timeout: float = 30.0 ) -> AsyncConnection \"Retrieve a connection from the specified pool.\" Use when: You need to understand a function's signature or a variable's type.","title":"hover"},{"location":"tools/lsp.html#documentsymbol","text":"List all symbols defined in a single file\u2014functions, classes, variables, constants. Operation: documentSymbol File: src/models/user.py Result: - class User (line 10) - def __init__ (line 15) - def validate (line 28) - def to_dict (line 45) - USER_ROLES: list (line 5) Use when: You want an overview of a file's structure.","title":"documentSymbol"},{"location":"tools/lsp.html#workspacesymbol","text":"Search for symbols across the entire workspace by name. Operation: workspaceSymbol Query: \"Session\" Result: - class Session (src/auth/session.py:12) - class SessionManager (src/auth/manager.py:8) - def create_session (src/api/auth.py:34) - SESSION_TIMEOUT (src/config.py:15) Use when: You know a symbol's name but not its location.","title":"workspaceSymbol"},{"location":"tools/lsp.html#gotoimplementation","text":"Find concrete implementations of an interface or abstract method. Operation: goToImplementation File: src/providers/base.py Line: 12 Character: 8 Result: - src/providers/openai.py:15 - class OpenAIProvider - src/providers/anthropic.py:18 - class AnthropicProvider Use when: You have an abstract class and want to find all implementations.","title":"goToImplementation"},{"location":"tools/lsp.html#preparecallhierarchy","text":"Initialize call hierarchy analysis for a function. This prepares for incomingCalls or outgoingCalls operations.","title":"prepareCallHierarchy"},{"location":"tools/lsp.html#incomingcalls","text":"Find all functions that call a specific function (who calls this?). Operation: incomingCalls File: src/auth/validate.py Line: 20 Character: 5 Result: - login_user (src/api/auth.py:45) calls validate_token - refresh_session (src/api/auth.py:78) calls validate_token - middleware_check (src/middleware/auth.py:12) calls validate_token Use when: You're changing a function and need to know what might break.","title":"incomingCalls"},{"location":"tools/lsp.html#outgoingcalls","text":"Find all functions that a specific function calls (what does this call?). Operation: outgoingCalls File: src/api/auth.py Line: 45 Character: 5 Result: - login_user calls: - validate_token (src/auth/validate.py:20) - create_session (src/auth/session.py:35) - log_event (src/utils/logging.py:12) Use when: You want to understand a function's dependencies.","title":"outgoingCalls"},{"location":"tools/lsp.html#python-specific-intelligence","text":"Amplifier uses Pyright for Python language support, providing:","title":"Python-Specific Intelligence"},{"location":"tools/lsp.html#type-inference","text":"Even without type annotations, Pyright infers types from your code: # No annotations here def get_users ( limit ): return db . query ( User ) . limit ( limit ) . all () # LSP hover reveals: # def get_users(limit: int) -> list[User]","title":"Type Inference"},{"location":"tools/lsp.html#import-resolution","text":"LSP resolves imports correctly, even for: - Relative imports ( from .utils import helper ) - Package imports ( from mypackage.submodule import func ) - Conditional imports - Dynamic imports (where possible)","title":"Import Resolution"},{"location":"tools/lsp.html#type-hierarchy","text":"Navigate class inheritance chains: - Find all subclasses of a base class - Trace method overrides through inheritance - Understand mixin compositions","title":"Type Hierarchy"},{"location":"tools/lsp.html#stub-files","text":"Pyright uses type stubs ( .pyi files) for standard library and third-party packages, providing accurate type information even for untyped libraries.","title":"Stub Files"},{"location":"tools/lsp.html#best-practices","text":"","title":"Best Practices"},{"location":"tools/lsp.html#1-start-with-lsp-for-code-understanding","text":"When investigating unfamiliar code: Use hover to understand types and signatures Use goToDefinition to see implementations Use incomingCalls to understand usage patterns","title":"1. Start with LSP for Code Understanding"},{"location":"tools/lsp.html#2-use-call-hierarchy-for-impact-analysis","text":"Before refactoring: Run incomingCalls on the function you're changing Trace the full call tree to understand blast radius Check all callers to ensure your changes are safe","title":"2. Use Call Hierarchy for Impact Analysis"},{"location":"tools/lsp.html#3-combine-with-grep-strategically","text":"Some workflows benefit from both tools: # First, find all files with \"authenticate\" (fast, broad) grep pattern=\"authenticate\" type=\"py\" # Then, use LSP on specific hits for semantic analysis LSP operation=\"findReferences\" file=\"src/auth.py\" line=45 character=8","title":"3. Combine with Grep Strategically"},{"location":"tools/lsp.html#4-position-matters","text":"LSP operations require precise positions: - Line: 1-indexed (first line is 1) - Character: 1-indexed (first character is 1) - Position your cursor ON the symbol you're querying","title":"4. Position Matters"},{"location":"tools/lsp.html#5-delegate-complex-navigation","text":"For multi-step navigation tasks, use specialized agents: - lsp:code-navigator for general code navigation - lsp-python:python-code-intel for Python-specific analysis","title":"5. Delegate Complex Navigation"},{"location":"tools/lsp.html#try-it-yourself","text":"","title":"Try It Yourself"},{"location":"tools/lsp.html#exercise-1-trace-a-function","text":"Pick any function in your codebase: Use hover to see its signature Use goToDefinition to find its implementation Use incomingCalls to see who calls it Use outgoingCalls to see what it depends on","title":"Exercise 1: Trace a Function"},{"location":"tools/lsp.html#exercise-2-understand-a-type","text":"Find a class you're curious about: Use documentSymbol to see all its methods Use goToImplementation to find subclasses Use findReferences on the class name to see usage","title":"Exercise 2: Understand a Type"},{"location":"tools/lsp.html#exercise-3-impact-analysis","text":"Before making a change: Identify the function you'll modify Use incomingCalls recursively to build the call tree Count how many locations might be affected Decide if the change is safe","title":"Exercise 3: Impact Analysis"},{"location":"tools/lsp.html#common-errors-and-solutions","text":"","title":"Common Errors and Solutions"},{"location":"tools/lsp.html#no-result-found","text":"Cause: LSP couldn't find semantic information at that position. Solutions: - Ensure cursor is exactly on the symbol (not whitespace) - Check that the file has valid syntax - The language server may not have indexed yet\u2014try again","title":"\"No result found\""},{"location":"tools/lsp.html#language-server-not-available","text":"Cause: No language server configured for this file type. Solutions: - Check if the language is supported (Python is built-in) - Ensure the language server is properly configured - Some file types don't have LSP support","title":"\"Language server not available\""},{"location":"tools/lsp.html#position-out-of-range","text":"Cause: Line or character number exceeds file bounds. Solutions: - Remember: lines and characters are 1-indexed - Verify the file hasn't changed since you got the position - Double-check your line/character values","title":"\"Position out of range\""},{"location":"tools/lsp.html#stale-results","text":"Cause: Language server hasn't processed recent changes. Solutions: - Save the file to trigger re-analysis - Wait a moment for indexing to complete - For large changes, the server may need time to catch up","title":"Stale Results"},{"location":"tools/lsp.html#summary","text":"The LSP tool provides semantic code intelligence that text search cannot match: Capability What It Does Key Benefit goToDefinition Jump to source No more searching findReferences All usages Complete picture hover Type info Understand without reading incomingCalls Who calls this Impact analysis outgoingCalls What this calls Dependency mapping Remember: Use LSP for understanding code relationships. Use grep for finding text patterns. Together, they're a powerful combination for navigating any codebase.","title":"Summary"},{"location":"tools/recipes-tool.html","text":"Recipes Tool \u00b6 The Recipes Tool enables declarative workflow automation through YAML specifications. Instead of manually orchestrating multi-step tasks, you define what needs to happen and let Amplifier handle the execution, checkpointing, and error recovery. What are Recipes? \u00b6 Recipes are declarative YAML workflows that define multi-step agent tasks. Think of them as executable specifications that describe: Steps : Individual units of work performed by agents Context : Data that flows between steps Dependencies : How steps relate to each other Checkpoints : Automatic save points for resumability Gates : Human approval points for sensitive operations A simple recipe might look like this: name : code-review description : Review code changes and suggest improvements steps : - name : analyze agent : foundation:zen-architect instruction : | Analyze the code in {{ file_path }} for: - Code quality issues - Potential bugs - Performance concerns - name : suggest agent : foundation:modular-builder instruction : | Based on the analysis, suggest specific improvements. Previous analysis: {{ steps.analyze.result }} Executing Recipes \u00b6 To run a recipe, use the execute operation with the path to your YAML file: amplifier run \"execute recipe.yaml\" Or through the recipes tool directly: recipes(operation=\"execute\", recipe_path=\"my-recipe.yaml\") During execution, Amplifier: Validates the recipe structure Creates a new session for tracking Executes steps sequentially Persists state after each step Returns the final result Passing Context \u00b6 Recipes become powerful when you parameterize them with context variables. Pass context as key-value pairs: amplifier run \"execute code-review.yaml with file_path=src/auth.py\" Or programmatically: recipes( operation=\"execute\", recipe_path=\"code-review.yaml\", context={\"file_path\": \"src/auth.py\", \"strict_mode\": true} ) Context variables are available in step instructions using Jinja2 templating: steps : - name : review instruction : | Review {{ file_path }} with strict_mode={{ strict_mode }} Context Accumulation \u00b6 Each step's result is automatically added to context for subsequent steps: steps : - name : step_one instruction : \"Generate a summary\" # Result stored in steps.step_one.result - name : step_two instruction : | Expand on this summary: {{ steps.step_one.result }} Operations \u00b6 The Recipes Tool supports several operations for managing workflow execution: Operation Purpose Required Parameters execute Run a recipe from YAML file recipe_path resume Continue an interrupted session session_id list List all active recipe sessions None validate Check recipe YAML structure recipe_path approvals List pending approvals across sessions None approve Approve a stage to continue execution session_id , stage_name deny Deny a stage and stop execution session_id , stage_name Operation Examples \u00b6 Validate before running: recipes(operation=\"validate\", recipe_path=\"deployment.yaml\") Resume an interrupted session: recipes(operation=\"resume\", session_id=\"recipe_20260110_143022_a3f2\") Check pending approvals: recipes(operation=\"approvals\") Approval Gates \u00b6 For sensitive operations, recipes support staged execution with human approval gates. This creates a human-in-the-loop workflow where execution pauses until approved. Defining Staged Recipes \u00b6 name : production-deploy description : Deploy to production with approval gates stages : - name : planning steps : - name : plan agent : foundation:zen-architect instruction : Create deployment plan for {{ service }} requires_approval : true - name : execution steps : - name : deploy agent : foundation:modular-builder instruction : | Execute deployment plan: {{ stages.planning.steps.plan.result }} Approval Workflow \u00b6 Recipe executes until it hits an approval gate Execution pauses and awaits human review Human reviews the stage output Human approves or denies: # Approve to continue recipes(operation=\"approve\", session_id=\"...\", stage_name=\"planning\") # Deny to stop execution recipes(operation=\"deny\", session_id=\"...\", stage_name=\"planning\", reason=\"Needs revision\") If approved, execution continues to the next stage Error Handling \u00b6 Recipes include built-in error handling and retry logic: steps : - name : api_call agent : foundation:integration-specialist instruction : Call external API retry : max_attempts : 3 delay_seconds : 5 on_error : continue # or 'fail' to stop execution Error Strategies \u00b6 Strategy Behavior fail Stop execution immediately (default) continue Log error and proceed to next step retry Attempt step again with configured backoff Best Practices \u00b6 1. Keep Steps Focused \u00b6 Each step should do one thing well: # Good: Single responsibility steps : - name : analyze instruction : Analyze code structure - name : review instruction : Review for issues - name : suggest instruction : Suggest improvements # Avoid: Monolithic steps steps : - name : do_everything instruction : Analyze, review, and suggest all at once 2. Use Descriptive Names \u00b6 Step and stage names become part of the context path: # Good: Clear, descriptive steps : - name : security_audit - name : performance_review # Avoid: Generic names steps : - name : step1 - name : step2 3. Validate Before Execution \u00b6 Always validate recipes before running in production: recipes(operation=\"validate\", recipe_path=\"critical-workflow.yaml\") 4. Design for Resumability \u00b6 Structure recipes so they can resume gracefully: Make steps idempotent where possible Use clear checkpoints between major operations Store intermediate results in context 5. Use Approval Gates for Sensitive Operations \u00b6 Add human checkpoints for: Production deployments Data migrations External API calls with side effects Operations that cannot be easily reversed 6. Document Your Recipes \u00b6 Include clear descriptions: name : data-migration description : | Migrates user data from legacy system to new schema. Prerequisites: - Backup completed - Maintenance window scheduled Context required: - source_db: Legacy database connection - target_db: New database connection Try It Yourself \u00b6 Create a simple recipe to experience the workflow: 1. Create hello-recipe.yaml : name : hello-world description : A simple introduction to recipes steps : - name : greet agent : foundation:file-ops instruction : | Create a file called hello.txt with the message: \"Hello from Amplifier Recipes!\" - name : verify agent : foundation:file-ops instruction : | Read hello.txt and confirm it contains the greeting. Report the contents. 2. Validate the recipe: amplifier run \"validate hello-recipe.yaml\" 3. Execute it: amplifier run \"execute hello-recipe.yaml\" 4. Check the results: The recipe will create hello.txt and verify its contents, demonstrating the multi-step workflow with context passing between agents. Next Steps \u00b6 Learn about Recipe Schema for advanced options Explore Staged Recipes for complex workflows See Recipe Examples for real-world patterns","title":"Recipes Tool"},{"location":"tools/recipes-tool.html#recipes-tool","text":"The Recipes Tool enables declarative workflow automation through YAML specifications. Instead of manually orchestrating multi-step tasks, you define what needs to happen and let Amplifier handle the execution, checkpointing, and error recovery.","title":"Recipes Tool"},{"location":"tools/recipes-tool.html#what-are-recipes","text":"Recipes are declarative YAML workflows that define multi-step agent tasks. Think of them as executable specifications that describe: Steps : Individual units of work performed by agents Context : Data that flows between steps Dependencies : How steps relate to each other Checkpoints : Automatic save points for resumability Gates : Human approval points for sensitive operations A simple recipe might look like this: name : code-review description : Review code changes and suggest improvements steps : - name : analyze agent : foundation:zen-architect instruction : | Analyze the code in {{ file_path }} for: - Code quality issues - Potential bugs - Performance concerns - name : suggest agent : foundation:modular-builder instruction : | Based on the analysis, suggest specific improvements. Previous analysis: {{ steps.analyze.result }}","title":"What are Recipes?"},{"location":"tools/recipes-tool.html#executing-recipes","text":"To run a recipe, use the execute operation with the path to your YAML file: amplifier run \"execute recipe.yaml\" Or through the recipes tool directly: recipes(operation=\"execute\", recipe_path=\"my-recipe.yaml\") During execution, Amplifier: Validates the recipe structure Creates a new session for tracking Executes steps sequentially Persists state after each step Returns the final result","title":"Executing Recipes"},{"location":"tools/recipes-tool.html#passing-context","text":"Recipes become powerful when you parameterize them with context variables. Pass context as key-value pairs: amplifier run \"execute code-review.yaml with file_path=src/auth.py\" Or programmatically: recipes( operation=\"execute\", recipe_path=\"code-review.yaml\", context={\"file_path\": \"src/auth.py\", \"strict_mode\": true} ) Context variables are available in step instructions using Jinja2 templating: steps : - name : review instruction : | Review {{ file_path }} with strict_mode={{ strict_mode }}","title":"Passing Context"},{"location":"tools/recipes-tool.html#context-accumulation","text":"Each step's result is automatically added to context for subsequent steps: steps : - name : step_one instruction : \"Generate a summary\" # Result stored in steps.step_one.result - name : step_two instruction : | Expand on this summary: {{ steps.step_one.result }}","title":"Context Accumulation"},{"location":"tools/recipes-tool.html#operations","text":"The Recipes Tool supports several operations for managing workflow execution: Operation Purpose Required Parameters execute Run a recipe from YAML file recipe_path resume Continue an interrupted session session_id list List all active recipe sessions None validate Check recipe YAML structure recipe_path approvals List pending approvals across sessions None approve Approve a stage to continue execution session_id , stage_name deny Deny a stage and stop execution session_id , stage_name","title":"Operations"},{"location":"tools/recipes-tool.html#operation-examples","text":"Validate before running: recipes(operation=\"validate\", recipe_path=\"deployment.yaml\") Resume an interrupted session: recipes(operation=\"resume\", session_id=\"recipe_20260110_143022_a3f2\") Check pending approvals: recipes(operation=\"approvals\")","title":"Operation Examples"},{"location":"tools/recipes-tool.html#approval-gates","text":"For sensitive operations, recipes support staged execution with human approval gates. This creates a human-in-the-loop workflow where execution pauses until approved.","title":"Approval Gates"},{"location":"tools/recipes-tool.html#defining-staged-recipes","text":"name : production-deploy description : Deploy to production with approval gates stages : - name : planning steps : - name : plan agent : foundation:zen-architect instruction : Create deployment plan for {{ service }} requires_approval : true - name : execution steps : - name : deploy agent : foundation:modular-builder instruction : | Execute deployment plan: {{ stages.planning.steps.plan.result }}","title":"Defining Staged Recipes"},{"location":"tools/recipes-tool.html#approval-workflow","text":"Recipe executes until it hits an approval gate Execution pauses and awaits human review Human reviews the stage output Human approves or denies: # Approve to continue recipes(operation=\"approve\", session_id=\"...\", stage_name=\"planning\") # Deny to stop execution recipes(operation=\"deny\", session_id=\"...\", stage_name=\"planning\", reason=\"Needs revision\") If approved, execution continues to the next stage","title":"Approval Workflow"},{"location":"tools/recipes-tool.html#error-handling","text":"Recipes include built-in error handling and retry logic: steps : - name : api_call agent : foundation:integration-specialist instruction : Call external API retry : max_attempts : 3 delay_seconds : 5 on_error : continue # or 'fail' to stop execution","title":"Error Handling"},{"location":"tools/recipes-tool.html#error-strategies","text":"Strategy Behavior fail Stop execution immediately (default) continue Log error and proceed to next step retry Attempt step again with configured backoff","title":"Error Strategies"},{"location":"tools/recipes-tool.html#best-practices","text":"","title":"Best Practices"},{"location":"tools/recipes-tool.html#1-keep-steps-focused","text":"Each step should do one thing well: # Good: Single responsibility steps : - name : analyze instruction : Analyze code structure - name : review instruction : Review for issues - name : suggest instruction : Suggest improvements # Avoid: Monolithic steps steps : - name : do_everything instruction : Analyze, review, and suggest all at once","title":"1. Keep Steps Focused"},{"location":"tools/recipes-tool.html#2-use-descriptive-names","text":"Step and stage names become part of the context path: # Good: Clear, descriptive steps : - name : security_audit - name : performance_review # Avoid: Generic names steps : - name : step1 - name : step2","title":"2. Use Descriptive Names"},{"location":"tools/recipes-tool.html#3-validate-before-execution","text":"Always validate recipes before running in production: recipes(operation=\"validate\", recipe_path=\"critical-workflow.yaml\")","title":"3. Validate Before Execution"},{"location":"tools/recipes-tool.html#4-design-for-resumability","text":"Structure recipes so they can resume gracefully: Make steps idempotent where possible Use clear checkpoints between major operations Store intermediate results in context","title":"4. Design for Resumability"},{"location":"tools/recipes-tool.html#5-use-approval-gates-for-sensitive-operations","text":"Add human checkpoints for: Production deployments Data migrations External API calls with side effects Operations that cannot be easily reversed","title":"5. Use Approval Gates for Sensitive Operations"},{"location":"tools/recipes-tool.html#6-document-your-recipes","text":"Include clear descriptions: name : data-migration description : | Migrates user data from legacy system to new schema. Prerequisites: - Backup completed - Maintenance window scheduled Context required: - source_db: Legacy database connection - target_db: New database connection","title":"6. Document Your Recipes"},{"location":"tools/recipes-tool.html#try-it-yourself","text":"Create a simple recipe to experience the workflow: 1. Create hello-recipe.yaml : name : hello-world description : A simple introduction to recipes steps : - name : greet agent : foundation:file-ops instruction : | Create a file called hello.txt with the message: \"Hello from Amplifier Recipes!\" - name : verify agent : foundation:file-ops instruction : | Read hello.txt and confirm it contains the greeting. Report the contents. 2. Validate the recipe: amplifier run \"validate hello-recipe.yaml\" 3. Execute it: amplifier run \"execute hello-recipe.yaml\" 4. Check the results: The recipe will create hello.txt and verify its contents, demonstrating the multi-step workflow with context passing between agents.","title":"Try It Yourself"},{"location":"tools/recipes-tool.html#next-steps","text":"Learn about Recipe Schema for advanced options Explore Staged Recipes for complex workflows See Recipe Examples for real-world patterns","title":"Next Steps"},{"location":"tools/search.html","text":"Search Tools (grep & glob) \u00b6 Finding files and searching their contents are fundamental operations in any codebase. Amplifier provides two complementary tools optimized for different search patterns: glob for finding files by name/path, and grep for searching file contents. Understanding when to use each tool will dramatically improve your efficiency. When to Use Each \u00b6 Task Tool Why Find files by name glob Pattern matching on file paths Search file contents grep Regex matching inside files Find all Python files glob **/*.py matches paths Find function definitions grep def function_name in content Locate config files glob **/config.* or **/*.yaml Find TODO comments grep TODO\\|FIXME pattern List files in directory glob src/**/* with path filter Find imports of module grep import module_name Find test files glob **/test_*.py or **/*_test.go Find error messages grep Search for specific strings Rule of Thumb: - Know the filename pattern? Use glob - Know what's inside the file? Use grep - Need both? Combine them (see below) Glob Patterns \u00b6 Glob uses shell-style pattern matching to find files by their paths. Basic Patterns \u00b6 Pattern Matches Example * Any characters in filename *.py matches main.py , test.py ** Any directory depth **/*.md matches docs/api/ref.md ? Single character file?.txt matches file1.txt [abc] Character set [Rr]eadme.md matches both cases [!abc] Negated set [!.]*.py excludes dotfiles Common Use Cases \u00b6 # All Python files in project **/*.py # All files in src directory (one level) src/* # All files in src directory (recursive) src/**/* # Configuration files **/config.* **/*.yaml **/*.json # Test files (Python convention) **/test_*.py **/*_test.py # TypeScript and JavaScript **/*.{ts,tsx,js,jsx} # Markdown documentation docs/**/*.md # Hidden files **/.* # Package manifests **/package.json **/pyproject.toml **/Cargo.toml Glob Parameters \u00b6 glob ( pattern = \"**/*.py\" , # Required: the pattern to match path = \"src\" , # Base directory (default: current) type = \"file\" , # \"file\", \"dir\", or \"any\" exclude = [ \"test_*\" ], # Patterns to exclude include_ignored = False # Search in .gitignore'd dirs ) Examples \u00b6 # Find all Python files glob ( pattern = \"**/*.py\" ) # Find directories named \"tests\" glob ( pattern = \"**/tests\" , type = \"dir\" ) # Find configs, excluding node_modules glob ( pattern = \"**/*.config.js\" , exclude = [ \"node_modules/**\" ]) # Search in normally-ignored directories glob ( pattern = \"**/*.py\" , include_ignored = True ) Grep Patterns \u00b6 Grep searches file contents using regular expressions (regex). Basic Regex \u00b6 Pattern Matches Example . Any single character a.c matches abc , a1c * Zero or more of previous ab*c matches ac , abc , abbc + One or more of previous ab+c matches abc , abbc ? Zero or one of previous ab?c matches ac , abc ^ Start of line ^import matches at line start $ End of line \\);$ matches line-ending ; \\s Whitespace def\\s+\\w+ matches function defs \\w Word character \\w+ matches identifiers \\b Word boundary \\bclass\\b avoids subclass Common Search Patterns \u00b6 # Function definitions (Python) def\\s+\\w+\\s*\\( # Class definitions (Python) class\\s+\\w+ # Import statements ^import\\s+|^from\\s+\\w+\\s+import # TODO/FIXME comments TODO|FIXME|XXX|HACK # Console/print statements console\\.(log|error|warn)|print\\( # Error handling except\\s+\\w+|catch\\s*\\(|\\.catch\\( # API endpoints @(app|router)\\.(get|post|put|delete) # Environment variables os\\.environ|process\\.env # Hardcoded URLs https?://[^\\s\"']+ # SQL-like patterns (potential injection) (SELECT|INSERT|UPDATE|DELETE)\\s+ Grep Parameters \u00b6 grep ( pattern = \"def \\\\ s+ \\\\ w+\" , # Required: regex pattern path = \"src\" , # Directory to search glob = \"*.py\" , # Filter by filename pattern type = \"py\" , # Or use file type shorthand output_mode = \"content\" , # How to display results head_limit = 100 , # Limit results \"-i\" : True , # Case insensitive \"-n\" : True , # Show line numbers \"-A\" : 2 , # Lines after match \"-B\" : 2 , # Lines before match \"-C\" : 3 , # Lines of context (before+after) multiline = True , # Match across lines include_ignored = False # Search ignored directories ) Output Modes \u00b6 Grep supports three output modes for different use cases: files_with_matches (default) \u00b6 Returns only file paths that contain matches. Fast and concise. grep ( pattern = \"async def\" , output_mode = \"files_with_matches\" ) Output: src/api/handlers.py src/services/processor.py src/utils/async_helpers.py Best for: Quick discovery, finding which files to examine. content \u00b6 Returns matching lines with context. Most detailed output. grep ( pattern = \"class.*Error\" , output_mode = \"content\" , \"-n\" : True , \"-C\" : 2 ) Output: src/exceptions.py 12: 13: # Custom application errors 14: class ValidationError(Exception): 15: \"\"\"Raised when input validation fails.\"\"\" 16: pass Best for: Understanding context, code review, detailed analysis. count \u00b6 Returns match counts per file. Great for metrics. grep ( pattern = \"TODO\" , output_mode = \"count\" ) Output: src/api/routes.py: 3 src/models/user.py: 1 src/services/auth.py: 7 Best for: Codebase metrics, prioritizing refactoring, finding hotspots. Combining Tools \u00b6 The most powerful searches combine glob and grep. Pattern 1: Filter by File Type Then Search \u00b6 # Find all config files, then search for database settings files = glob ( pattern = \"**/*.yaml\" ) grep ( pattern = \"database:\" , path = \".\" , glob = \"*.yaml\" ) Pattern 2: Use Grep's Built-in Filtering \u00b6 # Search only in Python files grep ( pattern = \"import requests\" , type = \"py\" ) # Search only in specific directory with glob filter grep ( pattern = \"async def\" , path = \"src/api\" , glob = \"*.py\" ) Pattern 3: Progressive Refinement \u00b6 # Step 1: Find all test files glob ( pattern = \"**/test_*.py\" ) # Step 2: Find tests that use mocking grep ( pattern = \"@patch|Mock\\(\" , glob = \"**/test_*.py\" ) # Step 3: Find specific mock patterns with context grep ( pattern = \"@patch.*database\" , glob = \"**/test_*.py\" , output_mode = \"content\" , \"-C\" : 3 ) Pattern 4: Cross-Reference \u00b6 # Find where a class is defined grep ( pattern = \"^class UserService\" , type = \"py\" ) # Result: src/services/user.py # Find all usages of that class grep ( pattern = \"UserService\" , type = \"py\" , output_mode = \"content\" ) Best Practices \u00b6 1. Start Broad, Then Narrow \u00b6 # Too specific - might miss variations grep ( pattern = \"def getUserById\" ) # Better - find all user-related functions grep ( pattern = \"def.*[Uu]ser\" , type = \"py\" ) 2. Use Type Filters for Speed \u00b6 # Slower - searches all files grep ( pattern = \"import\" , path = \".\" ) # Faster - only Python files grep ( pattern = \"import\" , type = \"py\" ) 3. Limit Results to Avoid Overload \u00b6 # Could return thousands of matches grep ( pattern = \"def \" ) # Better - limit and paginate grep ( pattern = \"def \" , head_limit = 50 , offset = 0 ) 4. Use Word Boundaries for Precision \u00b6 # Matches \"class\", \"subclass\", \"classification\" grep ( pattern = \"class\" ) # Matches only \"class\" keyword grep ( pattern = \" \\\\ bclass \\\\ b\" ) 5. Escape Special Characters \u00b6 # Wrong - . matches any character grep ( pattern = \"config.yaml\" ) # Correct - \\. matches literal dot grep ( pattern = \"config \\\\ .yaml\" ) 6. Use Case Insensitivity When Appropriate \u00b6 # Find README regardless of case grep ( pattern = \"readme\" , \"-i\" : True ) Try It Yourself \u00b6 Exercise 1: Find All API Routes \u00b6 Find files that define HTTP endpoints in a Python Flask/FastAPI project. # Your solution: grep ( pattern = \"@(app|router) \\\\ .(get|post|put|delete|patch)\" , type = \"py\" ) Exercise 2: Locate Configuration Files \u00b6 Find all YAML and JSON configuration files, excluding test fixtures. # Your solution: glob ( pattern = \"**/*.{yaml,yml,json}\" , exclude = [ \"**/fixtures/**\" , \"**/test/**\" ]) Exercise 3: Find Unused Imports \u00b6 Search for import statements that might be unused (import but no usage). # Step 1: Find all imports grep ( pattern = \"^from \\\\ s+ \\\\ w+ \\\\ s+import \\\\ s+( \\\\ w+)\" , type = \"py\" , output_mode = \"content\" ) # Step 2: For each import, search for usages (manual verification needed) Exercise 4: Count TODOs by Directory \u00b6 Get a count of TODO comments to prioritize cleanup. grep ( pattern = \"TODO|FIXME\" , output_mode = \"count\" ) Exercise 5: Find Large Functions \u00b6 Find function definitions and use context to assess complexity. grep ( pattern = \"^ \\\\ s*def \\\\ s+ \\\\ w+\" , type = \"py\" , output_mode = \"content\" , \"-A\" : 30 ) Common Errors and Solutions \u00b6 Error: \"Pattern not found\" \u00b6 Cause: Pattern doesn't match any content, or wrong file type filter. Solution: # Check if files exist first glob ( pattern = \"**/*.py\" ) # Try broader pattern grep ( pattern = \"user\" , type = \"py\" ) # Instead of \"UserService\" Error: \"Too many results\" \u00b6 Cause: Pattern too broad, missing filters. Solution: # Add file type filter grep ( pattern = \"import\" , type = \"py\" ) # Limit results grep ( pattern = \"import\" , head_limit = 100 ) # Narrow the path grep ( pattern = \"import\" , path = \"src/api\" ) Error: \"Regex syntax error\" \u00b6 Cause: Unescaped special characters or invalid regex. Solution: # Escape special characters grep ( pattern = \" \\\\ [.* \\\\ ]\" ) # Match brackets grep ( pattern = \" \\\\ $ \\\\ w+\" ) # Match $variables grep ( pattern = \"file \\\\ .txt\" ) # Match literal dot Error: \"Results include unwanted directories\" \u00b6 Cause: Searching in node_modules, .venv, etc. Solution: # These are excluded by default, but if you used include_ignored: grep ( pattern = \"import\" , include_ignored = False ) # Default behavior # Or use explicit exclusions in glob glob ( pattern = \"**/*.py\" , exclude = [ \"**/venv/**\" , \"**/.venv/**\" ]) Quick Reference \u00b6 Operation Command Find Python files glob(pattern=\"**/*.py\") Find in directory glob(pattern=\"src/**/*\") Search content grep(pattern=\"def main\") Case insensitive grep(pattern=\"error\", \"-i\": True) With context grep(pattern=\"error\", \"-C\": 3) Count matches grep(pattern=\"TODO\", output_mode=\"count\") Files only grep(pattern=\"class\", output_mode=\"files_with_matches\") Filter by type grep(pattern=\"import\", type=\"py\") Summary \u00b6 glob : Find files by path patterns ( **/*.py , src/**/*.ts ) grep : Search file contents with regex ( def\\s+\\w+ , TODO|FIXME ) Combine them : Use glob to find files, grep to search contents Output modes : files_with_matches (fast), content (detailed), count (metrics) Best practice : Start broad, filter by type, limit results, use word boundaries","title":"Search (grep & glob)"},{"location":"tools/search.html#search-tools-grep-glob","text":"Finding files and searching their contents are fundamental operations in any codebase. Amplifier provides two complementary tools optimized for different search patterns: glob for finding files by name/path, and grep for searching file contents. Understanding when to use each tool will dramatically improve your efficiency.","title":"Search Tools (grep &amp; glob)"},{"location":"tools/search.html#when-to-use-each","text":"Task Tool Why Find files by name glob Pattern matching on file paths Search file contents grep Regex matching inside files Find all Python files glob **/*.py matches paths Find function definitions grep def function_name in content Locate config files glob **/config.* or **/*.yaml Find TODO comments grep TODO\\|FIXME pattern List files in directory glob src/**/* with path filter Find imports of module grep import module_name Find test files glob **/test_*.py or **/*_test.go Find error messages grep Search for specific strings Rule of Thumb: - Know the filename pattern? Use glob - Know what's inside the file? Use grep - Need both? Combine them (see below)","title":"When to Use Each"},{"location":"tools/search.html#glob-patterns","text":"Glob uses shell-style pattern matching to find files by their paths.","title":"Glob Patterns"},{"location":"tools/search.html#basic-patterns","text":"Pattern Matches Example * Any characters in filename *.py matches main.py , test.py ** Any directory depth **/*.md matches docs/api/ref.md ? Single character file?.txt matches file1.txt [abc] Character set [Rr]eadme.md matches both cases [!abc] Negated set [!.]*.py excludes dotfiles","title":"Basic Patterns"},{"location":"tools/search.html#common-use-cases","text":"# All Python files in project **/*.py # All files in src directory (one level) src/* # All files in src directory (recursive) src/**/* # Configuration files **/config.* **/*.yaml **/*.json # Test files (Python convention) **/test_*.py **/*_test.py # TypeScript and JavaScript **/*.{ts,tsx,js,jsx} # Markdown documentation docs/**/*.md # Hidden files **/.* # Package manifests **/package.json **/pyproject.toml **/Cargo.toml","title":"Common Use Cases"},{"location":"tools/search.html#glob-parameters","text":"glob ( pattern = \"**/*.py\" , # Required: the pattern to match path = \"src\" , # Base directory (default: current) type = \"file\" , # \"file\", \"dir\", or \"any\" exclude = [ \"test_*\" ], # Patterns to exclude include_ignored = False # Search in .gitignore'd dirs )","title":"Glob Parameters"},{"location":"tools/search.html#examples","text":"# Find all Python files glob ( pattern = \"**/*.py\" ) # Find directories named \"tests\" glob ( pattern = \"**/tests\" , type = \"dir\" ) # Find configs, excluding node_modules glob ( pattern = \"**/*.config.js\" , exclude = [ \"node_modules/**\" ]) # Search in normally-ignored directories glob ( pattern = \"**/*.py\" , include_ignored = True )","title":"Examples"},{"location":"tools/search.html#grep-patterns","text":"Grep searches file contents using regular expressions (regex).","title":"Grep Patterns"},{"location":"tools/search.html#basic-regex","text":"Pattern Matches Example . Any single character a.c matches abc , a1c * Zero or more of previous ab*c matches ac , abc , abbc + One or more of previous ab+c matches abc , abbc ? Zero or one of previous ab?c matches ac , abc ^ Start of line ^import matches at line start $ End of line \\);$ matches line-ending ; \\s Whitespace def\\s+\\w+ matches function defs \\w Word character \\w+ matches identifiers \\b Word boundary \\bclass\\b avoids subclass","title":"Basic Regex"},{"location":"tools/search.html#common-search-patterns","text":"# Function definitions (Python) def\\s+\\w+\\s*\\( # Class definitions (Python) class\\s+\\w+ # Import statements ^import\\s+|^from\\s+\\w+\\s+import # TODO/FIXME comments TODO|FIXME|XXX|HACK # Console/print statements console\\.(log|error|warn)|print\\( # Error handling except\\s+\\w+|catch\\s*\\(|\\.catch\\( # API endpoints @(app|router)\\.(get|post|put|delete) # Environment variables os\\.environ|process\\.env # Hardcoded URLs https?://[^\\s\"']+ # SQL-like patterns (potential injection) (SELECT|INSERT|UPDATE|DELETE)\\s+","title":"Common Search Patterns"},{"location":"tools/search.html#grep-parameters","text":"grep ( pattern = \"def \\\\ s+ \\\\ w+\" , # Required: regex pattern path = \"src\" , # Directory to search glob = \"*.py\" , # Filter by filename pattern type = \"py\" , # Or use file type shorthand output_mode = \"content\" , # How to display results head_limit = 100 , # Limit results \"-i\" : True , # Case insensitive \"-n\" : True , # Show line numbers \"-A\" : 2 , # Lines after match \"-B\" : 2 , # Lines before match \"-C\" : 3 , # Lines of context (before+after) multiline = True , # Match across lines include_ignored = False # Search ignored directories )","title":"Grep Parameters"},{"location":"tools/search.html#output-modes","text":"Grep supports three output modes for different use cases:","title":"Output Modes"},{"location":"tools/search.html#files_with_matches-default","text":"Returns only file paths that contain matches. Fast and concise. grep ( pattern = \"async def\" , output_mode = \"files_with_matches\" ) Output: src/api/handlers.py src/services/processor.py src/utils/async_helpers.py Best for: Quick discovery, finding which files to examine.","title":"files_with_matches (default)"},{"location":"tools/search.html#content","text":"Returns matching lines with context. Most detailed output. grep ( pattern = \"class.*Error\" , output_mode = \"content\" , \"-n\" : True , \"-C\" : 2 ) Output: src/exceptions.py 12: 13: # Custom application errors 14: class ValidationError(Exception): 15: \"\"\"Raised when input validation fails.\"\"\" 16: pass Best for: Understanding context, code review, detailed analysis.","title":"content"},{"location":"tools/search.html#count","text":"Returns match counts per file. Great for metrics. grep ( pattern = \"TODO\" , output_mode = \"count\" ) Output: src/api/routes.py: 3 src/models/user.py: 1 src/services/auth.py: 7 Best for: Codebase metrics, prioritizing refactoring, finding hotspots.","title":"count"},{"location":"tools/search.html#combining-tools","text":"The most powerful searches combine glob and grep.","title":"Combining Tools"},{"location":"tools/search.html#pattern-1-filter-by-file-type-then-search","text":"# Find all config files, then search for database settings files = glob ( pattern = \"**/*.yaml\" ) grep ( pattern = \"database:\" , path = \".\" , glob = \"*.yaml\" )","title":"Pattern 1: Filter by File Type Then Search"},{"location":"tools/search.html#pattern-2-use-greps-built-in-filtering","text":"# Search only in Python files grep ( pattern = \"import requests\" , type = \"py\" ) # Search only in specific directory with glob filter grep ( pattern = \"async def\" , path = \"src/api\" , glob = \"*.py\" )","title":"Pattern 2: Use Grep's Built-in Filtering"},{"location":"tools/search.html#pattern-3-progressive-refinement","text":"# Step 1: Find all test files glob ( pattern = \"**/test_*.py\" ) # Step 2: Find tests that use mocking grep ( pattern = \"@patch|Mock\\(\" , glob = \"**/test_*.py\" ) # Step 3: Find specific mock patterns with context grep ( pattern = \"@patch.*database\" , glob = \"**/test_*.py\" , output_mode = \"content\" , \"-C\" : 3 )","title":"Pattern 3: Progressive Refinement"},{"location":"tools/search.html#pattern-4-cross-reference","text":"# Find where a class is defined grep ( pattern = \"^class UserService\" , type = \"py\" ) # Result: src/services/user.py # Find all usages of that class grep ( pattern = \"UserService\" , type = \"py\" , output_mode = \"content\" )","title":"Pattern 4: Cross-Reference"},{"location":"tools/search.html#best-practices","text":"","title":"Best Practices"},{"location":"tools/search.html#1-start-broad-then-narrow","text":"# Too specific - might miss variations grep ( pattern = \"def getUserById\" ) # Better - find all user-related functions grep ( pattern = \"def.*[Uu]ser\" , type = \"py\" )","title":"1. Start Broad, Then Narrow"},{"location":"tools/search.html#2-use-type-filters-for-speed","text":"# Slower - searches all files grep ( pattern = \"import\" , path = \".\" ) # Faster - only Python files grep ( pattern = \"import\" , type = \"py\" )","title":"2. Use Type Filters for Speed"},{"location":"tools/search.html#3-limit-results-to-avoid-overload","text":"# Could return thousands of matches grep ( pattern = \"def \" ) # Better - limit and paginate grep ( pattern = \"def \" , head_limit = 50 , offset = 0 )","title":"3. Limit Results to Avoid Overload"},{"location":"tools/search.html#4-use-word-boundaries-for-precision","text":"# Matches \"class\", \"subclass\", \"classification\" grep ( pattern = \"class\" ) # Matches only \"class\" keyword grep ( pattern = \" \\\\ bclass \\\\ b\" )","title":"4. Use Word Boundaries for Precision"},{"location":"tools/search.html#5-escape-special-characters","text":"# Wrong - . matches any character grep ( pattern = \"config.yaml\" ) # Correct - \\. matches literal dot grep ( pattern = \"config \\\\ .yaml\" )","title":"5. Escape Special Characters"},{"location":"tools/search.html#6-use-case-insensitivity-when-appropriate","text":"# Find README regardless of case grep ( pattern = \"readme\" , \"-i\" : True )","title":"6. Use Case Insensitivity When Appropriate"},{"location":"tools/search.html#try-it-yourself","text":"","title":"Try It Yourself"},{"location":"tools/search.html#exercise-1-find-all-api-routes","text":"Find files that define HTTP endpoints in a Python Flask/FastAPI project. # Your solution: grep ( pattern = \"@(app|router) \\\\ .(get|post|put|delete|patch)\" , type = \"py\" )","title":"Exercise 1: Find All API Routes"},{"location":"tools/search.html#exercise-2-locate-configuration-files","text":"Find all YAML and JSON configuration files, excluding test fixtures. # Your solution: glob ( pattern = \"**/*.{yaml,yml,json}\" , exclude = [ \"**/fixtures/**\" , \"**/test/**\" ])","title":"Exercise 2: Locate Configuration Files"},{"location":"tools/search.html#exercise-3-find-unused-imports","text":"Search for import statements that might be unused (import but no usage). # Step 1: Find all imports grep ( pattern = \"^from \\\\ s+ \\\\ w+ \\\\ s+import \\\\ s+( \\\\ w+)\" , type = \"py\" , output_mode = \"content\" ) # Step 2: For each import, search for usages (manual verification needed)","title":"Exercise 3: Find Unused Imports"},{"location":"tools/search.html#exercise-4-count-todos-by-directory","text":"Get a count of TODO comments to prioritize cleanup. grep ( pattern = \"TODO|FIXME\" , output_mode = \"count\" )","title":"Exercise 4: Count TODOs by Directory"},{"location":"tools/search.html#exercise-5-find-large-functions","text":"Find function definitions and use context to assess complexity. grep ( pattern = \"^ \\\\ s*def \\\\ s+ \\\\ w+\" , type = \"py\" , output_mode = \"content\" , \"-A\" : 30 )","title":"Exercise 5: Find Large Functions"},{"location":"tools/search.html#common-errors-and-solutions","text":"","title":"Common Errors and Solutions"},{"location":"tools/search.html#error-pattern-not-found","text":"Cause: Pattern doesn't match any content, or wrong file type filter. Solution: # Check if files exist first glob ( pattern = \"**/*.py\" ) # Try broader pattern grep ( pattern = \"user\" , type = \"py\" ) # Instead of \"UserService\"","title":"Error: \"Pattern not found\""},{"location":"tools/search.html#error-too-many-results","text":"Cause: Pattern too broad, missing filters. Solution: # Add file type filter grep ( pattern = \"import\" , type = \"py\" ) # Limit results grep ( pattern = \"import\" , head_limit = 100 ) # Narrow the path grep ( pattern = \"import\" , path = \"src/api\" )","title":"Error: \"Too many results\""},{"location":"tools/search.html#error-regex-syntax-error","text":"Cause: Unescaped special characters or invalid regex. Solution: # Escape special characters grep ( pattern = \" \\\\ [.* \\\\ ]\" ) # Match brackets grep ( pattern = \" \\\\ $ \\\\ w+\" ) # Match $variables grep ( pattern = \"file \\\\ .txt\" ) # Match literal dot","title":"Error: \"Regex syntax error\""},{"location":"tools/search.html#error-results-include-unwanted-directories","text":"Cause: Searching in node_modules, .venv, etc. Solution: # These are excluded by default, but if you used include_ignored: grep ( pattern = \"import\" , include_ignored = False ) # Default behavior # Or use explicit exclusions in glob glob ( pattern = \"**/*.py\" , exclude = [ \"**/venv/**\" , \"**/.venv/**\" ])","title":"Error: \"Results include unwanted directories\""},{"location":"tools/search.html#quick-reference","text":"Operation Command Find Python files glob(pattern=\"**/*.py\") Find in directory glob(pattern=\"src/**/*\") Search content grep(pattern=\"def main\") Case insensitive grep(pattern=\"error\", \"-i\": True) With context grep(pattern=\"error\", \"-C\": 3) Count matches grep(pattern=\"TODO\", output_mode=\"count\") Files only grep(pattern=\"class\", output_mode=\"files_with_matches\") Filter by type grep(pattern=\"import\", type=\"py\")","title":"Quick Reference"},{"location":"tools/search.html#summary","text":"glob : Find files by path patterns ( **/*.py , src/**/*.ts ) grep : Search file contents with regex ( def\\s+\\w+ , TODO|FIXME ) Combine them : Use glob to find files, grep to search contents Output modes : files_with_matches (fast), content (detailed), count (metrics) Best practice : Start broad, filter by type, limit results, use word boundaries","title":"Summary"},{"location":"tools/task.html","text":"Task Tool (Sub-Agents) \u00b6 The Task tool is Amplifier's delegation system. It launches specialized agents to handle complex tasks autonomously, allowing you to break down sophisticated workflows into manageable, parallelizable units of work. What is Delegation? \u00b6 Delegation means spawning a sub-agent with its own context, tools, and focus area. Think of it as hiring a specialist: You (main agent) --> Task tool --> Sub-agent (specialist) | v Works autonomously | v Returns final report Key characteristics: Stateless invocations : Each agent call starts fresh with no memory of previous calls Autonomous execution : Sub-agents work independently until completion Single response : You receive one final report, not a conversation Specialized tools : Each agent type has access to different tool sets The main agent remains focused on orchestration while specialists handle domain-specific work. When to Delegate \u00b6 Delegation is appropriate when a task requires: Exploration Tasks \u00b6 When you need to understand a codebase, find patterns, or gather information: Use foundation:explorer when: - Mapping module dependencies - Finding all usages of a pattern - Understanding system architecture - Gathering context across many files Git Operations (ALWAYS Delegate) \u00b6 Critical rule : Never use bash directly for git commands. Always delegate to git-ops: Use foundation:git-ops for: - Creating commits (generates proper messages) - Branch operations - Creating/managing PRs - Conflict resolution - Multi-repo sync The git-ops agent has safety protocols and follows commit message standards. Debugging \u00b6 When encountering errors, test failures, or unexpected behavior: Use foundation:bug-hunter when: - User reports an error - Tests are failing - Behavior doesn't match expectations - You need hypothesis-driven investigation Large Context Tasks \u00b6 When the work requires more context than fits in a single conversation: Delegate when: - Refactoring spans many files - Analysis requires reading extensive code - The task has multiple independent phases When NOT to Delegate \u00b6 Avoid the task tool for: Reading a specific file (use read_file directly) Finding a class definition (use glob or grep) Simple file edits (use edit_file directly) Tasks requiring back-and-forth conversation Available Agents \u00b6 Agent Purpose Key Capabilities foundation:explorer Codebase reconnaissance Deep file analysis, pattern discovery foundation:git-ops Git and GitHub operations Commits, PRs, branches, safety checks foundation:bug-hunter Systematic debugging Hypothesis-driven investigation foundation:zen-architect Design and review Architecture, specifications, code review foundation:modular-builder Implementation Build from specifications foundation:web-research External information Web search, documentation lookup foundation:test-coverage Test analysis Coverage gaps, test suggestions foundation:security-guardian Security review Vulnerability assessment, audits foundation:file-ops File operations Read, write, edit, search files foundation:session-analyst Session debugging Analyze/repair Amplifier sessions Specialized Domain Agents \u00b6 Agent Purpose amplifier:amplifier-expert Amplifier ecosystem guidance core:core-expert Kernel internals and protocols foundation:foundation-expert Bundle composition patterns lsp-python:python-code-intel Python semantic analysis Parallel Execution \u00b6 One of the Task tool's most powerful features is parallel agent execution. Launch multiple independent agents simultaneously: # CORRECT: Multiple independent calls in one message block - task(agent=\"foundation:explorer\", instruction=\"Map auth module\") - task(agent=\"foundation:explorer\", instruction=\"Map database layer\") - task(agent=\"foundation:web-research\", instruction=\"Find JWT best practices\") All three agents run concurrently, dramatically reducing total execution time. When to Parallelize \u00b6 Parallelize when tasks are independent : Good candidates for parallel execution: - Exploring different parts of a codebase - Running multiple analyses - Gathering information from different sources - Building independent modules When NOT to Parallelize \u00b6 Use sequential execution when tasks have dependencies : Run sequentially when: - Task B needs output from Task A - You need to decide next steps based on results - Operations must happen in a specific order Example of dependent tasks (must be sequential): 1. zen-architect designs the module specification 2. modular-builder implements from that specification 3. test-coverage analyzes the implementation Session Resumption \u00b6 Each task invocation returns a session_id . You can resume interrupted sessions: # Initial call task : agent : foundation:explorer instruction : \"Deep analysis of payment system\" # Returns: session_id: \"abc123...\" # Resume if interrupted task : session_id : \"abc123...\" instruction : \"Continue from where you left off\" When to Use Session Resumption \u00b6 Agent was interrupted mid-task You need to provide additional context to the same agent Long-running analysis needs continuation Limitations \u00b6 Sessions are stateless between invocations by default Resumption requires the original session_id Not all agents support meaningful resumption Best Practices \u00b6 1. Write Detailed Instructions \u00b6 Sub-agents have no context beyond what you provide. Be explicit: # BAD: Vague instruction instruction : \"Fix the bug\" # GOOD: Complete context instruction : | Investigate the KeyError in src/auth/login.py:45. The error occurs when users log in with OAuth. Check the token validation flow and session handling. Return: root cause, affected code paths, and fix recommendation. 2. Specify Expected Output \u00b6 Tell agents exactly what you need back: instruction : | Analyze the caching implementation. Return in your final report: 1. List of all cache keys used 2. TTL settings for each cache type 3. Potential race conditions identified 4. Recommendations for improvement 3. Choose the Right Agent \u00b6 Match the task to the specialist: Task Agent \"What does this code do?\" explorer \"Commit these changes\" git-ops \"Why is this failing?\" bug-hunter \"Design a new feature\" zen-architect \"Implement this spec\" modular-builder 4. Trust Agent Results \u00b6 Agent outputs are generally reliable. Use their findings directly rather than re-verifying everything manually. 5. Summarize for Users \u00b6 Agent results are not shown to users automatically. Always summarize: # After receiving agent report \"The explorer agent found that authentication spans 12 modules. The main entry point is src/auth/handler.py. Key finding: the session manager has a potential race condition.\" Try It Yourself \u00b6 Exercise 1: Parallel Exploration \u00b6 Ask Amplifier to explore two different areas of a codebase simultaneously: \"Explore both the API layer and the database models in parallel. I need to understand how they connect.\" Watch as two explorer agents work concurrently. Exercise 2: The Full Pipeline \u00b6 Request a feature that uses multiple agents: \"Design and implement a rate limiting feature for the API. Use zen-architect for design, then modular-builder for implementation.\" Observe the handoff between agents. Exercise 3: Debugging Delegation \u00b6 Report a bug and let bug-hunter investigate: \"The /api/users endpoint returns 500 errors intermittently. Use bug-hunter to find the root cause.\" Common Errors \u00b6 \"Session spawning not available\" \u00b6 The app layer hasn't registered session spawning capability. This typically means: - You're in a restricted environment - The bundle configuration doesn't include task delegation - Check your bundle's capabilities \"Agent not found\" \u00b6 The specified agent doesn't exist or isn't available: # Check agent name format agent: \"collection:agent-name\" # Common mistakes: - \"explorer\" (missing collection prefix) - \"foundation/explorer\" (wrong separator) - \"Foundation:explorer\" (case sensitive) \"Instruction required\" \u00b6 Every task call needs an instruction: # This will fail task : agent : foundation:explorer # This works task : agent : foundation:explorer instruction : \"Analyze the src/ directory structure\" Timeout Errors \u00b6 Complex tasks may timeout. Solutions: - Break into smaller sub-tasks - Provide more focused instructions - Use session resumption for long-running work Summary \u00b6 The Task tool enables powerful multi-agent workflows: Delegate complex work to specialized agents Parallelize independent tasks for efficiency Resume interrupted sessions when needed Trust agent results and summarize for users Master delegation to unlock Amplifier's full potential for sophisticated, multi-step software engineering tasks.","title":"Task (Sub-Agents)"},{"location":"tools/task.html#task-tool-sub-agents","text":"The Task tool is Amplifier's delegation system. It launches specialized agents to handle complex tasks autonomously, allowing you to break down sophisticated workflows into manageable, parallelizable units of work.","title":"Task Tool (Sub-Agents)"},{"location":"tools/task.html#what-is-delegation","text":"Delegation means spawning a sub-agent with its own context, tools, and focus area. Think of it as hiring a specialist: You (main agent) --> Task tool --> Sub-agent (specialist) | v Works autonomously | v Returns final report Key characteristics: Stateless invocations : Each agent call starts fresh with no memory of previous calls Autonomous execution : Sub-agents work independently until completion Single response : You receive one final report, not a conversation Specialized tools : Each agent type has access to different tool sets The main agent remains focused on orchestration while specialists handle domain-specific work.","title":"What is Delegation?"},{"location":"tools/task.html#when-to-delegate","text":"Delegation is appropriate when a task requires:","title":"When to Delegate"},{"location":"tools/task.html#exploration-tasks","text":"When you need to understand a codebase, find patterns, or gather information: Use foundation:explorer when: - Mapping module dependencies - Finding all usages of a pattern - Understanding system architecture - Gathering context across many files","title":"Exploration Tasks"},{"location":"tools/task.html#git-operations-always-delegate","text":"Critical rule : Never use bash directly for git commands. Always delegate to git-ops: Use foundation:git-ops for: - Creating commits (generates proper messages) - Branch operations - Creating/managing PRs - Conflict resolution - Multi-repo sync The git-ops agent has safety protocols and follows commit message standards.","title":"Git Operations (ALWAYS Delegate)"},{"location":"tools/task.html#debugging","text":"When encountering errors, test failures, or unexpected behavior: Use foundation:bug-hunter when: - User reports an error - Tests are failing - Behavior doesn't match expectations - You need hypothesis-driven investigation","title":"Debugging"},{"location":"tools/task.html#large-context-tasks","text":"When the work requires more context than fits in a single conversation: Delegate when: - Refactoring spans many files - Analysis requires reading extensive code - The task has multiple independent phases","title":"Large Context Tasks"},{"location":"tools/task.html#when-not-to-delegate","text":"Avoid the task tool for: Reading a specific file (use read_file directly) Finding a class definition (use glob or grep) Simple file edits (use edit_file directly) Tasks requiring back-and-forth conversation","title":"When NOT to Delegate"},{"location":"tools/task.html#available-agents","text":"Agent Purpose Key Capabilities foundation:explorer Codebase reconnaissance Deep file analysis, pattern discovery foundation:git-ops Git and GitHub operations Commits, PRs, branches, safety checks foundation:bug-hunter Systematic debugging Hypothesis-driven investigation foundation:zen-architect Design and review Architecture, specifications, code review foundation:modular-builder Implementation Build from specifications foundation:web-research External information Web search, documentation lookup foundation:test-coverage Test analysis Coverage gaps, test suggestions foundation:security-guardian Security review Vulnerability assessment, audits foundation:file-ops File operations Read, write, edit, search files foundation:session-analyst Session debugging Analyze/repair Amplifier sessions","title":"Available Agents"},{"location":"tools/task.html#specialized-domain-agents","text":"Agent Purpose amplifier:amplifier-expert Amplifier ecosystem guidance core:core-expert Kernel internals and protocols foundation:foundation-expert Bundle composition patterns lsp-python:python-code-intel Python semantic analysis","title":"Specialized Domain Agents"},{"location":"tools/task.html#parallel-execution","text":"One of the Task tool's most powerful features is parallel agent execution. Launch multiple independent agents simultaneously: # CORRECT: Multiple independent calls in one message block - task(agent=\"foundation:explorer\", instruction=\"Map auth module\") - task(agent=\"foundation:explorer\", instruction=\"Map database layer\") - task(agent=\"foundation:web-research\", instruction=\"Find JWT best practices\") All three agents run concurrently, dramatically reducing total execution time.","title":"Parallel Execution"},{"location":"tools/task.html#when-to-parallelize","text":"Parallelize when tasks are independent : Good candidates for parallel execution: - Exploring different parts of a codebase - Running multiple analyses - Gathering information from different sources - Building independent modules","title":"When to Parallelize"},{"location":"tools/task.html#when-not-to-parallelize","text":"Use sequential execution when tasks have dependencies : Run sequentially when: - Task B needs output from Task A - You need to decide next steps based on results - Operations must happen in a specific order Example of dependent tasks (must be sequential): 1. zen-architect designs the module specification 2. modular-builder implements from that specification 3. test-coverage analyzes the implementation","title":"When NOT to Parallelize"},{"location":"tools/task.html#session-resumption","text":"Each task invocation returns a session_id . You can resume interrupted sessions: # Initial call task : agent : foundation:explorer instruction : \"Deep analysis of payment system\" # Returns: session_id: \"abc123...\" # Resume if interrupted task : session_id : \"abc123...\" instruction : \"Continue from where you left off\"","title":"Session Resumption"},{"location":"tools/task.html#when-to-use-session-resumption","text":"Agent was interrupted mid-task You need to provide additional context to the same agent Long-running analysis needs continuation","title":"When to Use Session Resumption"},{"location":"tools/task.html#limitations","text":"Sessions are stateless between invocations by default Resumption requires the original session_id Not all agents support meaningful resumption","title":"Limitations"},{"location":"tools/task.html#best-practices","text":"","title":"Best Practices"},{"location":"tools/task.html#1-write-detailed-instructions","text":"Sub-agents have no context beyond what you provide. Be explicit: # BAD: Vague instruction instruction : \"Fix the bug\" # GOOD: Complete context instruction : | Investigate the KeyError in src/auth/login.py:45. The error occurs when users log in with OAuth. Check the token validation flow and session handling. Return: root cause, affected code paths, and fix recommendation.","title":"1. Write Detailed Instructions"},{"location":"tools/task.html#2-specify-expected-output","text":"Tell agents exactly what you need back: instruction : | Analyze the caching implementation. Return in your final report: 1. List of all cache keys used 2. TTL settings for each cache type 3. Potential race conditions identified 4. Recommendations for improvement","title":"2. Specify Expected Output"},{"location":"tools/task.html#3-choose-the-right-agent","text":"Match the task to the specialist: Task Agent \"What does this code do?\" explorer \"Commit these changes\" git-ops \"Why is this failing?\" bug-hunter \"Design a new feature\" zen-architect \"Implement this spec\" modular-builder","title":"3. Choose the Right Agent"},{"location":"tools/task.html#4-trust-agent-results","text":"Agent outputs are generally reliable. Use their findings directly rather than re-verifying everything manually.","title":"4. Trust Agent Results"},{"location":"tools/task.html#5-summarize-for-users","text":"Agent results are not shown to users automatically. Always summarize: # After receiving agent report \"The explorer agent found that authentication spans 12 modules. The main entry point is src/auth/handler.py. Key finding: the session manager has a potential race condition.\"","title":"5. Summarize for Users"},{"location":"tools/task.html#try-it-yourself","text":"","title":"Try It Yourself"},{"location":"tools/task.html#exercise-1-parallel-exploration","text":"Ask Amplifier to explore two different areas of a codebase simultaneously: \"Explore both the API layer and the database models in parallel. I need to understand how they connect.\" Watch as two explorer agents work concurrently.","title":"Exercise 1: Parallel Exploration"},{"location":"tools/task.html#exercise-2-the-full-pipeline","text":"Request a feature that uses multiple agents: \"Design and implement a rate limiting feature for the API. Use zen-architect for design, then modular-builder for implementation.\" Observe the handoff between agents.","title":"Exercise 2: The Full Pipeline"},{"location":"tools/task.html#exercise-3-debugging-delegation","text":"Report a bug and let bug-hunter investigate: \"The /api/users endpoint returns 500 errors intermittently. Use bug-hunter to find the root cause.\"","title":"Exercise 3: Debugging Delegation"},{"location":"tools/task.html#common-errors","text":"","title":"Common Errors"},{"location":"tools/task.html#session-spawning-not-available","text":"The app layer hasn't registered session spawning capability. This typically means: - You're in a restricted environment - The bundle configuration doesn't include task delegation - Check your bundle's capabilities","title":"\"Session spawning not available\""},{"location":"tools/task.html#agent-not-found","text":"The specified agent doesn't exist or isn't available: # Check agent name format agent: \"collection:agent-name\" # Common mistakes: - \"explorer\" (missing collection prefix) - \"foundation/explorer\" (wrong separator) - \"Foundation:explorer\" (case sensitive)","title":"\"Agent not found\""},{"location":"tools/task.html#instruction-required","text":"Every task call needs an instruction: # This will fail task : agent : foundation:explorer # This works task : agent : foundation:explorer instruction : \"Analyze the src/ directory structure\"","title":"\"Instruction required\""},{"location":"tools/task.html#timeout-errors","text":"Complex tasks may timeout. Solutions: - Break into smaller sub-tasks - Provide more focused instructions - Use session resumption for long-running work","title":"Timeout Errors"},{"location":"tools/task.html#summary","text":"The Task tool enables powerful multi-agent workflows: Delegate complex work to specialized agents Parallelize independent tasks for efficiency Resume interrupted sessions when needed Trust agent results and summarize for users Master delegation to unlock Amplifier's full potential for sophisticated, multi-step software engineering tasks.","title":"Summary"},{"location":"tools/web.html","text":"Web Tools \u00b6 Web tools extend your AI assistant's capabilities beyond local files and code, enabling real-time information retrieval from the internet. These tools are essential for research, documentation lookup, API exploration, and staying current with rapidly evolving technologies. Operations \u00b6 Tool Purpose web_search Search the internet for information web_fetch Fetch and parse content from a URL Both tools work together: use web_search to discover relevant URLs, then web_fetch to retrieve detailed content from specific pages. Web Search \u00b6 The web_search tool queries the internet and returns relevant results. Basic Usage \u00b6 User: Search for Python asyncio best practices The assistant will use web_search to find current articles, documentation, and discussions about the topic. When to Use Web Search \u00b6 Documentation lookup : Find official docs for libraries and frameworks Error resolution : Search for error messages and solutions Best practices : Discover current recommendations and patterns News and updates : Get latest information about technologies Comparative research : Find comparisons between tools or approaches Search Tips \u00b6 Be specific : \"FastAPI dependency injection tutorial\" beats \"FastAPI help\" Include context : Add version numbers or specific use cases Use quotes : For exact phrases or error messages Combine terms : \"React hooks useState useEffect examples\" Fetching URLs \u00b6 The web_fetch tool retrieves content from a specific URL. Parameters \u00b6 Parameter Type Default Description url string required The URL to fetch offset integer 0 Start reading from byte N limit integer 204800 Max bytes to return (200KB) save_to_file string null Save full content to this path Size Limits \u00b6 By default, web_fetch returns up to 200KB of content. This prevents overwhelming responses and keeps context manageable. The response includes metadata to help you understand what was retrieved: { \"truncated\" : true , \"total_bytes\" : 450000 , \"content\" : \"...\" } Using save_to_file \u00b6 For large pages, save the full content to a file instead of returning it: Fetch https://example.com/large-doc.html and save to ./docs/reference.html This saves the complete content and returns only metadata plus a preview, keeping your context clean while preserving full access to the data. Pagination with offset/limit \u00b6 For very large content, paginate through it: # First 200KB (default) web_fetch(url=\"https://example.com/huge-page\") # Next 200KB web_fetch(url=\"https://example.com/huge-page\", offset=204800) # Custom chunk size web_fetch(url=\"https://example.com/huge-page\", offset=0, limit=50000) Handling Large Pages \u00b6 Large web pages require special handling to avoid context overflow. Strategy 1: Save and Read Selectively \u00b6 1. Fetch URL with save_to_file parameter 2. Read specific sections using read_file with offset/limit 3. Search within saved file using grep This is ideal for documentation pages or API references where you only need specific sections. Strategy 2: Paginate Through Content \u00b6 1. Fetch first chunk (default 200KB) 2. Check if truncated is true 3. Continue fetching with increasing offsets 4. Stop when you find what you need Useful when searching for specific information in a large page. Strategy 3: Multiple Targeted Fetches \u00b6 If a page has anchor links or sections: Fetch https://docs.example.com/api#authentication Fetch https://docs.example.com/api#endpoints Many documentation sites support fragment navigation. Warning: Truncation Breaks Structured Data \u00b6 When content is truncated, JSON, XML, or other structured formats may break: { \"users\" : [ { \"name\" : \"Alice\" , \"role\" : \"admin\" }, { \"name\" : \"Bob\" , \"role\" : \"user\" }, { \"name\" : \"Charlie\" , \"ro [...truncated...] Workaround : Use save_to_file for any structured data you need to parse. Handling Redirects \u00b6 When web_fetch encounters a redirect to a different host, it returns a message indicating the redirect URL. The assistant should then make a new request with the provided redirect URL. Original: https://short.link/abc123 Redirect: https://actual-destination.com/full-path The assistant handles this automatically in most cases. Best Practices \u00b6 Combine Search and Fetch \u00b6 1. Search: \"Pydantic v2 migration guide\" 2. Review search results 3. Fetch the most relevant URL for details Verify Information Currency \u00b6 Web search results include dates when available. For rapidly evolving technologies, prefer recent sources: Search: \"Python 3.12 new features 2024\" Use Official Sources First \u00b6 When documentation exists, prefer official sources: Good: Fetch from docs.python.org Less ideal: Fetch from random blog posts Cache Large Documentation Locally \u00b6 For repeated reference to large docs: 1. Fetch with save_to_file to ./docs/reference.md 2. Read from local file for subsequent queries 3. Refresh periodically as needed Respect Rate Limits \u00b6 Avoid rapid sequential fetches to the same domain. The assistant handles this automatically, but be aware that some sites may block aggressive access. Try It Yourself \u00b6 Exercise 1: Documentation Lookup \u00b6 Find the official documentation for Python's pathlib module and explain the difference between Path.resolve() and Path.absolute() Exercise 2: Error Research \u00b6 Search for: \"TypeError: 'NoneType' object is not subscriptable\" and summarize the common causes Exercise 3: API Documentation \u00b6 Fetch the GitHub REST API documentation for creating issues and show me the required parameters Exercise 4: Large Page Handling \u00b6 Fetch a large documentation page and save it locally, then search for specific sections within the saved file Exercise 5: Comparative Research \u00b6 Search for comparisons between FastAPI and Flask, fetch two relevant articles, and summarize the key differences Common Errors \u00b6 Connection Errors \u00b6 Error Cause Solution Connection timeout Server slow or unreachable Retry or try alternative URL Connection refused Server not accepting connections Check URL validity DNS resolution failed Domain doesn't exist Verify the domain name HTTP Errors \u00b6 Status Meaning Action 403 Forbidden Access denied Site may block automated access 404 Not Found Page doesn't exist Verify URL or search for current location 429 Too Many Requests Rate limited Wait and retry later 500 Server Error Server problem Retry or find alternative source Content Issues \u00b6 Issue Cause Solution Empty response JavaScript-rendered content Content may require browser rendering Garbled text Encoding issues Usually handled automatically Incomplete data Truncation Use save_to_file for full content Blocked Access \u00b6 Some sites block automated fetching: Paywalled content : Requires authentication Bot protection : Sites using Cloudflare or similar Terms of service : Some sites prohibit scraping In these cases, try alternative sources or inform the user that direct access is unavailable. Summary \u00b6 Web tools provide powerful internet access capabilities: web_search : Discover information and find relevant URLs web_fetch : Retrieve content with size management options Key techniques: - Use save_to_file for large pages - Paginate with offset / limit for huge content - Combine search and fetch for effective research - Prefer official documentation sources These tools transform your assistant into a research partner capable of finding, retrieving, and synthesizing information from across the web.","title":"Web Tools"},{"location":"tools/web.html#web-tools","text":"Web tools extend your AI assistant's capabilities beyond local files and code, enabling real-time information retrieval from the internet. These tools are essential for research, documentation lookup, API exploration, and staying current with rapidly evolving technologies.","title":"Web Tools"},{"location":"tools/web.html#operations","text":"Tool Purpose web_search Search the internet for information web_fetch Fetch and parse content from a URL Both tools work together: use web_search to discover relevant URLs, then web_fetch to retrieve detailed content from specific pages.","title":"Operations"},{"location":"tools/web.html#web-search","text":"The web_search tool queries the internet and returns relevant results.","title":"Web Search"},{"location":"tools/web.html#basic-usage","text":"User: Search for Python asyncio best practices The assistant will use web_search to find current articles, documentation, and discussions about the topic.","title":"Basic Usage"},{"location":"tools/web.html#when-to-use-web-search","text":"Documentation lookup : Find official docs for libraries and frameworks Error resolution : Search for error messages and solutions Best practices : Discover current recommendations and patterns News and updates : Get latest information about technologies Comparative research : Find comparisons between tools or approaches","title":"When to Use Web Search"},{"location":"tools/web.html#search-tips","text":"Be specific : \"FastAPI dependency injection tutorial\" beats \"FastAPI help\" Include context : Add version numbers or specific use cases Use quotes : For exact phrases or error messages Combine terms : \"React hooks useState useEffect examples\"","title":"Search Tips"},{"location":"tools/web.html#fetching-urls","text":"The web_fetch tool retrieves content from a specific URL.","title":"Fetching URLs"},{"location":"tools/web.html#parameters","text":"Parameter Type Default Description url string required The URL to fetch offset integer 0 Start reading from byte N limit integer 204800 Max bytes to return (200KB) save_to_file string null Save full content to this path","title":"Parameters"},{"location":"tools/web.html#size-limits","text":"By default, web_fetch returns up to 200KB of content. This prevents overwhelming responses and keeps context manageable. The response includes metadata to help you understand what was retrieved: { \"truncated\" : true , \"total_bytes\" : 450000 , \"content\" : \"...\" }","title":"Size Limits"},{"location":"tools/web.html#using-save_to_file","text":"For large pages, save the full content to a file instead of returning it: Fetch https://example.com/large-doc.html and save to ./docs/reference.html This saves the complete content and returns only metadata plus a preview, keeping your context clean while preserving full access to the data.","title":"Using save_to_file"},{"location":"tools/web.html#pagination-with-offsetlimit","text":"For very large content, paginate through it: # First 200KB (default) web_fetch(url=\"https://example.com/huge-page\") # Next 200KB web_fetch(url=\"https://example.com/huge-page\", offset=204800) # Custom chunk size web_fetch(url=\"https://example.com/huge-page\", offset=0, limit=50000)","title":"Pagination with offset/limit"},{"location":"tools/web.html#handling-large-pages","text":"Large web pages require special handling to avoid context overflow.","title":"Handling Large Pages"},{"location":"tools/web.html#strategy-1-save-and-read-selectively","text":"1. Fetch URL with save_to_file parameter 2. Read specific sections using read_file with offset/limit 3. Search within saved file using grep This is ideal for documentation pages or API references where you only need specific sections.","title":"Strategy 1: Save and Read Selectively"},{"location":"tools/web.html#strategy-2-paginate-through-content","text":"1. Fetch first chunk (default 200KB) 2. Check if truncated is true 3. Continue fetching with increasing offsets 4. Stop when you find what you need Useful when searching for specific information in a large page.","title":"Strategy 2: Paginate Through Content"},{"location":"tools/web.html#strategy-3-multiple-targeted-fetches","text":"If a page has anchor links or sections: Fetch https://docs.example.com/api#authentication Fetch https://docs.example.com/api#endpoints Many documentation sites support fragment navigation.","title":"Strategy 3: Multiple Targeted Fetches"},{"location":"tools/web.html#warning-truncation-breaks-structured-data","text":"When content is truncated, JSON, XML, or other structured formats may break: { \"users\" : [ { \"name\" : \"Alice\" , \"role\" : \"admin\" }, { \"name\" : \"Bob\" , \"role\" : \"user\" }, { \"name\" : \"Charlie\" , \"ro [...truncated...] Workaround : Use save_to_file for any structured data you need to parse.","title":"Warning: Truncation Breaks Structured Data"},{"location":"tools/web.html#handling-redirects","text":"When web_fetch encounters a redirect to a different host, it returns a message indicating the redirect URL. The assistant should then make a new request with the provided redirect URL. Original: https://short.link/abc123 Redirect: https://actual-destination.com/full-path The assistant handles this automatically in most cases.","title":"Handling Redirects"},{"location":"tools/web.html#best-practices","text":"","title":"Best Practices"},{"location":"tools/web.html#combine-search-and-fetch","text":"1. Search: \"Pydantic v2 migration guide\" 2. Review search results 3. Fetch the most relevant URL for details","title":"Combine Search and Fetch"},{"location":"tools/web.html#verify-information-currency","text":"Web search results include dates when available. For rapidly evolving technologies, prefer recent sources: Search: \"Python 3.12 new features 2024\"","title":"Verify Information Currency"},{"location":"tools/web.html#use-official-sources-first","text":"When documentation exists, prefer official sources: Good: Fetch from docs.python.org Less ideal: Fetch from random blog posts","title":"Use Official Sources First"},{"location":"tools/web.html#cache-large-documentation-locally","text":"For repeated reference to large docs: 1. Fetch with save_to_file to ./docs/reference.md 2. Read from local file for subsequent queries 3. Refresh periodically as needed","title":"Cache Large Documentation Locally"},{"location":"tools/web.html#respect-rate-limits","text":"Avoid rapid sequential fetches to the same domain. The assistant handles this automatically, but be aware that some sites may block aggressive access.","title":"Respect Rate Limits"},{"location":"tools/web.html#try-it-yourself","text":"","title":"Try It Yourself"},{"location":"tools/web.html#exercise-1-documentation-lookup","text":"Find the official documentation for Python's pathlib module and explain the difference between Path.resolve() and Path.absolute()","title":"Exercise 1: Documentation Lookup"},{"location":"tools/web.html#exercise-2-error-research","text":"Search for: \"TypeError: 'NoneType' object is not subscriptable\" and summarize the common causes","title":"Exercise 2: Error Research"},{"location":"tools/web.html#exercise-3-api-documentation","text":"Fetch the GitHub REST API documentation for creating issues and show me the required parameters","title":"Exercise 3: API Documentation"},{"location":"tools/web.html#exercise-4-large-page-handling","text":"Fetch a large documentation page and save it locally, then search for specific sections within the saved file","title":"Exercise 4: Large Page Handling"},{"location":"tools/web.html#exercise-5-comparative-research","text":"Search for comparisons between FastAPI and Flask, fetch two relevant articles, and summarize the key differences","title":"Exercise 5: Comparative Research"},{"location":"tools/web.html#common-errors","text":"","title":"Common Errors"},{"location":"tools/web.html#connection-errors","text":"Error Cause Solution Connection timeout Server slow or unreachable Retry or try alternative URL Connection refused Server not accepting connections Check URL validity DNS resolution failed Domain doesn't exist Verify the domain name","title":"Connection Errors"},{"location":"tools/web.html#http-errors","text":"Status Meaning Action 403 Forbidden Access denied Site may block automated access 404 Not Found Page doesn't exist Verify URL or search for current location 429 Too Many Requests Rate limited Wait and retry later 500 Server Error Server problem Retry or find alternative source","title":"HTTP Errors"},{"location":"tools/web.html#content-issues","text":"Issue Cause Solution Empty response JavaScript-rendered content Content may require browser rendering Garbled text Encoding issues Usually handled automatically Incomplete data Truncation Use save_to_file for full content","title":"Content Issues"},{"location":"tools/web.html#blocked-access","text":"Some sites block automated fetching: Paywalled content : Requires authentication Bot protection : Sites using Cloudflare or similar Terms of service : Some sites prohibit scraping In these cases, try alternative sources or inform the user that direct access is unavailable.","title":"Blocked Access"},{"location":"tools/web.html#summary","text":"Web tools provide powerful internet access capabilities: web_search : Discover information and find relevant URLs web_fetch : Retrieve content with size management options Key techniques: - Use save_to_file for large pages - Paginate with offset / limit for huge content - Combine search and fetch for effective research - Prefer official documentation sources These tools transform your assistant into a research partner capable of finding, retrieving, and synthesizing information from across the web.","title":"Summary"}]}