{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"Welcome to the Amplifier Tutorial \u00b6 Learn Amplifier , the modular AI agent framework from Microsoft. What You'll Learn \u00b6 This tutorial takes you from zero to productive with Amplifier: Getting Started - Install, configure, and run your first conversation Core Concepts - Understand bundles, modules, agents, and recipes Tools Reference - Deep dives into every available tool Developer Setup - Professional workflows for serious development Advanced Topics - Build your own bundles, tools, and agents Who This Is For \u00b6 Developers who want an AI coding assistant they can customize Teams who need multi-provider flexibility (not locked to one vendor) Power users frustrated with black-box AI tools Anyone curious about how modern AI agents actually work Quick Start (90 Seconds) \u00b6 # Install UV (Python package manager) curl -LsSf https://astral.sh/uv/install.sh | sh # Install Amplifier uv tool install git+https://github.com/microsoft/amplifier # Configure your AI provider amplifier init # Start chatting amplifier That's it. You're now running a modular AI agent framework. Why Amplifier? \u00b6 Traditional AI Tools Amplifier One AI provider Switch between 7+ providers Limited customization Full module system Black box Transparent event logging Ad-hoc prompts Declarative workflows (recipes) Single agent Multi-agent orchestration Next Steps \u00b6 New to Amplifier? Start with What is Amplifier? Ready to install? Jump to Installation Want to explore? Browse the Tools Reference This tutorial is generated using Amplifier itself. The source is modular markdown that can be updated incrementally.","title":"Home"},{"location":"index.html#welcome-to-the-amplifier-tutorial","text":"Learn Amplifier , the modular AI agent framework from Microsoft.","title":"Welcome to the Amplifier Tutorial"},{"location":"index.html#what-youll-learn","text":"This tutorial takes you from zero to productive with Amplifier: Getting Started - Install, configure, and run your first conversation Core Concepts - Understand bundles, modules, agents, and recipes Tools Reference - Deep dives into every available tool Developer Setup - Professional workflows for serious development Advanced Topics - Build your own bundles, tools, and agents","title":"What You'll Learn"},{"location":"index.html#who-this-is-for","text":"Developers who want an AI coding assistant they can customize Teams who need multi-provider flexibility (not locked to one vendor) Power users frustrated with black-box AI tools Anyone curious about how modern AI agents actually work","title":"Who This Is For"},{"location":"index.html#quick-start-90-seconds","text":"# Install UV (Python package manager) curl -LsSf https://astral.sh/uv/install.sh | sh # Install Amplifier uv tool install git+https://github.com/microsoft/amplifier # Configure your AI provider amplifier init # Start chatting amplifier That's it. You're now running a modular AI agent framework.","title":"Quick Start (90 Seconds)"},{"location":"index.html#why-amplifier","text":"Traditional AI Tools Amplifier One AI provider Switch between 7+ providers Limited customization Full module system Black box Transparent event logging Ad-hoc prompts Declarative workflows (recipes) Single agent Multi-agent orchestration","title":"Why Amplifier?"},{"location":"index.html#next-steps","text":"New to Amplifier? Start with What is Amplifier? Ready to install? Jump to Installation Want to explore? Browse the Tools Reference This tutorial is generated using Amplifier itself. The source is modular markdown that can be updated incrementally.","title":"Next Steps"},{"location":"advanced/index.html","text":"Advanced Topics \u00b6 Once you've mastered the fundamentals, these advanced topics unlock Amplifier's full power. From multi-agent orchestration to custom kernel modules, this section covers expert-level capabilities. Dive deep into sophisticated patterns for building production-grade AI applications. Section Contents \u00b6 Page Description Custom Bundle Creating custom behavior packages Custom Recipe Building declarative workflows Custom Tool Extending Amplifier capabilities MCP Integration Model Context Protocol integration Quick Tips \u00b6 Recipes for repeatability - Codify multi-step workflows as recipes Agent specialization - Create focused agents rather than general-purpose Module contracts - Follow kernel protocols for reliable extensions Session hygiene - Clean up and repair sessions proactively Monitor everything - Observability is essential at scale Advanced Patterns \u00b6 Recipe-Driven Workflows \u00b6 name : code-review steps : - agent : zen-architect mode : REVIEW input : \"{{file_path}}\" - agent : security-guardian input : \"{{previous_output}}\" - agent : result-validator criteria : \"{{acceptance_criteria}}\" Multi-Agent Collaboration \u00b6 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 Orchestrator\u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u250c\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2510 \u2502 Spawn \u2502 \u25bc \u25bc \u250c\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2510 \u2502 A \u2502 \u2502 B \u2502 Parallel execution \u2514\u2500\u252c\u2500\u2518 \u2514\u2500\u252c\u2500\u2518 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2518 \u2502 \u250c\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2510 \u2502 Combine \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 Where to Start \u00b6 Automating workflows? Begin with Custom Recipe for declarative orchestration. Extending Amplifier? See Custom Bundle for creating custom behavior packages. Building tools? Start with Custom Tool to extend Amplifier's capabilities. Complexity Budget \u00b6 Advanced features add power but also complexity. Apply judiciously: Feature Use When Recipes Repeatable multi-step workflows Multi-agent Tasks benefit from specialization Custom modules Core behavior needs modification Session management Long-running or resumable work Next Steps \u00b6 For day-to-day development workflows, see Dev Setup . For foundational concepts, revisit Concepts .","title":"Overview"},{"location":"advanced/index.html#advanced-topics","text":"Once you've mastered the fundamentals, these advanced topics unlock Amplifier's full power. From multi-agent orchestration to custom kernel modules, this section covers expert-level capabilities. Dive deep into sophisticated patterns for building production-grade AI applications.","title":"Advanced Topics"},{"location":"advanced/index.html#section-contents","text":"Page Description Custom Bundle Creating custom behavior packages Custom Recipe Building declarative workflows Custom Tool Extending Amplifier capabilities MCP Integration Model Context Protocol integration","title":"Section Contents"},{"location":"advanced/index.html#quick-tips","text":"Recipes for repeatability - Codify multi-step workflows as recipes Agent specialization - Create focused agents rather than general-purpose Module contracts - Follow kernel protocols for reliable extensions Session hygiene - Clean up and repair sessions proactively Monitor everything - Observability is essential at scale","title":"Quick Tips"},{"location":"advanced/index.html#advanced-patterns","text":"","title":"Advanced Patterns"},{"location":"advanced/index.html#recipe-driven-workflows","text":"name : code-review steps : - agent : zen-architect mode : REVIEW input : \"{{file_path}}\" - agent : security-guardian input : \"{{previous_output}}\" - agent : result-validator criteria : \"{{acceptance_criteria}}\"","title":"Recipe-Driven Workflows"},{"location":"advanced/index.html#multi-agent-collaboration","text":"\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 Orchestrator\u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u250c\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2510 \u2502 Spawn \u2502 \u25bc \u25bc \u250c\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2510 \u2502 A \u2502 \u2502 B \u2502 Parallel execution \u2514\u2500\u252c\u2500\u2518 \u2514\u2500\u252c\u2500\u2518 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2518 \u2502 \u250c\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2510 \u2502 Combine \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Multi-Agent Collaboration"},{"location":"advanced/index.html#where-to-start","text":"Automating workflows? Begin with Custom Recipe for declarative orchestration. Extending Amplifier? See Custom Bundle for creating custom behavior packages. Building tools? Start with Custom Tool to extend Amplifier's capabilities.","title":"Where to Start"},{"location":"advanced/index.html#complexity-budget","text":"Advanced features add power but also complexity. Apply judiciously: Feature Use When Recipes Repeatable multi-step workflows Multi-agent Tasks benefit from specialization Custom modules Core behavior needs modification Session management Long-running or resumable work","title":"Complexity Budget"},{"location":"advanced/index.html#next-steps","text":"For day-to-day development workflows, see Dev Setup . For foundational concepts, revisit Concepts .","title":"Next Steps"},{"location":"advanced/custom-bundle.html","text":"Creating Custom Bundles \u00b6 Build your own bundle to customize Amplifier for your workflow. Overview \u00b6 A custom bundle lets you: Combine existing bundles - Mix and match capabilities Add custom agents - Specialists for your domain Include context - Project-specific knowledge Set defaults - Provider, model, instructions Bundle Structure \u00b6 my-bundle/ \u251c\u2500\u2500 bundle.yaml # Main configuration \u251c\u2500\u2500 agents/ # Custom agents \u2502 \u2514\u2500\u2500 my-agent.yaml \u251c\u2500\u2500 behaviors/ # Reusable capabilities \u2502 \u2514\u2500\u2500 my-behavior.yaml \u251c\u2500\u2500 context/ # Knowledge files \u2502 \u2514\u2500\u2500 project-info.md \u2514\u2500\u2500 modules/ # Custom tools (optional) \u2514\u2500\u2500 my-tool/ Basic Bundle \u00b6 Minimal Example \u00b6 # my-bundle/bundle.yaml bundle : name : my-custom version : 1.0.0 description : My custom Amplifier configuration includes : - bundle : foundation instructions : | You are a helpful assistant for my project. Always be concise and direct. Use It \u00b6 amp --bundle ./my-bundle Including Other Bundles \u00b6 Stack Multiple Bundles \u00b6 includes : - bundle : foundation # Core tools and agents - bundle : recipes # Workflow orchestration - bundle : lsp-python # Python code intelligence From GitHub \u00b6 includes : - bundle : git+https://github.com/microsoft/amplifier-bundle-recipes@main - bundle : git+https://github.com/robotdad/amplifier-bundle-lsp-typescript@main From Local Path \u00b6 includes : - bundle : ../shared-bundle - bundle : ~/my-bundles/common Custom Agents \u00b6 Define an Agent \u00b6 # agents/api-expert.yaml meta : name : api-expert description : \"REST API design and review specialist\" # Which tools this agent can use tools : - read_file - grep - web_search # Agent's specialized knowledge instructions : | You are a REST API expert. When reviewing APIs: - Check resource naming conventions - Verify HTTP method usage - Ensure consistent error responses - Look for proper versioning Reference OpenAPI spec and REST best practices. # Optional: load additional context context : include : - ../context/api-guidelines.md Register in Bundle \u00b6 # bundle.yaml agents : - path : ./agents/api-expert.yaml - path : ./agents/db-expert.yaml Use Your Agent \u00b6 > Use api-expert to review our user endpoints Custom Context \u00b6 Add Knowledge Files \u00b6 # bundle.yaml context : include : - ./context/project-overview.md - ./context/coding-standards.md - ./context/architecture.md Context File Example \u00b6 # context/project-overview.md ## Project: Acme API This is a REST API for the Acme product catalog. ### Key Components - **Products Service** - CRUD for products - **Orders Service** - Order processing - **Auth Service** - JWT authentication ### Coding Standards - Python 3.12+ - Type hints required - Docstrings in Google style - Tests required for new code Custom Instructions \u00b6 Bundle-Level Instructions \u00b6 # bundle.yaml instructions : | You are an assistant for the Acme project. Key guidelines: - Follow our coding standards in context/coding-standards.md - Always suggest type hints - Recommend tests for new code - Use our error handling patterns Layer with Includes \u00b6 Your instructions add to included bundles: Foundation instructions (base) \u2193 Your bundle instructions (added) \u2193 Final combined instructions Behaviors \u00b6 Behaviors are reusable agent + context combinations: Define a Behavior \u00b6 # behaviors/code-review.yaml meta : name : code-review description : \"Thorough code review process\" # What this behavior adds context : include : - ./review-checklist.md # Specialized agent config agent : instructions : | When reviewing code: 1. Check for bugs and logic errors 2. Review naming and readability 3. Assess test coverage 4. Look for security issues Use in Bundle \u00b6 behaviors : - path : ./behaviors/code-review.yaml - path : ./behaviors/security-audit.yaml Provider Configuration \u00b6 Set Default Provider \u00b6 # bundle.yaml providers : - module : provider-anthropic config : model : claude-sonnet-4-20250514 max_tokens : 8192 Multiple Providers \u00b6 providers : - module : provider-anthropic config : model : claude-sonnet-4-20250514 default : true # Use this by default - module : provider-ollama config : model : llama3.1 Tools Configuration \u00b6 Add Tools \u00b6 tools : - module : tool-filesystem - module : tool-bash config : allowed_commands : [ \"ls\" , \"cat\" , \"grep\" , \"git\" ] Custom Tool Module \u00b6 tools : - module : jira-tool source : ./modules/jira-tool config : api_url : https://acme.atlassian.net Complete Example \u00b6 # bundle.yaml bundle : name : acme-dev version : 1.0.0 description : Acme project development bundle # Build on existing bundles includes : - bundle : foundation - bundle : recipes - bundle : lsp-python # Default provider providers : - module : provider-anthropic config : model : claude-sonnet-4-20250514 # Custom agents agents : - path : ./agents/api-expert.yaml - path : ./agents/db-expert.yaml # Behaviors behaviors : - path : ./behaviors/code-review.yaml # Project knowledge context : include : - ./context/project-overview.md - ./context/coding-standards.md # Custom instructions instructions : | You are an Acme project assistant. Guidelines: - Follow our coding standards - Always suggest type hints - Write tests for new code - Use project patterns from context Try It Yourself \u00b6 Exercise 1: Create Minimal Bundle \u00b6 mkdir my-bundle cat > my-bundle/bundle.yaml << 'EOF' bundle: name: my-test version: 1.0.0 includes: - bundle: foundation instructions: | Be concise. Use bullet points. EOF amp --bundle ./my-bundle Exercise 2: Add an Agent \u00b6 Create my-bundle/agents/reviewer.yaml : meta : name : reviewer description : \"Code reviewer\" instructions : | Review code for bugs and improvements. Be specific and actionable. Update bundle.yaml: agents : - path : ./agents/reviewer.yaml Test: > Use reviewer to check src/main.py Exercise 3: Add Context \u00b6 Create my-bundle/context/standards.md with your coding standards. Update bundle.yaml: context : include : - ./context/standards.md Sharing Bundles \u00b6 Via Git \u00b6 # Push to GitHub cd my-bundle git init git add . git commit -m \"Initial bundle\" gh repo create my-bundle --public git push -u origin main Others can use: amp bundle add git+https://github.com/yourusername/my-bundle@main Via Zip \u00b6 zip -r my-bundle.zip my-bundle/ # Share the zip file","title":"Custom Bundles"},{"location":"advanced/custom-bundle.html#creating-custom-bundles","text":"Build your own bundle to customize Amplifier for your workflow.","title":"Creating Custom Bundles"},{"location":"advanced/custom-bundle.html#overview","text":"A custom bundle lets you: Combine existing bundles - Mix and match capabilities Add custom agents - Specialists for your domain Include context - Project-specific knowledge Set defaults - Provider, model, instructions","title":"Overview"},{"location":"advanced/custom-bundle.html#bundle-structure","text":"my-bundle/ \u251c\u2500\u2500 bundle.yaml # Main configuration \u251c\u2500\u2500 agents/ # Custom agents \u2502 \u2514\u2500\u2500 my-agent.yaml \u251c\u2500\u2500 behaviors/ # Reusable capabilities \u2502 \u2514\u2500\u2500 my-behavior.yaml \u251c\u2500\u2500 context/ # Knowledge files \u2502 \u2514\u2500\u2500 project-info.md \u2514\u2500\u2500 modules/ # Custom tools (optional) \u2514\u2500\u2500 my-tool/","title":"Bundle Structure"},{"location":"advanced/custom-bundle.html#basic-bundle","text":"","title":"Basic Bundle"},{"location":"advanced/custom-bundle.html#minimal-example","text":"# my-bundle/bundle.yaml bundle : name : my-custom version : 1.0.0 description : My custom Amplifier configuration includes : - bundle : foundation instructions : | You are a helpful assistant for my project. Always be concise and direct.","title":"Minimal Example"},{"location":"advanced/custom-bundle.html#use-it","text":"amp --bundle ./my-bundle","title":"Use It"},{"location":"advanced/custom-bundle.html#including-other-bundles","text":"","title":"Including Other Bundles"},{"location":"advanced/custom-bundle.html#stack-multiple-bundles","text":"includes : - bundle : foundation # Core tools and agents - bundle : recipes # Workflow orchestration - bundle : lsp-python # Python code intelligence","title":"Stack Multiple Bundles"},{"location":"advanced/custom-bundle.html#from-github","text":"includes : - bundle : git+https://github.com/microsoft/amplifier-bundle-recipes@main - bundle : git+https://github.com/robotdad/amplifier-bundle-lsp-typescript@main","title":"From GitHub"},{"location":"advanced/custom-bundle.html#from-local-path","text":"includes : - bundle : ../shared-bundle - bundle : ~/my-bundles/common","title":"From Local Path"},{"location":"advanced/custom-bundle.html#custom-agents","text":"","title":"Custom Agents"},{"location":"advanced/custom-bundle.html#define-an-agent","text":"# agents/api-expert.yaml meta : name : api-expert description : \"REST API design and review specialist\" # Which tools this agent can use tools : - read_file - grep - web_search # Agent's specialized knowledge instructions : | You are a REST API expert. When reviewing APIs: - Check resource naming conventions - Verify HTTP method usage - Ensure consistent error responses - Look for proper versioning Reference OpenAPI spec and REST best practices. # Optional: load additional context context : include : - ../context/api-guidelines.md","title":"Define an Agent"},{"location":"advanced/custom-bundle.html#register-in-bundle","text":"# bundle.yaml agents : - path : ./agents/api-expert.yaml - path : ./agents/db-expert.yaml","title":"Register in Bundle"},{"location":"advanced/custom-bundle.html#use-your-agent","text":"> Use api-expert to review our user endpoints","title":"Use Your Agent"},{"location":"advanced/custom-bundle.html#custom-context","text":"","title":"Custom Context"},{"location":"advanced/custom-bundle.html#add-knowledge-files","text":"# bundle.yaml context : include : - ./context/project-overview.md - ./context/coding-standards.md - ./context/architecture.md","title":"Add Knowledge Files"},{"location":"advanced/custom-bundle.html#context-file-example","text":"# context/project-overview.md ## Project: Acme API This is a REST API for the Acme product catalog. ### Key Components - **Products Service** - CRUD for products - **Orders Service** - Order processing - **Auth Service** - JWT authentication ### Coding Standards - Python 3.12+ - Type hints required - Docstrings in Google style - Tests required for new code","title":"Context File Example"},{"location":"advanced/custom-bundle.html#custom-instructions","text":"","title":"Custom Instructions"},{"location":"advanced/custom-bundle.html#bundle-level-instructions","text":"# bundle.yaml instructions : | You are an assistant for the Acme project. Key guidelines: - Follow our coding standards in context/coding-standards.md - Always suggest type hints - Recommend tests for new code - Use our error handling patterns","title":"Bundle-Level Instructions"},{"location":"advanced/custom-bundle.html#layer-with-includes","text":"Your instructions add to included bundles: Foundation instructions (base) \u2193 Your bundle instructions (added) \u2193 Final combined instructions","title":"Layer with Includes"},{"location":"advanced/custom-bundle.html#behaviors","text":"Behaviors are reusable agent + context combinations:","title":"Behaviors"},{"location":"advanced/custom-bundle.html#define-a-behavior","text":"# behaviors/code-review.yaml meta : name : code-review description : \"Thorough code review process\" # What this behavior adds context : include : - ./review-checklist.md # Specialized agent config agent : instructions : | When reviewing code: 1. Check for bugs and logic errors 2. Review naming and readability 3. Assess test coverage 4. Look for security issues","title":"Define a Behavior"},{"location":"advanced/custom-bundle.html#use-in-bundle","text":"behaviors : - path : ./behaviors/code-review.yaml - path : ./behaviors/security-audit.yaml","title":"Use in Bundle"},{"location":"advanced/custom-bundle.html#provider-configuration","text":"","title":"Provider Configuration"},{"location":"advanced/custom-bundle.html#set-default-provider","text":"# bundle.yaml providers : - module : provider-anthropic config : model : claude-sonnet-4-20250514 max_tokens : 8192","title":"Set Default Provider"},{"location":"advanced/custom-bundle.html#multiple-providers","text":"providers : - module : provider-anthropic config : model : claude-sonnet-4-20250514 default : true # Use this by default - module : provider-ollama config : model : llama3.1","title":"Multiple Providers"},{"location":"advanced/custom-bundle.html#tools-configuration","text":"","title":"Tools Configuration"},{"location":"advanced/custom-bundle.html#add-tools","text":"tools : - module : tool-filesystem - module : tool-bash config : allowed_commands : [ \"ls\" , \"cat\" , \"grep\" , \"git\" ]","title":"Add Tools"},{"location":"advanced/custom-bundle.html#custom-tool-module","text":"tools : - module : jira-tool source : ./modules/jira-tool config : api_url : https://acme.atlassian.net","title":"Custom Tool Module"},{"location":"advanced/custom-bundle.html#complete-example","text":"# bundle.yaml bundle : name : acme-dev version : 1.0.0 description : Acme project development bundle # Build on existing bundles includes : - bundle : foundation - bundle : recipes - bundle : lsp-python # Default provider providers : - module : provider-anthropic config : model : claude-sonnet-4-20250514 # Custom agents agents : - path : ./agents/api-expert.yaml - path : ./agents/db-expert.yaml # Behaviors behaviors : - path : ./behaviors/code-review.yaml # Project knowledge context : include : - ./context/project-overview.md - ./context/coding-standards.md # Custom instructions instructions : | You are an Acme project assistant. Guidelines: - Follow our coding standards - Always suggest type hints - Write tests for new code - Use project patterns from context","title":"Complete Example"},{"location":"advanced/custom-bundle.html#try-it-yourself","text":"","title":"Try It Yourself"},{"location":"advanced/custom-bundle.html#exercise-1-create-minimal-bundle","text":"mkdir my-bundle cat > my-bundle/bundle.yaml << 'EOF' bundle: name: my-test version: 1.0.0 includes: - bundle: foundation instructions: | Be concise. Use bullet points. EOF amp --bundle ./my-bundle","title":"Exercise 1: Create Minimal Bundle"},{"location":"advanced/custom-bundle.html#exercise-2-add-an-agent","text":"Create my-bundle/agents/reviewer.yaml : meta : name : reviewer description : \"Code reviewer\" instructions : | Review code for bugs and improvements. Be specific and actionable. Update bundle.yaml: agents : - path : ./agents/reviewer.yaml Test: > Use reviewer to check src/main.py","title":"Exercise 2: Add an Agent"},{"location":"advanced/custom-bundle.html#exercise-3-add-context","text":"Create my-bundle/context/standards.md with your coding standards. Update bundle.yaml: context : include : - ./context/standards.md","title":"Exercise 3: Add Context"},{"location":"advanced/custom-bundle.html#sharing-bundles","text":"","title":"Sharing Bundles"},{"location":"advanced/custom-bundle.html#via-git","text":"# Push to GitHub cd my-bundle git init git add . git commit -m \"Initial bundle\" gh repo create my-bundle --public git push -u origin main Others can use: amp bundle add git+https://github.com/yourusername/my-bundle@main","title":"Via Git"},{"location":"advanced/custom-bundle.html#via-zip","text":"zip -r my-bundle.zip my-bundle/ # Share the zip file","title":"Via Zip"},{"location":"advanced/custom-recipe.html","text":"Creating Custom Recipes \u00b6 Build multi-step workflows that orchestrate agents. Overview \u00b6 Recipes let you: Orchestrate agents - Chain specialists together Create repeatable workflows - Run the same process consistently Add approval gates - Human-in-the-loop checkpoints Handle complex flows - Loops, conditions, parallel execution Recipe Structure \u00b6 # my-recipe.yaml name : my-workflow description : What this recipe does # Input variables context : input_var : \"\" # Required (no default) optional_var : \"default\" # Optional (has default) # Workflow steps steps : - id : step-one instruction : \"Do the first thing with {{input_var}}\" - id : step-two agent : foundation:zen-architect instruction : | Based on: {{step-one.result}} Do the second thing. Basic Recipe \u00b6 Simple Two-Step Recipe \u00b6 name : explain-and-improve description : Explain code then suggest improvements context : file : \"\" steps : - id : explain instruction : \"Explain what {{file}} does in plain language\" - id : improve instruction : | Based on this understanding: {{explain.result}} Suggest 3 improvements for {{file}} Run It \u00b6 amp recipes execute explain-and-improve.yaml \\ --context '{\"file\": \"src/auth.py\"}' Using Agents \u00b6 Specify Agent for Step \u00b6 steps : - id : design agent : foundation:zen-architect instruction : \"Design a solution for {{problem}}\" - id : implement agent : foundation:modular-builder instruction : | Implement the design: {{design.result}} - id : review agent : foundation:security-guardian instruction : \"Review the implementation for security issues\" Context Variables \u00b6 Input Variables \u00b6 context : # Required - must be provided target_file : \"\" # Optional - has default value depth : \"standard\" include_tests : true Access Variables \u00b6 instruction : | Review {{target_file}} with {{depth}} depth. {{#if include_tests}}Include test analysis.{{/if}} Step Results \u00b6 Each step's output is available to later steps: steps : - id : analyze instruction : \"Analyze the code\" - id : report instruction : | Previous analysis: {{analyze.result}} Create a summary report. Approval Gates \u00b6 Require Human Approval \u00b6 steps : - id : plan instruction : \"Create a migration plan\" - id : confirm requires_approval : true instruction : \"Review the plan before proceeding\" - id : execute instruction : \"Execute the migration: {{plan.result}}\" Approval Commands \u00b6 # Check pending approvals amp recipes approvals # Approve amp recipes approve [ session-id ] [ step-id ] # Deny amp recipes deny [ session-id ] [ step-id ] --reason \"Need changes\" Advanced Features \u00b6 Loops (foreach) \u00b6 steps : - id : get-files instruction : \"List all Python files in src/\" parse_json : true - id : review-each foreach : \"{{get-files.result.files}}\" instruction : \"Review {{item}} for issues\" Parallel Execution \u00b6 steps : - id : parallel-reviews foreach : \"{{files}}\" parallel : 3 # Run 3 at a time instruction : \"Review {{item}}\" Conditional Steps \u00b6 steps : - id : check instruction : \"Does {{file}} have tests?\" parse_json : true - id : write-tests condition : \"{{check.result.has_tests}} == false\" instruction : \"Write tests for {{file}}\" Error Handling \u00b6 steps : - id : risky-step instruction : \"Try something that might fail\" on_error : continue # Don't stop on failure - id : handle-error condition : \"{{risky-step.status}} == 'error'\" instruction : \"Handle the error: {{risky-step.error}}\" Complete Examples \u00b6 Code Review Recipe \u00b6 name : code-review description : Comprehensive code review with multiple specialists context : file_path : \"\" review_depth : \"standard\" steps : - id : design-review agent : foundation:zen-architect instruction : | Review {{file_path}} for design issues: - Architecture patterns - Code organization - Complexity Depth: {{review_depth}} - id : security-review agent : foundation:security-guardian instruction : | Review {{file_path}} for security issues: - Input validation - Authentication/authorization - Data handling - id : test-review agent : foundation:test-coverage instruction : | Analyze test coverage for {{file_path}}: - Existing tests - Missing coverage - Test quality - id : final-report instruction : | Create a code review report combining: ## Design Review {{design-review.result}} ## Security Review {{security-review.result}} ## Test Coverage {{test-review.result}} Include: - Summary of findings - Priority-ordered action items - Overall assessment Deployment Recipe with Approval \u00b6 name : deploy description : Deploy to staging with approval gate context : environment : \"staging\" version : \"\" steps : - id : build instruction : \"Build version {{version}}\" - id : test instruction : \"Run full test suite\" - id : pre-deploy-check instruction : | Verify deployment readiness: - Build: {{build.result}} - Tests: {{test.result}} List any blockers. - id : approve-deploy requires_approval : true instruction : | Ready to deploy {{version}} to {{environment}}. Pre-check results: {{pre-deploy-check.result}} - id : deploy instruction : \"Deploy {{version}} to {{environment}}\" - id : verify instruction : \"Verify deployment health\" Recipe Validation \u00b6 Check your recipe before running: amp recipes validate my-recipe.yaml Common validation errors: Error Solution Invalid YAML syntax Check indentation, quotes Unknown agent Verify agent name Missing context var Add to context section Circular reference Check step dependencies Recipe Author Agent \u00b6 Get help creating recipes: > Help me create a recipe for database migration The recipe-author agent will: - Ask clarifying questions - Suggest best structure - Generate valid YAML - Add error handling Try It Yourself \u00b6 Exercise 1: Simple Recipe \u00b6 # hello-recipe.yaml name : hello description : Simple greeting recipe context : name : \"\" steps : - id : greet instruction : \"Say hello to {{name}}\" amp recipes execute hello-recipe.yaml --context '{\"name\": \"World\"}' Exercise 2: Multi-Step Recipe \u00b6 Create a recipe that: 1. Reads a file 2. Explains it 3. Suggests improvements Exercise 3: Add Approval Gate \u00b6 Add an approval step before making changes. Best Practices \u00b6 Clear step IDs - Use descriptive names like analyze-deps not step1 One responsibility per step - Keep steps focused Use appropriate agents - Match agent specialty to task Add approval gates - For destructive or important operations Handle errors - Use on_error for steps that might fail Document context - Make required inputs clear","title":"Custom Recipes"},{"location":"advanced/custom-recipe.html#creating-custom-recipes","text":"Build multi-step workflows that orchestrate agents.","title":"Creating Custom Recipes"},{"location":"advanced/custom-recipe.html#overview","text":"Recipes let you: Orchestrate agents - Chain specialists together Create repeatable workflows - Run the same process consistently Add approval gates - Human-in-the-loop checkpoints Handle complex flows - Loops, conditions, parallel execution","title":"Overview"},{"location":"advanced/custom-recipe.html#recipe-structure","text":"# my-recipe.yaml name : my-workflow description : What this recipe does # Input variables context : input_var : \"\" # Required (no default) optional_var : \"default\" # Optional (has default) # Workflow steps steps : - id : step-one instruction : \"Do the first thing with {{input_var}}\" - id : step-two agent : foundation:zen-architect instruction : | Based on: {{step-one.result}} Do the second thing.","title":"Recipe Structure"},{"location":"advanced/custom-recipe.html#basic-recipe","text":"","title":"Basic Recipe"},{"location":"advanced/custom-recipe.html#simple-two-step-recipe","text":"name : explain-and-improve description : Explain code then suggest improvements context : file : \"\" steps : - id : explain instruction : \"Explain what {{file}} does in plain language\" - id : improve instruction : | Based on this understanding: {{explain.result}} Suggest 3 improvements for {{file}}","title":"Simple Two-Step Recipe"},{"location":"advanced/custom-recipe.html#run-it","text":"amp recipes execute explain-and-improve.yaml \\ --context '{\"file\": \"src/auth.py\"}'","title":"Run It"},{"location":"advanced/custom-recipe.html#using-agents","text":"","title":"Using Agents"},{"location":"advanced/custom-recipe.html#specify-agent-for-step","text":"steps : - id : design agent : foundation:zen-architect instruction : \"Design a solution for {{problem}}\" - id : implement agent : foundation:modular-builder instruction : | Implement the design: {{design.result}} - id : review agent : foundation:security-guardian instruction : \"Review the implementation for security issues\"","title":"Specify Agent for Step"},{"location":"advanced/custom-recipe.html#context-variables","text":"","title":"Context Variables"},{"location":"advanced/custom-recipe.html#input-variables","text":"context : # Required - must be provided target_file : \"\" # Optional - has default value depth : \"standard\" include_tests : true","title":"Input Variables"},{"location":"advanced/custom-recipe.html#access-variables","text":"instruction : | Review {{target_file}} with {{depth}} depth. {{#if include_tests}}Include test analysis.{{/if}}","title":"Access Variables"},{"location":"advanced/custom-recipe.html#step-results","text":"Each step's output is available to later steps: steps : - id : analyze instruction : \"Analyze the code\" - id : report instruction : | Previous analysis: {{analyze.result}} Create a summary report.","title":"Step Results"},{"location":"advanced/custom-recipe.html#approval-gates","text":"","title":"Approval Gates"},{"location":"advanced/custom-recipe.html#require-human-approval","text":"steps : - id : plan instruction : \"Create a migration plan\" - id : confirm requires_approval : true instruction : \"Review the plan before proceeding\" - id : execute instruction : \"Execute the migration: {{plan.result}}\"","title":"Require Human Approval"},{"location":"advanced/custom-recipe.html#approval-commands","text":"# Check pending approvals amp recipes approvals # Approve amp recipes approve [ session-id ] [ step-id ] # Deny amp recipes deny [ session-id ] [ step-id ] --reason \"Need changes\"","title":"Approval Commands"},{"location":"advanced/custom-recipe.html#advanced-features","text":"","title":"Advanced Features"},{"location":"advanced/custom-recipe.html#loops-foreach","text":"steps : - id : get-files instruction : \"List all Python files in src/\" parse_json : true - id : review-each foreach : \"{{get-files.result.files}}\" instruction : \"Review {{item}} for issues\"","title":"Loops (foreach)"},{"location":"advanced/custom-recipe.html#parallel-execution","text":"steps : - id : parallel-reviews foreach : \"{{files}}\" parallel : 3 # Run 3 at a time instruction : \"Review {{item}}\"","title":"Parallel Execution"},{"location":"advanced/custom-recipe.html#conditional-steps","text":"steps : - id : check instruction : \"Does {{file}} have tests?\" parse_json : true - id : write-tests condition : \"{{check.result.has_tests}} == false\" instruction : \"Write tests for {{file}}\"","title":"Conditional Steps"},{"location":"advanced/custom-recipe.html#error-handling","text":"steps : - id : risky-step instruction : \"Try something that might fail\" on_error : continue # Don't stop on failure - id : handle-error condition : \"{{risky-step.status}} == 'error'\" instruction : \"Handle the error: {{risky-step.error}}\"","title":"Error Handling"},{"location":"advanced/custom-recipe.html#complete-examples","text":"","title":"Complete Examples"},{"location":"advanced/custom-recipe.html#code-review-recipe","text":"name : code-review description : Comprehensive code review with multiple specialists context : file_path : \"\" review_depth : \"standard\" steps : - id : design-review agent : foundation:zen-architect instruction : | Review {{file_path}} for design issues: - Architecture patterns - Code organization - Complexity Depth: {{review_depth}} - id : security-review agent : foundation:security-guardian instruction : | Review {{file_path}} for security issues: - Input validation - Authentication/authorization - Data handling - id : test-review agent : foundation:test-coverage instruction : | Analyze test coverage for {{file_path}}: - Existing tests - Missing coverage - Test quality - id : final-report instruction : | Create a code review report combining: ## Design Review {{design-review.result}} ## Security Review {{security-review.result}} ## Test Coverage {{test-review.result}} Include: - Summary of findings - Priority-ordered action items - Overall assessment","title":"Code Review Recipe"},{"location":"advanced/custom-recipe.html#deployment-recipe-with-approval","text":"name : deploy description : Deploy to staging with approval gate context : environment : \"staging\" version : \"\" steps : - id : build instruction : \"Build version {{version}}\" - id : test instruction : \"Run full test suite\" - id : pre-deploy-check instruction : | Verify deployment readiness: - Build: {{build.result}} - Tests: {{test.result}} List any blockers. - id : approve-deploy requires_approval : true instruction : | Ready to deploy {{version}} to {{environment}}. Pre-check results: {{pre-deploy-check.result}} - id : deploy instruction : \"Deploy {{version}} to {{environment}}\" - id : verify instruction : \"Verify deployment health\"","title":"Deployment Recipe with Approval"},{"location":"advanced/custom-recipe.html#recipe-validation","text":"Check your recipe before running: amp recipes validate my-recipe.yaml Common validation errors: Error Solution Invalid YAML syntax Check indentation, quotes Unknown agent Verify agent name Missing context var Add to context section Circular reference Check step dependencies","title":"Recipe Validation"},{"location":"advanced/custom-recipe.html#recipe-author-agent","text":"Get help creating recipes: > Help me create a recipe for database migration The recipe-author agent will: - Ask clarifying questions - Suggest best structure - Generate valid YAML - Add error handling","title":"Recipe Author Agent"},{"location":"advanced/custom-recipe.html#try-it-yourself","text":"","title":"Try It Yourself"},{"location":"advanced/custom-recipe.html#exercise-1-simple-recipe","text":"# hello-recipe.yaml name : hello description : Simple greeting recipe context : name : \"\" steps : - id : greet instruction : \"Say hello to {{name}}\" amp recipes execute hello-recipe.yaml --context '{\"name\": \"World\"}'","title":"Exercise 1: Simple Recipe"},{"location":"advanced/custom-recipe.html#exercise-2-multi-step-recipe","text":"Create a recipe that: 1. Reads a file 2. Explains it 3. Suggests improvements","title":"Exercise 2: Multi-Step Recipe"},{"location":"advanced/custom-recipe.html#exercise-3-add-approval-gate","text":"Add an approval step before making changes.","title":"Exercise 3: Add Approval Gate"},{"location":"advanced/custom-recipe.html#best-practices","text":"Clear step IDs - Use descriptive names like analyze-deps not step1 One responsibility per step - Keep steps focused Use appropriate agents - Match agent specialty to task Add approval gates - For destructive or important operations Handle errors - Use on_error for steps that might fail Document context - Make required inputs clear","title":"Best Practices"},{"location":"advanced/custom-tool.html","text":"Creating Custom Tools \u00b6 Extend Amplifier with your own tools. Overview \u00b6 Custom tools let you: Add new capabilities - Integrate with any system Wrap existing CLIs - Make tools AI-friendly Connect to APIs - Custom integrations Automate workflows - Complex operations as single tools Tool Structure \u00b6 A tool is a Python module that implements the Tool protocol: # my_tool.py from amplifier_core import Tool class MyTool ( Tool ): name = \"my-tool\" description = \"What this tool does (shown to AI)\" input_schema = { \"type\" : \"object\" , \"properties\" : { \"param1\" : { \"type\" : \"string\" , \"description\" : \"First parameter\" } }, \"required\" : [ \"param1\" ] } async def execute ( self , input : dict ) -> str : param1 = input [ \"param1\" ] # Do something return f \"Result: { param1 } \" Basic Example: Timestamp Tool \u00b6 # modules/timestamp_tool/tool.py from datetime import datetime from amplifier_core import Tool class TimestampTool ( Tool ): name = \"timestamp\" description = \"Get the current timestamp in various formats\" input_schema = { \"type\" : \"object\" , \"properties\" : { \"format\" : { \"type\" : \"string\" , \"description\" : \"Output format: iso, unix, or human\" , \"enum\" : [ \"iso\" , \"unix\" , \"human\" ], \"default\" : \"iso\" } } } async def execute ( self , input : dict ) -> str : fmt = input . get ( \"format\" , \"iso\" ) now = datetime . now () if fmt == \"iso\" : return now . isoformat () elif fmt == \"unix\" : return str ( int ( now . timestamp ())) else : return now . strftime ( \"%B %d , %Y at %I:%M %p\" ) Register in Bundle \u00b6 # bundle.yaml tools : - module : timestamp-tool source : ./modules/timestamp_tool API Integration Example \u00b6 # modules/weather_tool/tool.py import httpx from amplifier_core import Tool class WeatherTool ( Tool ): name = \"weather\" description = \"Get current weather for a location\" input_schema = { \"type\" : \"object\" , \"properties\" : { \"city\" : { \"type\" : \"string\" , \"description\" : \"City name\" } }, \"required\" : [ \"city\" ] } def __init__ ( self , config : dict = None ): self . api_key = config . get ( \"api_key\" ) if config else None async def execute ( self , input : dict ) -> str : city = input [ \"city\" ] async with httpx . AsyncClient () as client : response = await client . get ( f \"https://api.weather.example.com/current\" , params = { \"city\" : city , \"key\" : self . api_key } ) data = response . json () return f \"Weather in { city } : { data [ 'temp' ] } \u00b0F, { data [ 'condition' ] } \" Configure with API key: tools : - module : weather-tool source : ./modules/weather_tool config : api_key : ${WEATHER_API_KEY} CLI Wrapper Example \u00b6 Wrap an existing CLI tool: # modules/docker_tool/tool.py import subprocess import json from amplifier_core import Tool class DockerTool ( Tool ): name = \"docker\" description = \"Manage Docker containers\" input_schema = { \"type\" : \"object\" , \"properties\" : { \"action\" : { \"type\" : \"string\" , \"enum\" : [ \"list\" , \"start\" , \"stop\" , \"logs\" ], \"description\" : \"Action to perform\" }, \"container\" : { \"type\" : \"string\" , \"description\" : \"Container name/ID (for start/stop/logs)\" } }, \"required\" : [ \"action\" ] } async def execute ( self , input : dict ) -> str : action = input [ \"action\" ] container = input . get ( \"container\" ) if action == \"list\" : result = subprocess . run ( [ \"docker\" , \"ps\" , \"--format\" , \"json\" ], capture_output = True , text = True ) return result . stdout elif action == \"start\" : result = subprocess . run ( [ \"docker\" , \"start\" , container ], capture_output = True , text = True ) return f \"Started { container } \" if result . returncode == 0 else result . stderr elif action == \"stop\" : result = subprocess . run ( [ \"docker\" , \"stop\" , container ], capture_output = True , text = True ) return f \"Stopped { container } \" if result . returncode == 0 else result . stderr elif action == \"logs\" : result = subprocess . run ( [ \"docker\" , \"logs\" , \"--tail\" , \"50\" , container ], capture_output = True , text = True ) return result . stdout or result . stderr Input Schema \u00b6 Define what the AI can pass to your tool: input_schema = { \"type\" : \"object\" , \"properties\" : { # Required string \"name\" : { \"type\" : \"string\" , \"description\" : \"User's name\" }, # Optional with default \"count\" : { \"type\" : \"integer\" , \"description\" : \"Number of items\" , \"default\" : 10 }, # Enum (limited choices) \"format\" : { \"type\" : \"string\" , \"enum\" : [ \"json\" , \"csv\" , \"xml\" ], \"description\" : \"Output format\" }, # Boolean \"verbose\" : { \"type\" : \"boolean\" , \"description\" : \"Show detailed output\" , \"default\" : False }, # Array \"tags\" : { \"type\" : \"array\" , \"items\" : { \"type\" : \"string\" }, \"description\" : \"List of tags\" } }, \"required\" : [ \"name\" ] # Which params are required } Error Handling \u00b6 Return clear error messages: async def execute ( self , input : dict ) -> str : try : result = self . do_something ( input ) return result except FileNotFoundError as e : return f \"Error: File not found - { e } \" except PermissionError as e : return f \"Error: Permission denied - { e } \" except Exception as e : return f \"Error: { type ( e ) . __name__ } - { e } \" Async Operations \u00b6 For I/O-bound operations, use async: import httpx async def execute ( self , input : dict ) -> str : async with httpx . AsyncClient () as client : response = await client . get ( input [ \"url\" ]) return response . text Configuration \u00b6 Tools can accept configuration: class MyTool ( Tool ): def __init__ ( self , config : dict = None ): config = config or {} self . api_key = config . get ( \"api_key\" ) self . base_url = config . get ( \"base_url\" , \"https://api.example.com\" ) tools : - module : my-tool source : ./modules/my_tool config : api_key : ${API_KEY} base_url : https://api.custom.com Module Structure \u00b6 modules/my_tool/ \u251c\u2500\u2500 __init__.py # Export the tool class \u251c\u2500\u2500 tool.py # Tool implementation \u2514\u2500\u2500 pyproject.toml # Dependencies (optional) __init__.py : from .tool import MyTool __all__ = [ \"MyTool\" ] Try It Yourself \u00b6 Exercise 1: Simple Tool \u00b6 Create modules/greet/tool.py : from amplifier_core import Tool class GreetTool ( Tool ): name = \"greet\" description = \"Generate a greeting\" input_schema = { \"type\" : \"object\" , \"properties\" : { \"name\" : { \"type\" : \"string\" , \"description\" : \"Name to greet\" } }, \"required\" : [ \"name\" ] } async def execute ( self , input : dict ) -> str : return f \"Hello, { input [ 'name' ] } ! Welcome to Amplifier.\" Add to bundle and test: > Use the greet tool to greet Alice Exercise 2: CLI Wrapper \u00b6 Wrap a CLI tool you use frequently (git, kubectl, etc.). Exercise 3: API Integration \u00b6 Create a tool that calls an API you work with. Best Practices \u00b6 Clear descriptions - Help the AI know when to use your tool Specific schemas - Use enums and defaults where appropriate Good error messages - Return actionable error info Async when possible - Don't block on I/O Minimal dependencies - Keep tools lightweight","title":"Custom Tools"},{"location":"advanced/custom-tool.html#creating-custom-tools","text":"Extend Amplifier with your own tools.","title":"Creating Custom Tools"},{"location":"advanced/custom-tool.html#overview","text":"Custom tools let you: Add new capabilities - Integrate with any system Wrap existing CLIs - Make tools AI-friendly Connect to APIs - Custom integrations Automate workflows - Complex operations as single tools","title":"Overview"},{"location":"advanced/custom-tool.html#tool-structure","text":"A tool is a Python module that implements the Tool protocol: # my_tool.py from amplifier_core import Tool class MyTool ( Tool ): name = \"my-tool\" description = \"What this tool does (shown to AI)\" input_schema = { \"type\" : \"object\" , \"properties\" : { \"param1\" : { \"type\" : \"string\" , \"description\" : \"First parameter\" } }, \"required\" : [ \"param1\" ] } async def execute ( self , input : dict ) -> str : param1 = input [ \"param1\" ] # Do something return f \"Result: { param1 } \"","title":"Tool Structure"},{"location":"advanced/custom-tool.html#basic-example-timestamp-tool","text":"# modules/timestamp_tool/tool.py from datetime import datetime from amplifier_core import Tool class TimestampTool ( Tool ): name = \"timestamp\" description = \"Get the current timestamp in various formats\" input_schema = { \"type\" : \"object\" , \"properties\" : { \"format\" : { \"type\" : \"string\" , \"description\" : \"Output format: iso, unix, or human\" , \"enum\" : [ \"iso\" , \"unix\" , \"human\" ], \"default\" : \"iso\" } } } async def execute ( self , input : dict ) -> str : fmt = input . get ( \"format\" , \"iso\" ) now = datetime . now () if fmt == \"iso\" : return now . isoformat () elif fmt == \"unix\" : return str ( int ( now . timestamp ())) else : return now . strftime ( \"%B %d , %Y at %I:%M %p\" )","title":"Basic Example: Timestamp Tool"},{"location":"advanced/custom-tool.html#register-in-bundle","text":"# bundle.yaml tools : - module : timestamp-tool source : ./modules/timestamp_tool","title":"Register in Bundle"},{"location":"advanced/custom-tool.html#api-integration-example","text":"# modules/weather_tool/tool.py import httpx from amplifier_core import Tool class WeatherTool ( Tool ): name = \"weather\" description = \"Get current weather for a location\" input_schema = { \"type\" : \"object\" , \"properties\" : { \"city\" : { \"type\" : \"string\" , \"description\" : \"City name\" } }, \"required\" : [ \"city\" ] } def __init__ ( self , config : dict = None ): self . api_key = config . get ( \"api_key\" ) if config else None async def execute ( self , input : dict ) -> str : city = input [ \"city\" ] async with httpx . AsyncClient () as client : response = await client . get ( f \"https://api.weather.example.com/current\" , params = { \"city\" : city , \"key\" : self . api_key } ) data = response . json () return f \"Weather in { city } : { data [ 'temp' ] } \u00b0F, { data [ 'condition' ] } \" Configure with API key: tools : - module : weather-tool source : ./modules/weather_tool config : api_key : ${WEATHER_API_KEY}","title":"API Integration Example"},{"location":"advanced/custom-tool.html#cli-wrapper-example","text":"Wrap an existing CLI tool: # modules/docker_tool/tool.py import subprocess import json from amplifier_core import Tool class DockerTool ( Tool ): name = \"docker\" description = \"Manage Docker containers\" input_schema = { \"type\" : \"object\" , \"properties\" : { \"action\" : { \"type\" : \"string\" , \"enum\" : [ \"list\" , \"start\" , \"stop\" , \"logs\" ], \"description\" : \"Action to perform\" }, \"container\" : { \"type\" : \"string\" , \"description\" : \"Container name/ID (for start/stop/logs)\" } }, \"required\" : [ \"action\" ] } async def execute ( self , input : dict ) -> str : action = input [ \"action\" ] container = input . get ( \"container\" ) if action == \"list\" : result = subprocess . run ( [ \"docker\" , \"ps\" , \"--format\" , \"json\" ], capture_output = True , text = True ) return result . stdout elif action == \"start\" : result = subprocess . run ( [ \"docker\" , \"start\" , container ], capture_output = True , text = True ) return f \"Started { container } \" if result . returncode == 0 else result . stderr elif action == \"stop\" : result = subprocess . run ( [ \"docker\" , \"stop\" , container ], capture_output = True , text = True ) return f \"Stopped { container } \" if result . returncode == 0 else result . stderr elif action == \"logs\" : result = subprocess . run ( [ \"docker\" , \"logs\" , \"--tail\" , \"50\" , container ], capture_output = True , text = True ) return result . stdout or result . stderr","title":"CLI Wrapper Example"},{"location":"advanced/custom-tool.html#input-schema","text":"Define what the AI can pass to your tool: input_schema = { \"type\" : \"object\" , \"properties\" : { # Required string \"name\" : { \"type\" : \"string\" , \"description\" : \"User's name\" }, # Optional with default \"count\" : { \"type\" : \"integer\" , \"description\" : \"Number of items\" , \"default\" : 10 }, # Enum (limited choices) \"format\" : { \"type\" : \"string\" , \"enum\" : [ \"json\" , \"csv\" , \"xml\" ], \"description\" : \"Output format\" }, # Boolean \"verbose\" : { \"type\" : \"boolean\" , \"description\" : \"Show detailed output\" , \"default\" : False }, # Array \"tags\" : { \"type\" : \"array\" , \"items\" : { \"type\" : \"string\" }, \"description\" : \"List of tags\" } }, \"required\" : [ \"name\" ] # Which params are required }","title":"Input Schema"},{"location":"advanced/custom-tool.html#error-handling","text":"Return clear error messages: async def execute ( self , input : dict ) -> str : try : result = self . do_something ( input ) return result except FileNotFoundError as e : return f \"Error: File not found - { e } \" except PermissionError as e : return f \"Error: Permission denied - { e } \" except Exception as e : return f \"Error: { type ( e ) . __name__ } - { e } \"","title":"Error Handling"},{"location":"advanced/custom-tool.html#async-operations","text":"For I/O-bound operations, use async: import httpx async def execute ( self , input : dict ) -> str : async with httpx . AsyncClient () as client : response = await client . get ( input [ \"url\" ]) return response . text","title":"Async Operations"},{"location":"advanced/custom-tool.html#configuration","text":"Tools can accept configuration: class MyTool ( Tool ): def __init__ ( self , config : dict = None ): config = config or {} self . api_key = config . get ( \"api_key\" ) self . base_url = config . get ( \"base_url\" , \"https://api.example.com\" ) tools : - module : my-tool source : ./modules/my_tool config : api_key : ${API_KEY} base_url : https://api.custom.com","title":"Configuration"},{"location":"advanced/custom-tool.html#module-structure","text":"modules/my_tool/ \u251c\u2500\u2500 __init__.py # Export the tool class \u251c\u2500\u2500 tool.py # Tool implementation \u2514\u2500\u2500 pyproject.toml # Dependencies (optional) __init__.py : from .tool import MyTool __all__ = [ \"MyTool\" ]","title":"Module Structure"},{"location":"advanced/custom-tool.html#try-it-yourself","text":"","title":"Try It Yourself"},{"location":"advanced/custom-tool.html#exercise-1-simple-tool","text":"Create modules/greet/tool.py : from amplifier_core import Tool class GreetTool ( Tool ): name = \"greet\" description = \"Generate a greeting\" input_schema = { \"type\" : \"object\" , \"properties\" : { \"name\" : { \"type\" : \"string\" , \"description\" : \"Name to greet\" } }, \"required\" : [ \"name\" ] } async def execute ( self , input : dict ) -> str : return f \"Hello, { input [ 'name' ] } ! Welcome to Amplifier.\" Add to bundle and test: > Use the greet tool to greet Alice","title":"Exercise 1: Simple Tool"},{"location":"advanced/custom-tool.html#exercise-2-cli-wrapper","text":"Wrap a CLI tool you use frequently (git, kubectl, etc.).","title":"Exercise 2: CLI Wrapper"},{"location":"advanced/custom-tool.html#exercise-3-api-integration","text":"Create a tool that calls an API you work with.","title":"Exercise 3: API Integration"},{"location":"advanced/custom-tool.html#best-practices","text":"Clear descriptions - Help the AI know when to use your tool Specific schemas - Use enums and defaults where appropriate Good error messages - Return actionable error info Async when possible - Don't block on I/O Minimal dependencies - Keep tools lightweight","title":"Best Practices"},{"location":"advanced/mcp-integration.html","text":"MCP Integration \u00b6 Connect Amplifier to Model Context Protocol servers. Overview \u00b6 MCP (Model Context Protocol) is a standard for connecting AI assistants to external tools and data sources. Amplifier supports MCP servers, letting you: Connect to databases - Query and modify data Access APIs - Any service with MCP support Use external tools - Capabilities from MCP ecosystem Share tools - Same server works with multiple clients What is MCP? \u00b6 MCP separates: - Client - The AI assistant (Amplifier) - Server - Provider of tools/resources Amplifier (Client) \u2190\u2192 MCP Server \u2190\u2192 External System Benefits: - Standard protocol - Reusable servers - Ecosystem of tools - Works with multiple AI clients Configuring MCP Servers \u00b6 In Settings \u00b6 # ~/.amplifier/settings.yaml mcp : servers : - name : filesystem command : npx @modelcontextprotocol/server-filesystem args : [ \"/allowed/path\" ] - name : postgres command : npx @modelcontextprotocol/server-postgres env : DATABASE_URL : \"postgresql://user:pass@localhost/db\" In Bundle \u00b6 # bundle.yaml mcp : servers : - name : my-server command : python my_server.py Available MCP Servers \u00b6 Official Servers \u00b6 Server Purpose @modelcontextprotocol/server-filesystem File operations @modelcontextprotocol/server-postgres PostgreSQL queries @modelcontextprotocol/server-sqlite SQLite databases @modelcontextprotocol/server-github GitHub API Installing Servers \u00b6 # Via npm npm install -g @modelcontextprotocol/server-filesystem npm install -g @modelcontextprotocol/server-postgres # Via pip pip install mcp-server-fetch Example: Filesystem Server \u00b6 Configure \u00b6 mcp : servers : - name : files command : npx @modelcontextprotocol/server-filesystem args : [ \"/home/user/projects\" ] Use \u00b6 The server adds tools that Amplifier can use: > List files in /home/user/projects > Read the contents of package.json Example: Database Server \u00b6 Configure \u00b6 mcp : servers : - name : database command : npx @modelcontextprotocol/server-postgres env : DATABASE_URL : \"postgresql://localhost/mydb\" Use \u00b6 > Show all tables in the database > Query the users table for active users > Count orders from last week Example: GitHub Server \u00b6 Configure \u00b6 mcp : servers : - name : github command : npx @modelcontextprotocol/server-github env : GITHUB_TOKEN : ${GITHUB_TOKEN} Use \u00b6 > List open PRs in microsoft/amplifier > Get details of issue #123 > Show my recent commits Creating MCP Servers \u00b6 Python Server \u00b6 # my_server.py from mcp.server import Server from mcp.types import Tool , TextContent server = Server ( \"my-server\" ) @server . tool () async def get_weather ( city : str ) -> str : \"\"\"Get weather for a city\"\"\" # Implementation return f \"Weather in { city } : Sunny, 72\u00b0F\" @server . tool () async def search_docs ( query : str ) -> str : \"\"\"Search internal documentation\"\"\" # Implementation return f \"Found 5 results for: { query } \" if __name__ == \"__main__\" : server . run () Register \u00b6 mcp : servers : - name : my-tools command : python my_server.py MCP Resources \u00b6 MCP servers can also provide resources (data): @server . resource ( \"docs:// {path} \" ) async def get_doc ( path : str ) -> str : \"\"\"Get documentation by path\"\"\" with open ( f \"/docs/ { path } \" ) as f : return f . read () Access in Amplifier: > Get the resource docs://api/auth.md Debugging MCP \u00b6 Test Server Directly \u00b6 # Run server npx @modelcontextprotocol/server-filesystem /tmp # In another terminal, test with mcp CLI mcp test-server filesystem Check Logs \u00b6 # Amplifier logs MCP communication export AMPLIFIER_LOG_LEVEL = debug amp Common Issues \u00b6 Server not starting: - Check command path - Verify dependencies installed - Check environment variables Tools not appearing: - Restart Amplifier - Verify server is running - Check server logs Permission errors: - Check allowed paths - Verify credentials - Check environment setup Security Considerations \u00b6 Principle of Least Privilege \u00b6 mcp : servers : # Good - limited scope - name : project-files command : npx @modelcontextprotocol/server-filesystem args : [ \"/home/user/current-project\" ] # Avoid - too broad - name : all-files command : npx @modelcontextprotocol/server-filesystem args : [ \"/\" ] # Don't do this! Credential Management \u00b6 mcp : servers : - name : database command : npx @modelcontextprotocol/server-postgres env : # Use environment variable, not hardcoded DATABASE_URL : ${DATABASE_URL} Audit MCP Actions \u00b6 MCP tool calls appear in session logs: cat events.jsonl | jq 'select(.tool_name | startswith(\"mcp:\"))' Try It Yourself \u00b6 Exercise 1: Filesystem Server \u00b6 # Add to ~/.amplifier/settings.yaml mcp : servers : - name : files command : npx @modelcontextprotocol/server-filesystem args : [ \"./\" ] npm install -g @modelcontextprotocol/server-filesystem amp > What files are in this directory? Exercise 2: SQLite Server \u00b6 mcp : servers : - name : db command : npx @modelcontextprotocol/server-sqlite args : [ \"./test.db\" ] > Create a users table > Insert some test data > Query all users Resources \u00b6 MCP Specification Official Servers Python SDK TypeScript SDK","title":"MCP Integration"},{"location":"advanced/mcp-integration.html#mcp-integration","text":"Connect Amplifier to Model Context Protocol servers.","title":"MCP Integration"},{"location":"advanced/mcp-integration.html#overview","text":"MCP (Model Context Protocol) is a standard for connecting AI assistants to external tools and data sources. Amplifier supports MCP servers, letting you: Connect to databases - Query and modify data Access APIs - Any service with MCP support Use external tools - Capabilities from MCP ecosystem Share tools - Same server works with multiple clients","title":"Overview"},{"location":"advanced/mcp-integration.html#what-is-mcp","text":"MCP separates: - Client - The AI assistant (Amplifier) - Server - Provider of tools/resources Amplifier (Client) \u2190\u2192 MCP Server \u2190\u2192 External System Benefits: - Standard protocol - Reusable servers - Ecosystem of tools - Works with multiple AI clients","title":"What is MCP?"},{"location":"advanced/mcp-integration.html#configuring-mcp-servers","text":"","title":"Configuring MCP Servers"},{"location":"advanced/mcp-integration.html#in-settings","text":"# ~/.amplifier/settings.yaml mcp : servers : - name : filesystem command : npx @modelcontextprotocol/server-filesystem args : [ \"/allowed/path\" ] - name : postgres command : npx @modelcontextprotocol/server-postgres env : DATABASE_URL : \"postgresql://user:pass@localhost/db\"","title":"In Settings"},{"location":"advanced/mcp-integration.html#in-bundle","text":"# bundle.yaml mcp : servers : - name : my-server command : python my_server.py","title":"In Bundle"},{"location":"advanced/mcp-integration.html#available-mcp-servers","text":"","title":"Available MCP Servers"},{"location":"advanced/mcp-integration.html#official-servers","text":"Server Purpose @modelcontextprotocol/server-filesystem File operations @modelcontextprotocol/server-postgres PostgreSQL queries @modelcontextprotocol/server-sqlite SQLite databases @modelcontextprotocol/server-github GitHub API","title":"Official Servers"},{"location":"advanced/mcp-integration.html#installing-servers","text":"# Via npm npm install -g @modelcontextprotocol/server-filesystem npm install -g @modelcontextprotocol/server-postgres # Via pip pip install mcp-server-fetch","title":"Installing Servers"},{"location":"advanced/mcp-integration.html#example-filesystem-server","text":"","title":"Example: Filesystem Server"},{"location":"advanced/mcp-integration.html#configure","text":"mcp : servers : - name : files command : npx @modelcontextprotocol/server-filesystem args : [ \"/home/user/projects\" ]","title":"Configure"},{"location":"advanced/mcp-integration.html#use","text":"The server adds tools that Amplifier can use: > List files in /home/user/projects > Read the contents of package.json","title":"Use"},{"location":"advanced/mcp-integration.html#example-database-server","text":"","title":"Example: Database Server"},{"location":"advanced/mcp-integration.html#configure_1","text":"mcp : servers : - name : database command : npx @modelcontextprotocol/server-postgres env : DATABASE_URL : \"postgresql://localhost/mydb\"","title":"Configure"},{"location":"advanced/mcp-integration.html#use_1","text":"> Show all tables in the database > Query the users table for active users > Count orders from last week","title":"Use"},{"location":"advanced/mcp-integration.html#example-github-server","text":"","title":"Example: GitHub Server"},{"location":"advanced/mcp-integration.html#configure_2","text":"mcp : servers : - name : github command : npx @modelcontextprotocol/server-github env : GITHUB_TOKEN : ${GITHUB_TOKEN}","title":"Configure"},{"location":"advanced/mcp-integration.html#use_2","text":"> List open PRs in microsoft/amplifier > Get details of issue #123 > Show my recent commits","title":"Use"},{"location":"advanced/mcp-integration.html#creating-mcp-servers","text":"","title":"Creating MCP Servers"},{"location":"advanced/mcp-integration.html#python-server","text":"# my_server.py from mcp.server import Server from mcp.types import Tool , TextContent server = Server ( \"my-server\" ) @server . tool () async def get_weather ( city : str ) -> str : \"\"\"Get weather for a city\"\"\" # Implementation return f \"Weather in { city } : Sunny, 72\u00b0F\" @server . tool () async def search_docs ( query : str ) -> str : \"\"\"Search internal documentation\"\"\" # Implementation return f \"Found 5 results for: { query } \" if __name__ == \"__main__\" : server . run ()","title":"Python Server"},{"location":"advanced/mcp-integration.html#register","text":"mcp : servers : - name : my-tools command : python my_server.py","title":"Register"},{"location":"advanced/mcp-integration.html#mcp-resources","text":"MCP servers can also provide resources (data): @server . resource ( \"docs:// {path} \" ) async def get_doc ( path : str ) -> str : \"\"\"Get documentation by path\"\"\" with open ( f \"/docs/ { path } \" ) as f : return f . read () Access in Amplifier: > Get the resource docs://api/auth.md","title":"MCP Resources"},{"location":"advanced/mcp-integration.html#debugging-mcp","text":"","title":"Debugging MCP"},{"location":"advanced/mcp-integration.html#test-server-directly","text":"# Run server npx @modelcontextprotocol/server-filesystem /tmp # In another terminal, test with mcp CLI mcp test-server filesystem","title":"Test Server Directly"},{"location":"advanced/mcp-integration.html#check-logs","text":"# Amplifier logs MCP communication export AMPLIFIER_LOG_LEVEL = debug amp","title":"Check Logs"},{"location":"advanced/mcp-integration.html#common-issues","text":"Server not starting: - Check command path - Verify dependencies installed - Check environment variables Tools not appearing: - Restart Amplifier - Verify server is running - Check server logs Permission errors: - Check allowed paths - Verify credentials - Check environment setup","title":"Common Issues"},{"location":"advanced/mcp-integration.html#security-considerations","text":"","title":"Security Considerations"},{"location":"advanced/mcp-integration.html#principle-of-least-privilege","text":"mcp : servers : # Good - limited scope - name : project-files command : npx @modelcontextprotocol/server-filesystem args : [ \"/home/user/current-project\" ] # Avoid - too broad - name : all-files command : npx @modelcontextprotocol/server-filesystem args : [ \"/\" ] # Don't do this!","title":"Principle of Least Privilege"},{"location":"advanced/mcp-integration.html#credential-management","text":"mcp : servers : - name : database command : npx @modelcontextprotocol/server-postgres env : # Use environment variable, not hardcoded DATABASE_URL : ${DATABASE_URL}","title":"Credential Management"},{"location":"advanced/mcp-integration.html#audit-mcp-actions","text":"MCP tool calls appear in session logs: cat events.jsonl | jq 'select(.tool_name | startswith(\"mcp:\"))'","title":"Audit MCP Actions"},{"location":"advanced/mcp-integration.html#try-it-yourself","text":"","title":"Try It Yourself"},{"location":"advanced/mcp-integration.html#exercise-1-filesystem-server","text":"# Add to ~/.amplifier/settings.yaml mcp : servers : - name : files command : npx @modelcontextprotocol/server-filesystem args : [ \"./\" ] npm install -g @modelcontextprotocol/server-filesystem amp > What files are in this directory?","title":"Exercise 1: Filesystem Server"},{"location":"advanced/mcp-integration.html#exercise-2-sqlite-server","text":"mcp : servers : - name : db command : npx @modelcontextprotocol/server-sqlite args : [ \"./test.db\" ] > Create a users table > Insert some test data > Query all users","title":"Exercise 2: SQLite Server"},{"location":"advanced/mcp-integration.html#resources","text":"MCP Specification Official Servers Python SDK TypeScript SDK","title":"Resources"},{"location":"bundles/index.html","text":"Bundles Guide \u00b6 Bundles are the primary way to customize Amplifier's behavior. A bundle packages together tools, agents, context, and configuration into a cohesive, reusable unit. This section teaches you how to use existing bundles, create your own, and compose them for powerful applications. Section Contents \u00b6 Page Description Foundation Core Amplifier bundle with essential capabilities Recipes Multi-step workflow orchestration LSP Python Python code intelligence via Language Server Protocol Design Intelligence Design system and UI expertise Quick Tips \u00b6 Thin bundles - Keep bundles focused; compose for complexity Reuse context - Reference shared context files instead of duplicating Version carefully - Bundle changes affect all users Test in isolation - Verify bundles work independently before composing Document behavior - Clear descriptions help users and AI understand intent Bundle Anatomy \u00b6 my-bundle/ \u251c\u2500\u2500 bundle.yaml # Bundle manifest \u251c\u2500\u2500 context/ # Knowledge and instructions \u2502 \u251c\u2500\u2500 README.md # Primary context \u2502 \u2514\u2500\u2500 examples/ # Example files \u251c\u2500\u2500 agents/ # Agent definitions \u2502 \u2514\u2500\u2500 specialist.yaml \u2514\u2500\u2500 skills/ # Optional skills \u2514\u2500\u2500 domain-skill.md The Thin Bundle Philosophy \u00b6 Bundles should be minimal compositions, not monolithic packages: Do Don't Reference shared context Duplicate instructions Compose multiple thin bundles Build one giant bundle Single responsibility Kitchen sink approach Clear extension points Tightly coupled internals Where to Start \u00b6 Core capabilities? Begin with Foundation for the essential Amplifier bundle. Workflow automation? Jump to Recipes for multi-step orchestration. Python development? See LSP Python for code intelligence. Example: Minimal Bundle \u00b6 # bundle.yaml name : my-assistant description : Custom assistant behavior version : 1.0.0 context : - context/README.md extends : - foundation # Inherit base capabilities Next Steps \u00b6 After mastering bundles, explore Skills for adding domain knowledge or Advanced for complex patterns.","title":"Overview"},{"location":"bundles/index.html#bundles-guide","text":"Bundles are the primary way to customize Amplifier's behavior. A bundle packages together tools, agents, context, and configuration into a cohesive, reusable unit. This section teaches you how to use existing bundles, create your own, and compose them for powerful applications.","title":"Bundles Guide"},{"location":"bundles/index.html#section-contents","text":"Page Description Foundation Core Amplifier bundle with essential capabilities Recipes Multi-step workflow orchestration LSP Python Python code intelligence via Language Server Protocol Design Intelligence Design system and UI expertise","title":"Section Contents"},{"location":"bundles/index.html#quick-tips","text":"Thin bundles - Keep bundles focused; compose for complexity Reuse context - Reference shared context files instead of duplicating Version carefully - Bundle changes affect all users Test in isolation - Verify bundles work independently before composing Document behavior - Clear descriptions help users and AI understand intent","title":"Quick Tips"},{"location":"bundles/index.html#bundle-anatomy","text":"my-bundle/ \u251c\u2500\u2500 bundle.yaml # Bundle manifest \u251c\u2500\u2500 context/ # Knowledge and instructions \u2502 \u251c\u2500\u2500 README.md # Primary context \u2502 \u2514\u2500\u2500 examples/ # Example files \u251c\u2500\u2500 agents/ # Agent definitions \u2502 \u2514\u2500\u2500 specialist.yaml \u2514\u2500\u2500 skills/ # Optional skills \u2514\u2500\u2500 domain-skill.md","title":"Bundle Anatomy"},{"location":"bundles/index.html#the-thin-bundle-philosophy","text":"Bundles should be minimal compositions, not monolithic packages: Do Don't Reference shared context Duplicate instructions Compose multiple thin bundles Build one giant bundle Single responsibility Kitchen sink approach Clear extension points Tightly coupled internals","title":"The Thin Bundle Philosophy"},{"location":"bundles/index.html#where-to-start","text":"Core capabilities? Begin with Foundation for the essential Amplifier bundle. Workflow automation? Jump to Recipes for multi-step orchestration. Python development? See LSP Python for code intelligence.","title":"Where to Start"},{"location":"bundles/index.html#example-minimal-bundle","text":"# bundle.yaml name : my-assistant description : Custom assistant behavior version : 1.0.0 context : - context/README.md extends : - foundation # Inherit base capabilities","title":"Example: Minimal Bundle"},{"location":"bundles/index.html#next-steps","text":"After mastering bundles, explore Skills for adding domain knowledge or Advanced for complex patterns.","title":"Next Steps"},{"location":"bundles/design-intelligence.html","text":"Design Intelligence Bundle \u00b6 Overview \u00b6 The Design Intelligence bundle provides a team of specialized AI agents for UI/UX design work. Rather than a single generalist design assistant, this bundle offers role-specific experts that mirror how professional design teams operate. Each agent brings deep expertise in their domain while sharing a common design philosophy rooted in the Nine Dimensions and Five Pillars framework. They work together through orchestration, allowing you to tackle design challenges from strategic vision down to pixel-level implementation. Agents Included \u00b6 Agent Purpose Primary Domain art-director Visual strategy and aesthetic direction Style, brand expression component-designer Individual UI component design Component-level refinement animation-choreographer Motion and transitions Animation timing, micro-interactions design-system-architect Design tokens and foundations System-level architecture layout-architect Page structure and spatial composition Information architecture responsive-strategist Multi-device adaptation Breakpoints, device patterns voice-strategist UX writing and tone Microcopy, messaging art-director \u00b6 The Art Director owns aesthetic direction and visual strategy. This agent transforms abstract concepts like \"feels premium\" or \"approachable but professional\" into systematic design principles. Responsibilities: - Defining and maintaining the aesthetic guide - Ensuring visual coherence across the system - Translating brand personality into design decisions - Resolving conflicts between competing visual approaches Best for: Starting new projects, establishing visual identity, reviewing design consistency. component-designer \u00b6 The Component Designer works at the individual element level, crafting buttons, cards, inputs, and other UI building blocks that embody your design system. Responsibilities: - Designing new UI components from specifications - Refining existing components for quality - Creating component variants and props APIs - Documenting component usage and examples Best for: Building design system libraries, refining individual elements, component documentation. animation-choreographer \u00b6 The Animation Choreographer treats motion as communication. Every transition, micro-interaction, and state change carries meaning and provides feedback. Responsibilities: - Designing icon animations and micro-interactions - Planning page transitions and choreography - Creating loading states and progress indicators - Establishing motion timing and easing standards - Ensuring accessibility for motion-sensitive users Best for: Adding polish to interactions, designing loading experiences, establishing motion language. design-system-architect \u00b6 The Design System Architect works at the foundation level, establishing tokens, scales, and systematic patterns that ensure consistency across all design work. Responsibilities: - Designing color, typography, and spacing scales - Creating and managing design tokens - Establishing grid systems and layout foundations - Evaluating decisions against the Nine Dimensions - Defining cross-cutting design concerns Best for: Starting design systems, establishing foundations, ensuring systematic consistency. layout-architect \u00b6 The Layout Architect handles page-level structure and information hierarchy. They determine how content flows and how users navigate through information. Responsibilities: - Designing page/view layouts (header, sidebar, main, footer) - Planning information architecture and navigation - Creating grid systems and spatial composition - Establishing content flow and reading patterns Best for: Planning application structure, designing navigation systems, establishing page templates. responsive-strategist \u00b6 The Responsive Strategist ensures designs work across all devices and input methods, from mobile touch to desktop mouse interactions. Responsibilities: - Defining breakpoint strategy and behavior - Planning mobile-first vs desktop-first approaches - Adapting touch vs mouse interaction patterns - Optimizing for specific device categories - Implementing fluid typography and spacing Best for: Multi-device design, mobile optimization, touch interface considerations. voice-strategist \u00b6 The Voice Strategist ensures every word in your interface serves users. From button labels to error messages, language shapes user experience. Responsibilities: - Establishing voice and tone frameworks - Writing UX copy and microcopy - Creating error message patterns - Designing empty state messaging - Developing content guidelines for developers Best for: Interface copy, error handling UX, establishing tone guidelines. The Nine Dimensions \u00b6 The Design Intelligence agents share a common evaluation framework called the Nine Dimensions. When assessing design quality, each dimension receives attention: Dimension Focus Key Questions Style Visual identity and aesthetic Does it feel cohesive? Does it express the brand? Color Palette, contrast, meaning Is contrast accessible? Do colors communicate state? Voice Language, tone, personality Is copy clear and helpful? Is tone consistent? Space Layout, whitespace, breathing room Does content have room to breathe? Is hierarchy clear? Motion Animation, transitions, feedback Does motion communicate? Is timing appropriate? Type Typography, readability, scale Is text readable? Does hierarchy guide the eye? Touch Interaction, affordance, feedback Are targets large enough? Is interaction clear? State Loading, error, empty, success Are all states designed? Is feedback immediate? Flow Navigation, progression, journey Is the path clear? Can users recover from mistakes? Agents reference these dimensions when making decisions and can explain their recommendations in terms of specific dimensional impacts. The Five Pillars \u00b6 Beyond the Nine Dimensions, agents are guided by Five Pillars that establish baseline quality: Clarity - Every element communicates its purpose Consistency - Patterns repeat predictably across the system Accessibility - Design works for all users and abilities Performance - Visual design supports fast, responsive experiences Delight - Thoughtful details that elevate the mundane When to Use \u00b6 Starting a New Project \u00b6 Begin with art-director to establish aesthetic direction, then design-system-architect to create foundations: You: \"I'm building a developer tools SaaS. It should feel professional but not corporate, technical but approachable.\" art-director: Analyzes requirements, creates AESTHETIC-GUIDE.md with color direction, typography approach, and visual principles. design-system-architect: Translates aesthetic into concrete tokens - color scales, type scales, spacing system. Building Components \u00b6 Use component-designer when implementing specific UI elements: You: \"Design a notification badge component that shows unread counts\" component-designer: Creates component spec with variants (dot, count, overflow), states (default, attention, muted), and accessibility considerations. Adding Motion \u00b6 Bring in animation-choreographer to design purposeful animations: You: \"The save button feels static. It should provide feedback.\" animation-choreographer: Designs micro-interaction sequence - button press response, processing state, success confirmation with appropriate timing. Multi-Device Work \u00b6 Consult responsive-strategist for device-specific decisions: You: \"Our dashboard has too much information for mobile screens\" responsive-strategist: Analyzes content priority, suggests progressive disclosure pattern, defines what collapses vs hides vs reorganizes at each breakpoint. Writing Interface Copy \u00b6 Use voice-strategist for any text that users see: You: \"What should the error message say when file upload fails?\" voice-strategist: Crafts message considering context, user emotion, actionability: \"Upload failed. Check your connection and try again, or try a smaller file (max 10MB).\" Try It Yourself \u00b6 Establish Visual Direction \u00b6 I'm building a meditation app for busy professionals. The vibe should be calming but not new-age, minimal but not cold. Help me establish the visual direction. Design a Component \u00b6 Design a progress indicator component for a multi-step form. It needs to show: current step, completed steps, remaining steps, and allow clicking back to completed steps. Plan Motion \u00b6 Design the animation for a mobile menu that slides in from the right. Consider: the trigger button, the overlay, the menu content, and how items stagger in. Create Responsive Strategy \u00b6 I have a data table that works on desktop but breaks on mobile. The table has 8 columns: name, status, date, amount, category, assignee, priority, and actions. Help me plan the responsive approach. Write Error Messages \u00b6 Create a set of error messages for a payment form. Cover: invalid card number, expired card, insufficient funds, network error, and general processing failure. Agent Collaboration \u00b6 Design Intelligence agents work together through orchestration. Common collaboration patterns: Art Director + Design System Architect : Art director sets direction, architect implements as tokens. Component Designer + Animation Choreographer : Designer creates static component, choreographer adds motion. Layout Architect + Responsive Strategist : Layout architect designs desktop, strategist adapts for all devices. Voice Strategist + Component Designer : Voice strategist writes copy, designer integrates into component specs. Configuration \u00b6 The Design Intelligence bundle is included in Amplifier Foundation. Enable it in your bundle configuration: # .amplifier/config.yaml bundles : - foundation - design-intelligence Individual agents can be invoked directly or through the main assistant which will delegate to the appropriate specialist based on your request. Quality Baseline \u00b6 All Design Intelligence agents work toward a 9.5/10 quality baseline. This means: No placeholder or generic solutions Every decision justified against the Nine Dimensions Accessibility considered by default Edge cases and states addressed Implementation guidance included When you receive design recommendations, you're getting production-ready guidance, not rough sketches. Related Resources \u00b6 Amplifier Foundation Bundle - Core development agents Advanced Topics - Custom bundles and tools Bundles Guide - How bundles work together","title":"Design Intelligence"},{"location":"bundles/design-intelligence.html#design-intelligence-bundle","text":"","title":"Design Intelligence Bundle"},{"location":"bundles/design-intelligence.html#overview","text":"The Design Intelligence bundle provides a team of specialized AI agents for UI/UX design work. Rather than a single generalist design assistant, this bundle offers role-specific experts that mirror how professional design teams operate. Each agent brings deep expertise in their domain while sharing a common design philosophy rooted in the Nine Dimensions and Five Pillars framework. They work together through orchestration, allowing you to tackle design challenges from strategic vision down to pixel-level implementation.","title":"Overview"},{"location":"bundles/design-intelligence.html#agents-included","text":"Agent Purpose Primary Domain art-director Visual strategy and aesthetic direction Style, brand expression component-designer Individual UI component design Component-level refinement animation-choreographer Motion and transitions Animation timing, micro-interactions design-system-architect Design tokens and foundations System-level architecture layout-architect Page structure and spatial composition Information architecture responsive-strategist Multi-device adaptation Breakpoints, device patterns voice-strategist UX writing and tone Microcopy, messaging","title":"Agents Included"},{"location":"bundles/design-intelligence.html#art-director","text":"The Art Director owns aesthetic direction and visual strategy. This agent transforms abstract concepts like \"feels premium\" or \"approachable but professional\" into systematic design principles. Responsibilities: - Defining and maintaining the aesthetic guide - Ensuring visual coherence across the system - Translating brand personality into design decisions - Resolving conflicts between competing visual approaches Best for: Starting new projects, establishing visual identity, reviewing design consistency.","title":"art-director"},{"location":"bundles/design-intelligence.html#component-designer","text":"The Component Designer works at the individual element level, crafting buttons, cards, inputs, and other UI building blocks that embody your design system. Responsibilities: - Designing new UI components from specifications - Refining existing components for quality - Creating component variants and props APIs - Documenting component usage and examples Best for: Building design system libraries, refining individual elements, component documentation.","title":"component-designer"},{"location":"bundles/design-intelligence.html#animation-choreographer","text":"The Animation Choreographer treats motion as communication. Every transition, micro-interaction, and state change carries meaning and provides feedback. Responsibilities: - Designing icon animations and micro-interactions - Planning page transitions and choreography - Creating loading states and progress indicators - Establishing motion timing and easing standards - Ensuring accessibility for motion-sensitive users Best for: Adding polish to interactions, designing loading experiences, establishing motion language.","title":"animation-choreographer"},{"location":"bundles/design-intelligence.html#design-system-architect","text":"The Design System Architect works at the foundation level, establishing tokens, scales, and systematic patterns that ensure consistency across all design work. Responsibilities: - Designing color, typography, and spacing scales - Creating and managing design tokens - Establishing grid systems and layout foundations - Evaluating decisions against the Nine Dimensions - Defining cross-cutting design concerns Best for: Starting design systems, establishing foundations, ensuring systematic consistency.","title":"design-system-architect"},{"location":"bundles/design-intelligence.html#layout-architect","text":"The Layout Architect handles page-level structure and information hierarchy. They determine how content flows and how users navigate through information. Responsibilities: - Designing page/view layouts (header, sidebar, main, footer) - Planning information architecture and navigation - Creating grid systems and spatial composition - Establishing content flow and reading patterns Best for: Planning application structure, designing navigation systems, establishing page templates.","title":"layout-architect"},{"location":"bundles/design-intelligence.html#responsive-strategist","text":"The Responsive Strategist ensures designs work across all devices and input methods, from mobile touch to desktop mouse interactions. Responsibilities: - Defining breakpoint strategy and behavior - Planning mobile-first vs desktop-first approaches - Adapting touch vs mouse interaction patterns - Optimizing for specific device categories - Implementing fluid typography and spacing Best for: Multi-device design, mobile optimization, touch interface considerations.","title":"responsive-strategist"},{"location":"bundles/design-intelligence.html#voice-strategist","text":"The Voice Strategist ensures every word in your interface serves users. From button labels to error messages, language shapes user experience. Responsibilities: - Establishing voice and tone frameworks - Writing UX copy and microcopy - Creating error message patterns - Designing empty state messaging - Developing content guidelines for developers Best for: Interface copy, error handling UX, establishing tone guidelines.","title":"voice-strategist"},{"location":"bundles/design-intelligence.html#the-nine-dimensions","text":"The Design Intelligence agents share a common evaluation framework called the Nine Dimensions. When assessing design quality, each dimension receives attention: Dimension Focus Key Questions Style Visual identity and aesthetic Does it feel cohesive? Does it express the brand? Color Palette, contrast, meaning Is contrast accessible? Do colors communicate state? Voice Language, tone, personality Is copy clear and helpful? Is tone consistent? Space Layout, whitespace, breathing room Does content have room to breathe? Is hierarchy clear? Motion Animation, transitions, feedback Does motion communicate? Is timing appropriate? Type Typography, readability, scale Is text readable? Does hierarchy guide the eye? Touch Interaction, affordance, feedback Are targets large enough? Is interaction clear? State Loading, error, empty, success Are all states designed? Is feedback immediate? Flow Navigation, progression, journey Is the path clear? Can users recover from mistakes? Agents reference these dimensions when making decisions and can explain their recommendations in terms of specific dimensional impacts.","title":"The Nine Dimensions"},{"location":"bundles/design-intelligence.html#the-five-pillars","text":"Beyond the Nine Dimensions, agents are guided by Five Pillars that establish baseline quality: Clarity - Every element communicates its purpose Consistency - Patterns repeat predictably across the system Accessibility - Design works for all users and abilities Performance - Visual design supports fast, responsive experiences Delight - Thoughtful details that elevate the mundane","title":"The Five Pillars"},{"location":"bundles/design-intelligence.html#when-to-use","text":"","title":"When to Use"},{"location":"bundles/design-intelligence.html#starting-a-new-project","text":"Begin with art-director to establish aesthetic direction, then design-system-architect to create foundations: You: \"I'm building a developer tools SaaS. It should feel professional but not corporate, technical but approachable.\" art-director: Analyzes requirements, creates AESTHETIC-GUIDE.md with color direction, typography approach, and visual principles. design-system-architect: Translates aesthetic into concrete tokens - color scales, type scales, spacing system.","title":"Starting a New Project"},{"location":"bundles/design-intelligence.html#building-components","text":"Use component-designer when implementing specific UI elements: You: \"Design a notification badge component that shows unread counts\" component-designer: Creates component spec with variants (dot, count, overflow), states (default, attention, muted), and accessibility considerations.","title":"Building Components"},{"location":"bundles/design-intelligence.html#adding-motion","text":"Bring in animation-choreographer to design purposeful animations: You: \"The save button feels static. It should provide feedback.\" animation-choreographer: Designs micro-interaction sequence - button press response, processing state, success confirmation with appropriate timing.","title":"Adding Motion"},{"location":"bundles/design-intelligence.html#multi-device-work","text":"Consult responsive-strategist for device-specific decisions: You: \"Our dashboard has too much information for mobile screens\" responsive-strategist: Analyzes content priority, suggests progressive disclosure pattern, defines what collapses vs hides vs reorganizes at each breakpoint.","title":"Multi-Device Work"},{"location":"bundles/design-intelligence.html#writing-interface-copy","text":"Use voice-strategist for any text that users see: You: \"What should the error message say when file upload fails?\" voice-strategist: Crafts message considering context, user emotion, actionability: \"Upload failed. Check your connection and try again, or try a smaller file (max 10MB).\"","title":"Writing Interface Copy"},{"location":"bundles/design-intelligence.html#try-it-yourself","text":"","title":"Try It Yourself"},{"location":"bundles/design-intelligence.html#establish-visual-direction","text":"I'm building a meditation app for busy professionals. The vibe should be calming but not new-age, minimal but not cold. Help me establish the visual direction.","title":"Establish Visual Direction"},{"location":"bundles/design-intelligence.html#design-a-component","text":"Design a progress indicator component for a multi-step form. It needs to show: current step, completed steps, remaining steps, and allow clicking back to completed steps.","title":"Design a Component"},{"location":"bundles/design-intelligence.html#plan-motion","text":"Design the animation for a mobile menu that slides in from the right. Consider: the trigger button, the overlay, the menu content, and how items stagger in.","title":"Plan Motion"},{"location":"bundles/design-intelligence.html#create-responsive-strategy","text":"I have a data table that works on desktop but breaks on mobile. The table has 8 columns: name, status, date, amount, category, assignee, priority, and actions. Help me plan the responsive approach.","title":"Create Responsive Strategy"},{"location":"bundles/design-intelligence.html#write-error-messages","text":"Create a set of error messages for a payment form. Cover: invalid card number, expired card, insufficient funds, network error, and general processing failure.","title":"Write Error Messages"},{"location":"bundles/design-intelligence.html#agent-collaboration","text":"Design Intelligence agents work together through orchestration. Common collaboration patterns: Art Director + Design System Architect : Art director sets direction, architect implements as tokens. Component Designer + Animation Choreographer : Designer creates static component, choreographer adds motion. Layout Architect + Responsive Strategist : Layout architect designs desktop, strategist adapts for all devices. Voice Strategist + Component Designer : Voice strategist writes copy, designer integrates into component specs.","title":"Agent Collaboration"},{"location":"bundles/design-intelligence.html#configuration","text":"The Design Intelligence bundle is included in Amplifier Foundation. Enable it in your bundle configuration: # .amplifier/config.yaml bundles : - foundation - design-intelligence Individual agents can be invoked directly or through the main assistant which will delegate to the appropriate specialist based on your request.","title":"Configuration"},{"location":"bundles/design-intelligence.html#quality-baseline","text":"All Design Intelligence agents work toward a 9.5/10 quality baseline. This means: No placeholder or generic solutions Every decision justified against the Nine Dimensions Accessibility considered by default Edge cases and states addressed Implementation guidance included When you receive design recommendations, you're getting production-ready guidance, not rough sketches.","title":"Quality Baseline"},{"location":"bundles/design-intelligence.html#related-resources","text":"Amplifier Foundation Bundle - Core development agents Advanced Topics - Custom bundles and tools Bundles Guide - How bundles work together","title":"Related Resources"},{"location":"bundles/foundation.html","text":"Foundation Bundle \u00b6 Overview \u00b6 The Foundation Bundle is the default bundle that ships with Amplifier, providing essential tools and agents for general-purpose software development workflows. It forms the backbone of most development tasks, offering file operations, code search, shell access, web research capabilities, and a suite of specialized agents for common development patterns. Key Characteristics: - Universal Coverage : Handles 80% of common development tasks - Production-Ready : Battle-tested tools with robust error handling - Zero Configuration : Works out of the box with sensible defaults - Extensible : Serves as a foundation for specialized bundles The Foundation Bundle is automatically loaded when Amplifier starts, making its tools and agents immediately available without additional configuration. Tools Included \u00b6 Tool Purpose Key Use Cases bash Shell command execution Running builds, tests, package managers, git operations read_file Read files and directories Inspecting code, configuration files, documentation write_file Create/overwrite files Writing new code, generating configs, creating documentation edit_file Precise string replacements Modifying existing code, refactoring, bug fixes grep Content search with regex Finding function definitions, locating imports, tracking usage glob File pattern matching Discovering project structure, finding files by type task Launch specialized agents Delegating complex multi-step workflows to sub-agents load_skill Access domain knowledge Loading best practices, coding standards, design patterns python_check Python code quality Linting, formatting, type checking Python code recipes Execute workflows Running multi-stage automated processes todo Task tracking Managing complex multi-step work Tool Details \u00b6 Filesystem Tools \u00b6 The read_file , write_file , and edit_file tools provide comprehensive file manipulation: - Support for absolute and relative paths - Bundle resource access via @bundle:path syntax - Automatic backup before destructive operations - Line-based reading for large files with offset/limit parameters Search Tools \u00b6 grep and glob enable fast codebase navigation: - grep : Regex-based content search with ripgrep performance - glob : Fast file pattern matching with ignore rules - Both exclude common directories (node_modules, .venv, .git) by default - Pagination support for large result sets Shell Access \u00b6 The bash tool provides controlled shell access: - Safe execution with destructive command blocking - Background process support for dev servers - Output truncation to prevent context overflow - Proper handling of exit codes and errors Agents Included \u00b6 Agent Purpose When to Use explorer Codebase reconnaissance Understanding unfamiliar projects, mapping dependencies zen-architect Design and architecture Planning major features, refactoring, system design modular-builder Implementation Building features, writing tests, creating modules bug-hunter Debugging and diagnosis Investigating failures, tracing errors, fixing bugs git-ops Git operations Branch management, commits, PR workflows file-ops Bulk file operations Renaming, moving, restructuring multiple files ecosystem-expert Technology guidance Learning APIs, frameworks, best practices integration-specialist System integration Connecting services, APIs, third-party tools security-guardian Security analysis Reviewing code for vulnerabilities, security best practices test-coverage Test strategy Analyzing coverage, writing tests, test planning web-research Internet research Finding documentation, examples, solutions post-task-cleanup Code cleanup Organizing imports, removing dead code, formatting session-analyst Workflow analysis Understanding conversation history, extracting insights Agent Details \u00b6 explorer \u00b6 Capabilities: - Analyzes project structure and technology stack - Maps dependencies and relationships - Identifies entry points and core modules - Generates architecture summaries Best For: - First-time project exploration - Onboarding to unfamiliar codebases - Pre-implementation reconnaissance zen-architect \u00b6 Capabilities: - Designs system architecture and component boundaries - Plans implementation strategies - Creates technical specifications - Evaluates design tradeoffs Best For: - Major feature planning - Refactoring large systems - API design - Database schema design modular-builder \u00b6 Capabilities: - Implements features following best practices - Creates modular, testable code - Writes comprehensive tests - Documents public APIs Best For: - Feature implementation - Module creation - Test development - Code generation bug-hunter \u00b6 Capabilities: - Investigates test failures and runtime errors - Traces execution paths - Identifies root causes - Proposes and implements fixes Best For: - Debugging failing tests - Investigating production issues - Performance problems - Unexpected behavior git-ops \u00b6 Capabilities: - Manages branches and commits - Handles merge conflicts - Creates pull requests - Reviews git history Best For: - Branch operations - Commit management - Git workflow automation - History analysis Getting Started \u00b6 Basic Usage \u00b6 The Foundation Bundle is active by default. Simply start using Amplifier and all Foundation tools and agents are immediately available. Example 1: Reading and Editing Code You: \"Find all TODO comments in the src/ directory\" Amplifier: [Uses grep tool to search for TODO patterns] You: \"Update the authentication logic in auth.py\" Amplifier: [Uses read_file to inspect, then edit_file to modify] Example 2: Delegating to Agents You: \"I need to understand this legacy codebase\" Amplifier: [Launches explorer agent to analyze structure] You: \"Design a new caching layer for this system\" Amplifier: [Launches zen-architect to create design] You: \"Now implement that design\" Amplifier: [Launches modular-builder to write code] Agent Workflows \u00b6 Agents can be chained for complex workflows: Full Feature Development: explorer \u2192 Understand existing code zen-architect \u2192 Design the feature modular-builder \u2192 Implement with tests git-ops \u2192 Commit and create PR Bug Investigation and Fix: bug-hunter \u2192 Diagnose the issue modular-builder \u2192 Implement fix test-coverage \u2192 Add regression tests git-ops \u2192 Create fix PR Code Quality Improvement: session-analyst \u2192 Review recent changes security-guardian \u2192 Check for vulnerabilities post-task-cleanup \u2192 Clean up code test-coverage \u2192 Ensure adequate testing Configuration \u00b6 The Foundation Bundle works with zero configuration, but can be customized via .amplifier/config.yaml : bundles : foundation : enabled : true agents : # Customize agent behavior explorer : max_depth : 5 bug-hunter : auto_fix : false When to Use \u00b6 Perfect For: \u00b6 \u2705 General software development - Most common programming tasks \u2705 Project exploration - Understanding new codebases \u2705 Feature implementation - Building new functionality \u2705 Bug fixing - Debugging and resolving issues \u2705 Code refactoring - Improving code structure \u2705 Git workflows - Managing version control \u2705 Test development - Writing and maintaining tests \u2705 Documentation - Creating and updating docs Consider Specialized Bundles For: \u00b6 \ud83d\udd27 Python development - Use python-dev bundle for enhanced Python tools \ud83c\udfa8 Design work - Use design-intelligence bundle for UI/UX \u2699\ufe0f DevOps tasks - Use infrastructure-specific bundles \ud83d\udcca Data science - Use data-analysis bundles Complementary Bundles \u00b6 The Foundation Bundle works well alongside: - python-dev : Adds Python-specific linting, type checking, testing tools - design-intelligence : Adds UI/UX design agents and tools - recipes : Adds workflow automation and multi-stage processes Multiple bundles can be loaded simultaneously, with their tools and agents available together. Best Practices \u00b6 Tool Selection \u00b6 Use specialized tools first: - Prefer read_file over bash cat for reading files - Use grep instead of bash grep for searching - Use glob for file discovery before manual searching Delegate complex tasks: - Launch agents for multi-step workflows - Use task tool when work requires multiple operations - Let agents operate autonomously instead of micromanaging Agent Usage \u00b6 Choose the right agent: - explorer for understanding, not building - zen-architect for design, not implementation - modular-builder for implementation, not debugging - bug-hunter for diagnosis and fixes Provide clear instructions: Good: \"Use bug-hunter to investigate why test_auth.py::test_login fails\" Bad: \"Fix the tests\" Workflow Patterns \u00b6 1. Exploration First Before major changes, understand the codebase: explorer \u2192 zen-architect \u2192 modular-builder 2. Test-Driven Development Write tests before implementation: zen-architect \u2192 test-coverage \u2192 modular-builder 3. Iterative Refinement Build, test, improve: modular-builder \u2192 test-coverage \u2192 post-task-cleanup Common Patterns \u00b6 Pattern: Safe Refactoring \u00b6 Search - Find all usages with grep Analyze - Review with explorer or session-analyst Plan - Design changes with zen-architect Execute - Implement with modular-builder Verify - Test with test-coverage Commit - Save with git-ops Pattern: New Feature Development \u00b6 Explore - Use explorer to understand integration points Design - Use zen-architect to plan architecture Build - Use modular-builder to implement Test - Use test-coverage to ensure quality Document - Update docs with write_file Review - Use security-guardian for security check Ship - Create PR with git-ops Pattern: Bug Fix Workflow \u00b6 Reproduce - Verify the issue with bash to run tests Investigate - Use bug-hunter to diagnose Fix - Implement solution (often done by bug-hunter ) Test - Add regression test Commit - Save fix with descriptive message Try It Yourself \u00b6 Exercise 1: Project Exploration \u00b6 Try exploring a new project: 1. Launch explorer agent to analyze project structure 2. Use grep to find all exported functions 3. Use glob to list all test files 4. Read package.json or requirements.txt to understand dependencies Exercise 2: Feature Implementation \u00b6 Build a simple feature: 1. Use zen-architect to design a new utility function 2. Launch modular-builder to implement it 3. Use test-coverage to ensure it's tested 4. Use post-task-cleanup to format code 5. Use git-ops to commit changes Exercise 3: Bug Hunt \u00b6 Practice debugging: 1. Run tests with bash to identify failures 2. Launch bug-hunter to investigate 3. Review the proposed fix 4. Run tests again to verify 5. Commit the fix Exercise 4: Search and Replace \u00b6 Try refactoring: 1. Use grep to find all occurrences of a function name 2. Use read_file to inspect each usage 3. Use edit_file to update the function signature 4. Use bash to run tests 5. Use post-task-cleanup to organize imports Advanced Usage \u00b6 Multi-Agent Workflows \u00b6 Launch multiple agents in parallel for complex tasks: You: \"Audit this codebase for quality and security\" Amplifier: [Launches security-guardian and test-coverage simultaneously] Custom Agent Instructions \u00b6 Provide detailed context for better results: You: \"Use explorer to map the authentication flow, focusing on JWT token validation and refresh logic. Document the security boundaries.\" Combining Tools and Agents \u00b6 Mix direct tool usage with agent delegation: 1. Use glob to find all API route files 2. Launch explorer to analyze each route 3. Use zen-architect to design improvements 4. Implement changes yourself with edit_file Integration \u00b6 With Other Bundles \u00b6 Foundation provides the base layer for specialized bundles: - python-dev extends Foundation with Python-specific tools - design-intelligence adds design agents while using Foundation's filesystem tools - Custom bundles can leverage Foundation's agents in their workflows With Recipes \u00b6 Foundation agents are frequently used in recipes: stages : - name : analyze agent : foundation:explorer instruction : \"Analyze project structure\" - name : design agent : foundation:zen-architect instruction : \"Design new feature based on analysis\" - name : implement agent : foundation:modular-builder instruction : \"Implement the designed feature\" Troubleshooting \u00b6 Common Issues \u00b6 Agent not responding or slow: - Check if task is too broad - provide more specific instructions - Review agent's tool access - ensure needed tools are available Search returning too many results: - Use more specific regex patterns with grep - Add file type filters with glob - Use head_limit parameter to paginate File operations failing: - Verify file paths are correct - Check file permissions - Ensure files exist before editing Getting Help \u00b6 Use load_skill to access domain-specific knowledge Launch ecosystem-expert for technology questions Use web-research agent for finding documentation What's Next? \u00b6 Explore LSP Python Bundle for enhanced Python tools Learn about Design Intelligence Bundle for UI/UX work Check out Recipes Bundle for workflow automation Read Advanced Topics for complex patterns The Foundation Bundle provides everything you need for general-purpose development. Master these tools and agents, and you'll be productive in any programming environment.","title":"Foundation"},{"location":"bundles/foundation.html#foundation-bundle","text":"","title":"Foundation Bundle"},{"location":"bundles/foundation.html#overview","text":"The Foundation Bundle is the default bundle that ships with Amplifier, providing essential tools and agents for general-purpose software development workflows. It forms the backbone of most development tasks, offering file operations, code search, shell access, web research capabilities, and a suite of specialized agents for common development patterns. Key Characteristics: - Universal Coverage : Handles 80% of common development tasks - Production-Ready : Battle-tested tools with robust error handling - Zero Configuration : Works out of the box with sensible defaults - Extensible : Serves as a foundation for specialized bundles The Foundation Bundle is automatically loaded when Amplifier starts, making its tools and agents immediately available without additional configuration.","title":"Overview"},{"location":"bundles/foundation.html#tools-included","text":"Tool Purpose Key Use Cases bash Shell command execution Running builds, tests, package managers, git operations read_file Read files and directories Inspecting code, configuration files, documentation write_file Create/overwrite files Writing new code, generating configs, creating documentation edit_file Precise string replacements Modifying existing code, refactoring, bug fixes grep Content search with regex Finding function definitions, locating imports, tracking usage glob File pattern matching Discovering project structure, finding files by type task Launch specialized agents Delegating complex multi-step workflows to sub-agents load_skill Access domain knowledge Loading best practices, coding standards, design patterns python_check Python code quality Linting, formatting, type checking Python code recipes Execute workflows Running multi-stage automated processes todo Task tracking Managing complex multi-step work","title":"Tools Included"},{"location":"bundles/foundation.html#tool-details","text":"","title":"Tool Details"},{"location":"bundles/foundation.html#filesystem-tools","text":"The read_file , write_file , and edit_file tools provide comprehensive file manipulation: - Support for absolute and relative paths - Bundle resource access via @bundle:path syntax - Automatic backup before destructive operations - Line-based reading for large files with offset/limit parameters","title":"Filesystem Tools"},{"location":"bundles/foundation.html#search-tools","text":"grep and glob enable fast codebase navigation: - grep : Regex-based content search with ripgrep performance - glob : Fast file pattern matching with ignore rules - Both exclude common directories (node_modules, .venv, .git) by default - Pagination support for large result sets","title":"Search Tools"},{"location":"bundles/foundation.html#shell-access","text":"The bash tool provides controlled shell access: - Safe execution with destructive command blocking - Background process support for dev servers - Output truncation to prevent context overflow - Proper handling of exit codes and errors","title":"Shell Access"},{"location":"bundles/foundation.html#agents-included","text":"Agent Purpose When to Use explorer Codebase reconnaissance Understanding unfamiliar projects, mapping dependencies zen-architect Design and architecture Planning major features, refactoring, system design modular-builder Implementation Building features, writing tests, creating modules bug-hunter Debugging and diagnosis Investigating failures, tracing errors, fixing bugs git-ops Git operations Branch management, commits, PR workflows file-ops Bulk file operations Renaming, moving, restructuring multiple files ecosystem-expert Technology guidance Learning APIs, frameworks, best practices integration-specialist System integration Connecting services, APIs, third-party tools security-guardian Security analysis Reviewing code for vulnerabilities, security best practices test-coverage Test strategy Analyzing coverage, writing tests, test planning web-research Internet research Finding documentation, examples, solutions post-task-cleanup Code cleanup Organizing imports, removing dead code, formatting session-analyst Workflow analysis Understanding conversation history, extracting insights","title":"Agents Included"},{"location":"bundles/foundation.html#agent-details","text":"","title":"Agent Details"},{"location":"bundles/foundation.html#explorer","text":"Capabilities: - Analyzes project structure and technology stack - Maps dependencies and relationships - Identifies entry points and core modules - Generates architecture summaries Best For: - First-time project exploration - Onboarding to unfamiliar codebases - Pre-implementation reconnaissance","title":"explorer"},{"location":"bundles/foundation.html#zen-architect","text":"Capabilities: - Designs system architecture and component boundaries - Plans implementation strategies - Creates technical specifications - Evaluates design tradeoffs Best For: - Major feature planning - Refactoring large systems - API design - Database schema design","title":"zen-architect"},{"location":"bundles/foundation.html#modular-builder","text":"Capabilities: - Implements features following best practices - Creates modular, testable code - Writes comprehensive tests - Documents public APIs Best For: - Feature implementation - Module creation - Test development - Code generation","title":"modular-builder"},{"location":"bundles/foundation.html#bug-hunter","text":"Capabilities: - Investigates test failures and runtime errors - Traces execution paths - Identifies root causes - Proposes and implements fixes Best For: - Debugging failing tests - Investigating production issues - Performance problems - Unexpected behavior","title":"bug-hunter"},{"location":"bundles/foundation.html#git-ops","text":"Capabilities: - Manages branches and commits - Handles merge conflicts - Creates pull requests - Reviews git history Best For: - Branch operations - Commit management - Git workflow automation - History analysis","title":"git-ops"},{"location":"bundles/foundation.html#getting-started","text":"","title":"Getting Started"},{"location":"bundles/foundation.html#basic-usage","text":"The Foundation Bundle is active by default. Simply start using Amplifier and all Foundation tools and agents are immediately available. Example 1: Reading and Editing Code You: \"Find all TODO comments in the src/ directory\" Amplifier: [Uses grep tool to search for TODO patterns] You: \"Update the authentication logic in auth.py\" Amplifier: [Uses read_file to inspect, then edit_file to modify] Example 2: Delegating to Agents You: \"I need to understand this legacy codebase\" Amplifier: [Launches explorer agent to analyze structure] You: \"Design a new caching layer for this system\" Amplifier: [Launches zen-architect to create design] You: \"Now implement that design\" Amplifier: [Launches modular-builder to write code]","title":"Basic Usage"},{"location":"bundles/foundation.html#agent-workflows","text":"Agents can be chained for complex workflows: Full Feature Development: explorer \u2192 Understand existing code zen-architect \u2192 Design the feature modular-builder \u2192 Implement with tests git-ops \u2192 Commit and create PR Bug Investigation and Fix: bug-hunter \u2192 Diagnose the issue modular-builder \u2192 Implement fix test-coverage \u2192 Add regression tests git-ops \u2192 Create fix PR Code Quality Improvement: session-analyst \u2192 Review recent changes security-guardian \u2192 Check for vulnerabilities post-task-cleanup \u2192 Clean up code test-coverage \u2192 Ensure adequate testing","title":"Agent Workflows"},{"location":"bundles/foundation.html#configuration","text":"The Foundation Bundle works with zero configuration, but can be customized via .amplifier/config.yaml : bundles : foundation : enabled : true agents : # Customize agent behavior explorer : max_depth : 5 bug-hunter : auto_fix : false","title":"Configuration"},{"location":"bundles/foundation.html#when-to-use","text":"","title":"When to Use"},{"location":"bundles/foundation.html#perfect-for","text":"\u2705 General software development - Most common programming tasks \u2705 Project exploration - Understanding new codebases \u2705 Feature implementation - Building new functionality \u2705 Bug fixing - Debugging and resolving issues \u2705 Code refactoring - Improving code structure \u2705 Git workflows - Managing version control \u2705 Test development - Writing and maintaining tests \u2705 Documentation - Creating and updating docs","title":"Perfect For:"},{"location":"bundles/foundation.html#consider-specialized-bundles-for","text":"\ud83d\udd27 Python development - Use python-dev bundle for enhanced Python tools \ud83c\udfa8 Design work - Use design-intelligence bundle for UI/UX \u2699\ufe0f DevOps tasks - Use infrastructure-specific bundles \ud83d\udcca Data science - Use data-analysis bundles","title":"Consider Specialized Bundles For:"},{"location":"bundles/foundation.html#complementary-bundles","text":"The Foundation Bundle works well alongside: - python-dev : Adds Python-specific linting, type checking, testing tools - design-intelligence : Adds UI/UX design agents and tools - recipes : Adds workflow automation and multi-stage processes Multiple bundles can be loaded simultaneously, with their tools and agents available together.","title":"Complementary Bundles"},{"location":"bundles/foundation.html#best-practices","text":"","title":"Best Practices"},{"location":"bundles/foundation.html#tool-selection","text":"Use specialized tools first: - Prefer read_file over bash cat for reading files - Use grep instead of bash grep for searching - Use glob for file discovery before manual searching Delegate complex tasks: - Launch agents for multi-step workflows - Use task tool when work requires multiple operations - Let agents operate autonomously instead of micromanaging","title":"Tool Selection"},{"location":"bundles/foundation.html#agent-usage","text":"Choose the right agent: - explorer for understanding, not building - zen-architect for design, not implementation - modular-builder for implementation, not debugging - bug-hunter for diagnosis and fixes Provide clear instructions: Good: \"Use bug-hunter to investigate why test_auth.py::test_login fails\" Bad: \"Fix the tests\"","title":"Agent Usage"},{"location":"bundles/foundation.html#workflow-patterns","text":"1. Exploration First Before major changes, understand the codebase: explorer \u2192 zen-architect \u2192 modular-builder 2. Test-Driven Development Write tests before implementation: zen-architect \u2192 test-coverage \u2192 modular-builder 3. Iterative Refinement Build, test, improve: modular-builder \u2192 test-coverage \u2192 post-task-cleanup","title":"Workflow Patterns"},{"location":"bundles/foundation.html#common-patterns","text":"","title":"Common Patterns"},{"location":"bundles/foundation.html#pattern-safe-refactoring","text":"Search - Find all usages with grep Analyze - Review with explorer or session-analyst Plan - Design changes with zen-architect Execute - Implement with modular-builder Verify - Test with test-coverage Commit - Save with git-ops","title":"Pattern: Safe Refactoring"},{"location":"bundles/foundation.html#pattern-new-feature-development","text":"Explore - Use explorer to understand integration points Design - Use zen-architect to plan architecture Build - Use modular-builder to implement Test - Use test-coverage to ensure quality Document - Update docs with write_file Review - Use security-guardian for security check Ship - Create PR with git-ops","title":"Pattern: New Feature Development"},{"location":"bundles/foundation.html#pattern-bug-fix-workflow","text":"Reproduce - Verify the issue with bash to run tests Investigate - Use bug-hunter to diagnose Fix - Implement solution (often done by bug-hunter ) Test - Add regression test Commit - Save fix with descriptive message","title":"Pattern: Bug Fix Workflow"},{"location":"bundles/foundation.html#try-it-yourself","text":"","title":"Try It Yourself"},{"location":"bundles/foundation.html#exercise-1-project-exploration","text":"Try exploring a new project: 1. Launch explorer agent to analyze project structure 2. Use grep to find all exported functions 3. Use glob to list all test files 4. Read package.json or requirements.txt to understand dependencies","title":"Exercise 1: Project Exploration"},{"location":"bundles/foundation.html#exercise-2-feature-implementation","text":"Build a simple feature: 1. Use zen-architect to design a new utility function 2. Launch modular-builder to implement it 3. Use test-coverage to ensure it's tested 4. Use post-task-cleanup to format code 5. Use git-ops to commit changes","title":"Exercise 2: Feature Implementation"},{"location":"bundles/foundation.html#exercise-3-bug-hunt","text":"Practice debugging: 1. Run tests with bash to identify failures 2. Launch bug-hunter to investigate 3. Review the proposed fix 4. Run tests again to verify 5. Commit the fix","title":"Exercise 3: Bug Hunt"},{"location":"bundles/foundation.html#exercise-4-search-and-replace","text":"Try refactoring: 1. Use grep to find all occurrences of a function name 2. Use read_file to inspect each usage 3. Use edit_file to update the function signature 4. Use bash to run tests 5. Use post-task-cleanup to organize imports","title":"Exercise 4: Search and Replace"},{"location":"bundles/foundation.html#advanced-usage","text":"","title":"Advanced Usage"},{"location":"bundles/foundation.html#multi-agent-workflows","text":"Launch multiple agents in parallel for complex tasks: You: \"Audit this codebase for quality and security\" Amplifier: [Launches security-guardian and test-coverage simultaneously]","title":"Multi-Agent Workflows"},{"location":"bundles/foundation.html#custom-agent-instructions","text":"Provide detailed context for better results: You: \"Use explorer to map the authentication flow, focusing on JWT token validation and refresh logic. Document the security boundaries.\"","title":"Custom Agent Instructions"},{"location":"bundles/foundation.html#combining-tools-and-agents","text":"Mix direct tool usage with agent delegation: 1. Use glob to find all API route files 2. Launch explorer to analyze each route 3. Use zen-architect to design improvements 4. Implement changes yourself with edit_file","title":"Combining Tools and Agents"},{"location":"bundles/foundation.html#integration","text":"","title":"Integration"},{"location":"bundles/foundation.html#with-other-bundles","text":"Foundation provides the base layer for specialized bundles: - python-dev extends Foundation with Python-specific tools - design-intelligence adds design agents while using Foundation's filesystem tools - Custom bundles can leverage Foundation's agents in their workflows","title":"With Other Bundles"},{"location":"bundles/foundation.html#with-recipes","text":"Foundation agents are frequently used in recipes: stages : - name : analyze agent : foundation:explorer instruction : \"Analyze project structure\" - name : design agent : foundation:zen-architect instruction : \"Design new feature based on analysis\" - name : implement agent : foundation:modular-builder instruction : \"Implement the designed feature\"","title":"With Recipes"},{"location":"bundles/foundation.html#troubleshooting","text":"","title":"Troubleshooting"},{"location":"bundles/foundation.html#common-issues","text":"Agent not responding or slow: - Check if task is too broad - provide more specific instructions - Review agent's tool access - ensure needed tools are available Search returning too many results: - Use more specific regex patterns with grep - Add file type filters with glob - Use head_limit parameter to paginate File operations failing: - Verify file paths are correct - Check file permissions - Ensure files exist before editing","title":"Common Issues"},{"location":"bundles/foundation.html#getting-help","text":"Use load_skill to access domain-specific knowledge Launch ecosystem-expert for technology questions Use web-research agent for finding documentation","title":"Getting Help"},{"location":"bundles/foundation.html#whats-next","text":"Explore LSP Python Bundle for enhanced Python tools Learn about Design Intelligence Bundle for UI/UX work Check out Recipes Bundle for workflow automation Read Advanced Topics for complex patterns The Foundation Bundle provides everything you need for general-purpose development. Master these tools and agents, and you'll be productive in any programming environment.","title":"What's Next?"},{"location":"bundles/lsp-python.html","text":"LSP Python Bundle \u00b6 Overview \u00b6 The LSP Python bundle provides semantic code intelligence for Python codebases using the Language Server Protocol (LSP) powered by Pyright. Unlike text-based search tools like grep, LSP understands your code's actual structure\u2014types, references, call hierarchies, and more. This bundle transforms how you navigate and understand Python code by providing: Precise symbol lookup : Find exact definitions, not text matches Semantic references : Find actual usages, excluding comments and strings Type inference : Get types even without explicit annotations Call hierarchy : Trace what calls a function and what it calls What's Included \u00b6 LSP Tool (Pyright) \u00b6 The bundle configures and provides access to Pyright, Microsoft's static type checker for Python, as an LSP server. This gives you access to powerful code intelligence operations: Operation Description goToDefinition Jump to where a symbol is defined findReferences Find all usages of a symbol hover Get type information and documentation documentSymbol List all symbols in a file workspaceSymbol Search for symbols across the workspace goToImplementation Find implementations of abstract methods prepareCallHierarchy Prepare call hierarchy for a symbol incomingCalls Find what calls a function outgoingCalls Find what a function calls python-code-intel Agent \u00b6 A specialized agent for complex, multi-step Python code navigation tasks. The agent excels at: Tracing inheritance chains across multiple files Mapping module dependencies Understanding type flows through your codebase Building comprehensive call graphs Debugging type mismatches When to Use \u00b6 Use LSP Python Bundle When \u00b6 Finding where something is defined: \"Where is the Session class defined?\" \u2192 goToDefinition gives exact file:line, not grep's multiple matches Finding all usages of a symbol: \"What uses the authenticate() method?\" \u2192 findReferences returns actual code usages, ignoring comments/strings Getting type information: \"What type does get_connection() return?\" \u2192 hover shows inferred types even without annotations Tracing call relationships: \"What functions call handle_request()?\" \u2192 incomingCalls maps the complete caller graph Understanding complex codebases: \"Map the authentication flow from login to session creation\" \u2192 python-code-intel agent traces multi-step paths Use Grep Instead When \u00b6 Searching for text patterns (log messages, comments, TODOs) Finding configuration values or magic strings Bulk text search across many files Searching non-Python files Quick Decision Guide \u00b6 Task Tool \"Find definition of X\" LSP goToDefinition \"Find all callers of X\" LSP incomingCalls \"Find text 'ERROR' in logs\" grep \"What type is X?\" LSP hover \"Find TODO comments\" grep \"Trace the auth flow\" python-code-intel agent Try It Yourself \u00b6 Basic Operations \u00b6 1. Go to Definition Find where a symbol is defined: LSP operation: goToDefinition file_path: src/auth/login.py line: 42 character: 15 This returns the exact file and line where the symbol at that position is defined. 2. Find References Find all usages of a symbol: LSP operation: findReferences file_path: src/models/user.py line: 10 character: 7 Returns every location where User (or whatever symbol is at that position) is referenced. 3. Hover for Type Info Get type information and docstrings: LSP operation: hover file_path: src/utils/cache.py line: 25 character: 12 Returns the inferred type, function signature, and any docstring. 4. Document Symbols List all symbols in a file: LSP operation: documentSymbol file_path: src/services/payment.py line: 1 character: 1 Returns classes, functions, variables, and their locations in the file. 5. Workspace Symbol Search Search for symbols across the entire workspace: LSP operation: workspaceSymbol query: \"authenticate\" file_path: src/main.py line: 1 character: 1 Finds all symbols matching the query pattern. Call Hierarchy Operations \u00b6 6. Prepare Call Hierarchy Prepare a symbol for call hierarchy analysis: LSP operation: prepareCallHierarchy file_path: src/api/handlers.py line: 55 character: 8 7. Incoming Calls Find what calls a function (callers): LSP operation: incomingCalls file_path: src/api/handlers.py line: 55 character: 8 8. Outgoing Calls Find what a function calls (callees): LSP operation: outgoingCalls file_path: src/api/handlers.py line: 55 character: 8 Using the python-code-intel Agent \u00b6 For complex navigation tasks, delegate to the specialized agent: Example: Tracing a Feature Flow Task: \"Trace how user authentication works from the login endpoint to session creation, including all intermediate function calls\" Agent: python-code-intel The agent will: 1. Find the login endpoint definition 2. Trace outgoing calls to identify authentication logic 3. Follow the call chain to session creation 4. Build a complete map of the flow 5. Return a structured summary with file:line references Example: Finding All Implementations Task: \"Find all classes that implement the PaymentProcessor interface and show their process_payment method signatures\" Agent: python-code-intel The agent will: 1. Locate the PaymentProcessor base class 2. Find all implementations using goToImplementation 3. Extract method signatures using hover 4. Return a comparison of all implementations Example: Debugging Type Issues Task: \"The function get_user_data() is returning the wrong type somewhere. Trace all the places it's called and check the expected vs actual types\" Agent: python-code-intel The agent will: 1. Get the return type of get_user_data() 2. Find all call sites using incomingCalls 3. Check type expectations at each call site 4. Identify type mismatches 5. Report findings with specific locations LSP vs Grep: A Practical Comparison \u00b6 Consider searching for uses of a function called validate : With grep: grep -r \"validate\" src/ Returns: - Actual function calls: validate(data) - Comments: # TODO: validate input - Strings: \"Please validate your email\" - Other functions: validate_email() , revalidate() - Variable names: is_validated = True With LSP findReferences: LSP findReferences on validate function Returns: - Only actual references to that specific function - No false positives from comments or strings - No confusion with similarly-named symbols Configuration \u00b6 The LSP Python bundle requires Pyright to be available. It's typically configured in your bundle composition: # Example bundle including LSP Python extends : - lsp-python # Pyright will use pyrightconfig.json or pyproject.toml # from your project root for configuration Pyright Configuration \u00b6 Create a pyrightconfig.json in your project root for best results: { \"include\" : [ \"src\" ], \"exclude\" : [ \"**/node_modules\" , \"**/__pycache__\" , \".venv\" ], \"venvPath\" : \".\" , \"venv\" : \".venv\" , \"typeCheckingMode\" : \"basic\" } Tips for Effective Use \u00b6 Position matters : LSP operations work on specific positions. Place the cursor on the symbol you want to analyze. Let Pyright index first : Large codebases may need a moment for initial indexing. Use the agent for multi-step tasks : Single operations go direct to LSP; complex traces delegate to python-code-intel. Combine with grep strategically : Use LSP for semantic queries, grep for text patterns. Check virtual environments : Ensure Pyright can find your project's dependencies for accurate type inference. Common Patterns \u00b6 Pattern: Refactoring Impact Analysis \u00b6 Before renaming or modifying a function: 1. Use findReferences to find all usages 2. Use incomingCalls to understand the call graph 3. Use hover at each call site to check type expectations Pattern: Understanding New Codebases \u00b6 When exploring unfamiliar code: 1. Use documentSymbol to see file structure 2. Use workspaceSymbol to find entry points 3. Use outgoingCalls to trace execution flow 4. Delegate complex traces to python-code-intel agent Pattern: Debugging Type Errors \u00b6 When facing type mismatches: 1. Use hover to get inferred types 2. Use goToDefinition to check type definitions 3. Trace the data flow with call hierarchy operations Related Bundles \u00b6 lsp : Base LSP bundle (required dependency) foundation : Core development tools Summary \u00b6 The LSP Python bundle brings IDE-level code intelligence to your Amplifier workflow. By understanding your code semantically rather than as text, it enables precise navigation, accurate refactoring, and deep code understanding\u2014all accessible through simple tool operations or the specialized python-code-intel agent.","title":"LSP Python"},{"location":"bundles/lsp-python.html#lsp-python-bundle","text":"","title":"LSP Python Bundle"},{"location":"bundles/lsp-python.html#overview","text":"The LSP Python bundle provides semantic code intelligence for Python codebases using the Language Server Protocol (LSP) powered by Pyright. Unlike text-based search tools like grep, LSP understands your code's actual structure\u2014types, references, call hierarchies, and more. This bundle transforms how you navigate and understand Python code by providing: Precise symbol lookup : Find exact definitions, not text matches Semantic references : Find actual usages, excluding comments and strings Type inference : Get types even without explicit annotations Call hierarchy : Trace what calls a function and what it calls","title":"Overview"},{"location":"bundles/lsp-python.html#whats-included","text":"","title":"What's Included"},{"location":"bundles/lsp-python.html#lsp-tool-pyright","text":"The bundle configures and provides access to Pyright, Microsoft's static type checker for Python, as an LSP server. This gives you access to powerful code intelligence operations: Operation Description goToDefinition Jump to where a symbol is defined findReferences Find all usages of a symbol hover Get type information and documentation documentSymbol List all symbols in a file workspaceSymbol Search for symbols across the workspace goToImplementation Find implementations of abstract methods prepareCallHierarchy Prepare call hierarchy for a symbol incomingCalls Find what calls a function outgoingCalls Find what a function calls","title":"LSP Tool (Pyright)"},{"location":"bundles/lsp-python.html#python-code-intel-agent","text":"A specialized agent for complex, multi-step Python code navigation tasks. The agent excels at: Tracing inheritance chains across multiple files Mapping module dependencies Understanding type flows through your codebase Building comprehensive call graphs Debugging type mismatches","title":"python-code-intel Agent"},{"location":"bundles/lsp-python.html#when-to-use","text":"","title":"When to Use"},{"location":"bundles/lsp-python.html#use-lsp-python-bundle-when","text":"Finding where something is defined: \"Where is the Session class defined?\" \u2192 goToDefinition gives exact file:line, not grep's multiple matches Finding all usages of a symbol: \"What uses the authenticate() method?\" \u2192 findReferences returns actual code usages, ignoring comments/strings Getting type information: \"What type does get_connection() return?\" \u2192 hover shows inferred types even without annotations Tracing call relationships: \"What functions call handle_request()?\" \u2192 incomingCalls maps the complete caller graph Understanding complex codebases: \"Map the authentication flow from login to session creation\" \u2192 python-code-intel agent traces multi-step paths","title":"Use LSP Python Bundle When"},{"location":"bundles/lsp-python.html#use-grep-instead-when","text":"Searching for text patterns (log messages, comments, TODOs) Finding configuration values or magic strings Bulk text search across many files Searching non-Python files","title":"Use Grep Instead When"},{"location":"bundles/lsp-python.html#quick-decision-guide","text":"Task Tool \"Find definition of X\" LSP goToDefinition \"Find all callers of X\" LSP incomingCalls \"Find text 'ERROR' in logs\" grep \"What type is X?\" LSP hover \"Find TODO comments\" grep \"Trace the auth flow\" python-code-intel agent","title":"Quick Decision Guide"},{"location":"bundles/lsp-python.html#try-it-yourself","text":"","title":"Try It Yourself"},{"location":"bundles/lsp-python.html#basic-operations","text":"1. Go to Definition Find where a symbol is defined: LSP operation: goToDefinition file_path: src/auth/login.py line: 42 character: 15 This returns the exact file and line where the symbol at that position is defined. 2. Find References Find all usages of a symbol: LSP operation: findReferences file_path: src/models/user.py line: 10 character: 7 Returns every location where User (or whatever symbol is at that position) is referenced. 3. Hover for Type Info Get type information and docstrings: LSP operation: hover file_path: src/utils/cache.py line: 25 character: 12 Returns the inferred type, function signature, and any docstring. 4. Document Symbols List all symbols in a file: LSP operation: documentSymbol file_path: src/services/payment.py line: 1 character: 1 Returns classes, functions, variables, and their locations in the file. 5. Workspace Symbol Search Search for symbols across the entire workspace: LSP operation: workspaceSymbol query: \"authenticate\" file_path: src/main.py line: 1 character: 1 Finds all symbols matching the query pattern.","title":"Basic Operations"},{"location":"bundles/lsp-python.html#call-hierarchy-operations","text":"6. Prepare Call Hierarchy Prepare a symbol for call hierarchy analysis: LSP operation: prepareCallHierarchy file_path: src/api/handlers.py line: 55 character: 8 7. Incoming Calls Find what calls a function (callers): LSP operation: incomingCalls file_path: src/api/handlers.py line: 55 character: 8 8. Outgoing Calls Find what a function calls (callees): LSP operation: outgoingCalls file_path: src/api/handlers.py line: 55 character: 8","title":"Call Hierarchy Operations"},{"location":"bundles/lsp-python.html#using-the-python-code-intel-agent","text":"For complex navigation tasks, delegate to the specialized agent: Example: Tracing a Feature Flow Task: \"Trace how user authentication works from the login endpoint to session creation, including all intermediate function calls\" Agent: python-code-intel The agent will: 1. Find the login endpoint definition 2. Trace outgoing calls to identify authentication logic 3. Follow the call chain to session creation 4. Build a complete map of the flow 5. Return a structured summary with file:line references Example: Finding All Implementations Task: \"Find all classes that implement the PaymentProcessor interface and show their process_payment method signatures\" Agent: python-code-intel The agent will: 1. Locate the PaymentProcessor base class 2. Find all implementations using goToImplementation 3. Extract method signatures using hover 4. Return a comparison of all implementations Example: Debugging Type Issues Task: \"The function get_user_data() is returning the wrong type somewhere. Trace all the places it's called and check the expected vs actual types\" Agent: python-code-intel The agent will: 1. Get the return type of get_user_data() 2. Find all call sites using incomingCalls 3. Check type expectations at each call site 4. Identify type mismatches 5. Report findings with specific locations","title":"Using the python-code-intel Agent"},{"location":"bundles/lsp-python.html#lsp-vs-grep-a-practical-comparison","text":"Consider searching for uses of a function called validate : With grep: grep -r \"validate\" src/ Returns: - Actual function calls: validate(data) - Comments: # TODO: validate input - Strings: \"Please validate your email\" - Other functions: validate_email() , revalidate() - Variable names: is_validated = True With LSP findReferences: LSP findReferences on validate function Returns: - Only actual references to that specific function - No false positives from comments or strings - No confusion with similarly-named symbols","title":"LSP vs Grep: A Practical Comparison"},{"location":"bundles/lsp-python.html#configuration","text":"The LSP Python bundle requires Pyright to be available. It's typically configured in your bundle composition: # Example bundle including LSP Python extends : - lsp-python # Pyright will use pyrightconfig.json or pyproject.toml # from your project root for configuration","title":"Configuration"},{"location":"bundles/lsp-python.html#pyright-configuration","text":"Create a pyrightconfig.json in your project root for best results: { \"include\" : [ \"src\" ], \"exclude\" : [ \"**/node_modules\" , \"**/__pycache__\" , \".venv\" ], \"venvPath\" : \".\" , \"venv\" : \".venv\" , \"typeCheckingMode\" : \"basic\" }","title":"Pyright Configuration"},{"location":"bundles/lsp-python.html#tips-for-effective-use","text":"Position matters : LSP operations work on specific positions. Place the cursor on the symbol you want to analyze. Let Pyright index first : Large codebases may need a moment for initial indexing. Use the agent for multi-step tasks : Single operations go direct to LSP; complex traces delegate to python-code-intel. Combine with grep strategically : Use LSP for semantic queries, grep for text patterns. Check virtual environments : Ensure Pyright can find your project's dependencies for accurate type inference.","title":"Tips for Effective Use"},{"location":"bundles/lsp-python.html#common-patterns","text":"","title":"Common Patterns"},{"location":"bundles/lsp-python.html#pattern-refactoring-impact-analysis","text":"Before renaming or modifying a function: 1. Use findReferences to find all usages 2. Use incomingCalls to understand the call graph 3. Use hover at each call site to check type expectations","title":"Pattern: Refactoring Impact Analysis"},{"location":"bundles/lsp-python.html#pattern-understanding-new-codebases","text":"When exploring unfamiliar code: 1. Use documentSymbol to see file structure 2. Use workspaceSymbol to find entry points 3. Use outgoingCalls to trace execution flow 4. Delegate complex traces to python-code-intel agent","title":"Pattern: Understanding New Codebases"},{"location":"bundles/lsp-python.html#pattern-debugging-type-errors","text":"When facing type mismatches: 1. Use hover to get inferred types 2. Use goToDefinition to check type definitions 3. Trace the data flow with call hierarchy operations","title":"Pattern: Debugging Type Errors"},{"location":"bundles/lsp-python.html#related-bundles","text":"lsp : Base LSP bundle (required dependency) foundation : Core development tools","title":"Related Bundles"},{"location":"bundles/lsp-python.html#summary","text":"The LSP Python bundle brings IDE-level code intelligence to your Amplifier workflow. By understanding your code semantically rather than as text, it enables precise navigation, accurate refactoring, and deep code understanding\u2014all accessible through simple tool operations or the specialized python-code-intel agent.","title":"Summary"},{"location":"bundles/recipes.html","text":"Recipes Bundle \u00b6 The Recipes Bundle brings declarative workflow orchestration to Amplifier. Define multi-step AI agent workflows in YAML, execute them with automatic checkpointing, and add human-in-the-loop approval gates when needed. Overview \u00b6 Recipes are declarative YAML specifications that define multi-step agent workflows. Instead of manually orchestrating complex tasks through multiple prompts, you define the workflow once and let the recipe engine handle execution, state management, and error recovery. Key Characteristics: Declarative : Define what you want, not how to do it Resumable : Automatic checkpointing means interrupted workflows can continue Composable : Build complex workflows from simpler steps with dependencies Auditable : Full execution history for debugging and compliance Approval Gates : Pause workflows for human review at critical points Recipes solve the coordination problem: orchestrating multiple AI agents across complex, multi-step tasks without manual intervention between each step. What's Included \u00b6 recipes Tool \u00b6 The recipes tool is your interface to the recipe execution engine. Operation Description execute Run a recipe from a YAML file with optional context resume Resume an interrupted session from checkpoint list List all active recipe sessions validate Validate recipe structure without executing approvals List pending approvals across all sessions approve Approve a stage to continue execution deny Deny a stage to halt execution cancel Cancel a running recipe session Basic Usage: # Execute a recipe recipes : operation : execute recipe_path : workflows/code-review.yaml context : file_path : src/auth.py # Resume interrupted session recipes : operation : resume session_id : recipe_20251118_143022_a3f2 recipe-author Agent \u00b6 The recipe-author agent helps you create, validate, and refine recipe YAML specifications through conversation. It understands recipe schema, design patterns, and best practices. Use it to: - Create new recipes from requirements - Validate existing recipe syntax - Refine error handling and retry logic - Add approval gates to workflows - Optimize step dependencies Recipe Structure \u00b6 Flat Recipes \u00b6 Flat recipes execute steps sequentially with explicit dependencies: name : code-review-workflow description : Automated code review pipeline context : file_path : \"\" # Provided at runtime steps : - id : analyze agent : foundation:zen-architect instruction : | Analyze the code structure in {{ file_path }}. Focus on architecture, patterns, and issues. - id : security agent : foundation:security-guardian instruction : Review {{ file_path }} for security vulnerabilities. depends_on : [ analyze ] - id : summarize agent : foundation:zen-architect instruction : | Create summary combining: - Architecture: {{ steps.analyze.output }} - Security: {{ steps.security.output }} depends_on : [ analyze , security ] Staged Recipes \u00b6 Staged recipes group steps into approval stages. Execution pauses at stage boundaries for human approval: name : deploy-pipeline description : Production deployment with approval gates stages : - name : planning steps : - id : analyze-changes agent : foundation:zen-architect instruction : Analyze changes for deployment risks. - id : generate-plan agent : foundation:modular-builder instruction : Generate deployment plan. depends_on : [ analyze-changes ] - name : execution approval_required : true steps : - id : deploy agent : foundation:modular-builder instruction : Execute deployment according to plan. Step Configuration \u00b6 Each step supports these options: steps : - id : unique-step-id # Required: unique identifier agent : bundle:agent-name # Required: agent to invoke instruction : | # Required: task instructions What the agent should do. Can use {{ variable }} interpolation. # Optional configuration depends_on : [ step-id ] # Steps that must complete first timeout : 300 # Timeout in seconds (default: 300) retries : 3 # Number of retry attempts on_error : continue # continue | fail | skip condition : \"{{ prev.success }}\" # Conditional execution Context and Variables \u00b6 Recipes support context variables and step output interpolation: context : project_name : my-app environment : production steps : - id : build agent : foundation:modular-builder instruction : Build {{ project_name }} for {{ environment }}. - id : deploy agent : foundation:modular-builder instruction : | Deploy using build artifacts. Build output: {{ steps.build.output }} depends_on : [ build ] Foreach Loops \u00b6 Process collections with foreach: steps : - id : review-files foreach : \"{{ files }}\" as : current_file agent : foundation:zen-architect instruction : Review {{ current_file }} for code quality. When to Use \u00b6 Good Use Cases \u00b6 \u2705 Multi-agent workflows : Tasks requiring multiple specialized agents working in sequence or parallel \u2705 Approval-gated processes : Workflows requiring human approval at critical points (deployments, data migrations) \u2705 Repeatable processes : Tasks performed regularly with the same structure \u2705 Complex dependencies : Steps with intricate dependencies and conditional execution \u2705 Auditable workflows : When you need full execution history for compliance When Not to Use \u00b6 \u274c Simple one-shot tasks : Single agent can handle it? Invoke directly \u274c Highly dynamic workflows : Next step depends entirely on unpredictable user input \u274c Exploratory work : Don't know the steps upfront? Work interactively first Try It Yourself \u00b6 Example 1: Create and Execute a Simple Recipe \u00b6 Create ~/.amplifier/recipes/analyze-module.yaml : name : analyze-module description : Analyze a Python module for quality and security context : module_path : \"\" steps : - id : structure agent : foundation:explorer instruction : | Map the structure of {{ module_path }}. Identify key classes, functions, and dependencies. - id : quality agent : foundation:zen-architect instruction : | Review code quality in {{ module_path }}. Context: {{ steps.structure.output }} depends_on : [ structure ] - id : security agent : foundation:security-guardian instruction : | Check {{ module_path }} for security issues. Focus on input validation and data handling. depends_on : [ structure ] - id : report agent : foundation:zen-architect instruction : | Create summary report: - Quality: {{ steps.quality.output }} - Security: {{ steps.security.output }} depends_on : [ quality , security ] Execute it: Execute the analyze-module recipe for src/auth/ Example 2: Staged Recipe with Approvals \u00b6 Create ~/.amplifier/recipes/publish-content.yaml : name : publish-content description : Content publication with review gates stages : - name : draft steps : - id : generate agent : foundation:modular-builder instruction : Generate content based on outline. - id : initial-review agent : foundation:zen-architect instruction : Review draft for clarity and structure. depends_on : [ generate ] - name : editorial approval_required : true steps : - id : fact-check agent : foundation:web-research instruction : Verify facts and claims in content. - id : style-edit agent : foundation:zen-architect instruction : Apply style guide and polish prose. - name : publish approval_required : true steps : - id : final-publish agent : foundation:modular-builder instruction : Publish to production. Example 3: Using the recipe-author Agent \u00b6 Help me create a recipe for automated PR review that: 1. Analyzes code changes 2. Runs security checks 3. Validates test coverage 4. Requires approval before posting comments The recipe-author agent will guide you through the design, asking clarifying questions and generating valid YAML. Example 4: Managing Recipe Sessions \u00b6 # List active sessions List my active recipe sessions # Check pending approvals Show pending recipe approvals # Approve a stage Approve the validation stage for session recipe_20251118_143022 # Resume interrupted session Resume recipe session recipe_20251118_143022 Best Practices \u00b6 Start simple : Begin with flat recipes, add stages when you need approval gates Use meaningful IDs : Step IDs appear in logs and error messages Handle errors explicitly : Set on_error behavior based on criticality Test with validate : Always validate before executing new recipes Version your recipes : Store recipes in version control alongside code Keep steps focused : Each step should do one thing well Use context for configuration : Parameterize via context, don't hardcode Troubleshooting \u00b6 Recipe won't execute : Run validate first to check for syntax errors Step times out : Increase timeout value or break into smaller pieces Can't resume session : Use list to verify session ID exists and isn't completed Approval not working : Ensure approval_required: true is on the stage, not the step Related Bundles \u00b6 foundation : Provides agents commonly used in recipe steps amplifier : Core agent orchestration that recipes build upon Summary \u00b6 The Recipes Bundle transforms complex multi-agent workflows into maintainable, repeatable, auditable processes. Define your workflow once in YAML, execute it reliably, and add human oversight where needed through approval gates.","title":"Recipes"},{"location":"bundles/recipes.html#recipes-bundle","text":"The Recipes Bundle brings declarative workflow orchestration to Amplifier. Define multi-step AI agent workflows in YAML, execute them with automatic checkpointing, and add human-in-the-loop approval gates when needed.","title":"Recipes Bundle"},{"location":"bundles/recipes.html#overview","text":"Recipes are declarative YAML specifications that define multi-step agent workflows. Instead of manually orchestrating complex tasks through multiple prompts, you define the workflow once and let the recipe engine handle execution, state management, and error recovery. Key Characteristics: Declarative : Define what you want, not how to do it Resumable : Automatic checkpointing means interrupted workflows can continue Composable : Build complex workflows from simpler steps with dependencies Auditable : Full execution history for debugging and compliance Approval Gates : Pause workflows for human review at critical points Recipes solve the coordination problem: orchestrating multiple AI agents across complex, multi-step tasks without manual intervention between each step.","title":"Overview"},{"location":"bundles/recipes.html#whats-included","text":"","title":"What's Included"},{"location":"bundles/recipes.html#recipes-tool","text":"The recipes tool is your interface to the recipe execution engine. Operation Description execute Run a recipe from a YAML file with optional context resume Resume an interrupted session from checkpoint list List all active recipe sessions validate Validate recipe structure without executing approvals List pending approvals across all sessions approve Approve a stage to continue execution deny Deny a stage to halt execution cancel Cancel a running recipe session Basic Usage: # Execute a recipe recipes : operation : execute recipe_path : workflows/code-review.yaml context : file_path : src/auth.py # Resume interrupted session recipes : operation : resume session_id : recipe_20251118_143022_a3f2","title":"recipes Tool"},{"location":"bundles/recipes.html#recipe-author-agent","text":"The recipe-author agent helps you create, validate, and refine recipe YAML specifications through conversation. It understands recipe schema, design patterns, and best practices. Use it to: - Create new recipes from requirements - Validate existing recipe syntax - Refine error handling and retry logic - Add approval gates to workflows - Optimize step dependencies","title":"recipe-author Agent"},{"location":"bundles/recipes.html#recipe-structure","text":"","title":"Recipe Structure"},{"location":"bundles/recipes.html#flat-recipes","text":"Flat recipes execute steps sequentially with explicit dependencies: name : code-review-workflow description : Automated code review pipeline context : file_path : \"\" # Provided at runtime steps : - id : analyze agent : foundation:zen-architect instruction : | Analyze the code structure in {{ file_path }}. Focus on architecture, patterns, and issues. - id : security agent : foundation:security-guardian instruction : Review {{ file_path }} for security vulnerabilities. depends_on : [ analyze ] - id : summarize agent : foundation:zen-architect instruction : | Create summary combining: - Architecture: {{ steps.analyze.output }} - Security: {{ steps.security.output }} depends_on : [ analyze , security ]","title":"Flat Recipes"},{"location":"bundles/recipes.html#staged-recipes","text":"Staged recipes group steps into approval stages. Execution pauses at stage boundaries for human approval: name : deploy-pipeline description : Production deployment with approval gates stages : - name : planning steps : - id : analyze-changes agent : foundation:zen-architect instruction : Analyze changes for deployment risks. - id : generate-plan agent : foundation:modular-builder instruction : Generate deployment plan. depends_on : [ analyze-changes ] - name : execution approval_required : true steps : - id : deploy agent : foundation:modular-builder instruction : Execute deployment according to plan.","title":"Staged Recipes"},{"location":"bundles/recipes.html#step-configuration","text":"Each step supports these options: steps : - id : unique-step-id # Required: unique identifier agent : bundle:agent-name # Required: agent to invoke instruction : | # Required: task instructions What the agent should do. Can use {{ variable }} interpolation. # Optional configuration depends_on : [ step-id ] # Steps that must complete first timeout : 300 # Timeout in seconds (default: 300) retries : 3 # Number of retry attempts on_error : continue # continue | fail | skip condition : \"{{ prev.success }}\" # Conditional execution","title":"Step Configuration"},{"location":"bundles/recipes.html#context-and-variables","text":"Recipes support context variables and step output interpolation: context : project_name : my-app environment : production steps : - id : build agent : foundation:modular-builder instruction : Build {{ project_name }} for {{ environment }}. - id : deploy agent : foundation:modular-builder instruction : | Deploy using build artifacts. Build output: {{ steps.build.output }} depends_on : [ build ]","title":"Context and Variables"},{"location":"bundles/recipes.html#foreach-loops","text":"Process collections with foreach: steps : - id : review-files foreach : \"{{ files }}\" as : current_file agent : foundation:zen-architect instruction : Review {{ current_file }} for code quality.","title":"Foreach Loops"},{"location":"bundles/recipes.html#when-to-use","text":"","title":"When to Use"},{"location":"bundles/recipes.html#good-use-cases","text":"\u2705 Multi-agent workflows : Tasks requiring multiple specialized agents working in sequence or parallel \u2705 Approval-gated processes : Workflows requiring human approval at critical points (deployments, data migrations) \u2705 Repeatable processes : Tasks performed regularly with the same structure \u2705 Complex dependencies : Steps with intricate dependencies and conditional execution \u2705 Auditable workflows : When you need full execution history for compliance","title":"Good Use Cases"},{"location":"bundles/recipes.html#when-not-to-use","text":"\u274c Simple one-shot tasks : Single agent can handle it? Invoke directly \u274c Highly dynamic workflows : Next step depends entirely on unpredictable user input \u274c Exploratory work : Don't know the steps upfront? Work interactively first","title":"When Not to Use"},{"location":"bundles/recipes.html#try-it-yourself","text":"","title":"Try It Yourself"},{"location":"bundles/recipes.html#example-1-create-and-execute-a-simple-recipe","text":"Create ~/.amplifier/recipes/analyze-module.yaml : name : analyze-module description : Analyze a Python module for quality and security context : module_path : \"\" steps : - id : structure agent : foundation:explorer instruction : | Map the structure of {{ module_path }}. Identify key classes, functions, and dependencies. - id : quality agent : foundation:zen-architect instruction : | Review code quality in {{ module_path }}. Context: {{ steps.structure.output }} depends_on : [ structure ] - id : security agent : foundation:security-guardian instruction : | Check {{ module_path }} for security issues. Focus on input validation and data handling. depends_on : [ structure ] - id : report agent : foundation:zen-architect instruction : | Create summary report: - Quality: {{ steps.quality.output }} - Security: {{ steps.security.output }} depends_on : [ quality , security ] Execute it: Execute the analyze-module recipe for src/auth/","title":"Example 1: Create and Execute a Simple Recipe"},{"location":"bundles/recipes.html#example-2-staged-recipe-with-approvals","text":"Create ~/.amplifier/recipes/publish-content.yaml : name : publish-content description : Content publication with review gates stages : - name : draft steps : - id : generate agent : foundation:modular-builder instruction : Generate content based on outline. - id : initial-review agent : foundation:zen-architect instruction : Review draft for clarity and structure. depends_on : [ generate ] - name : editorial approval_required : true steps : - id : fact-check agent : foundation:web-research instruction : Verify facts and claims in content. - id : style-edit agent : foundation:zen-architect instruction : Apply style guide and polish prose. - name : publish approval_required : true steps : - id : final-publish agent : foundation:modular-builder instruction : Publish to production.","title":"Example 2: Staged Recipe with Approvals"},{"location":"bundles/recipes.html#example-3-using-the-recipe-author-agent","text":"Help me create a recipe for automated PR review that: 1. Analyzes code changes 2. Runs security checks 3. Validates test coverage 4. Requires approval before posting comments The recipe-author agent will guide you through the design, asking clarifying questions and generating valid YAML.","title":"Example 3: Using the recipe-author Agent"},{"location":"bundles/recipes.html#example-4-managing-recipe-sessions","text":"# List active sessions List my active recipe sessions # Check pending approvals Show pending recipe approvals # Approve a stage Approve the validation stage for session recipe_20251118_143022 # Resume interrupted session Resume recipe session recipe_20251118_143022","title":"Example 4: Managing Recipe Sessions"},{"location":"bundles/recipes.html#best-practices","text":"Start simple : Begin with flat recipes, add stages when you need approval gates Use meaningful IDs : Step IDs appear in logs and error messages Handle errors explicitly : Set on_error behavior based on criticality Test with validate : Always validate before executing new recipes Version your recipes : Store recipes in version control alongside code Keep steps focused : Each step should do one thing well Use context for configuration : Parameterize via context, don't hardcode","title":"Best Practices"},{"location":"bundles/recipes.html#troubleshooting","text":"Recipe won't execute : Run validate first to check for syntax errors Step times out : Increase timeout value or break into smaller pieces Can't resume session : Use list to verify session ID exists and isn't completed Approval not working : Ensure approval_required: true is on the stage, not the step","title":"Troubleshooting"},{"location":"bundles/recipes.html#related-bundles","text":"foundation : Provides agents commonly used in recipe steps amplifier : Core agent orchestration that recipes build upon","title":"Related Bundles"},{"location":"bundles/recipes.html#summary","text":"The Recipes Bundle transforms complex multi-agent workflows into maintainable, repeatable, auditable processes. Define your workflow once in YAML, execute it reliably, and add human oversight where needed through approval gates.","title":"Summary"},{"location":"concepts/index.html","text":"Core Concepts \u00b6 Understanding Amplifier's architecture and design philosophy is essential for building effective AI-powered applications. These concepts form the mental model you'll use throughout your work. This section explains the foundational ideas, patterns, and principles that make Amplifier work. Section Contents \u00b6 Page Description Agents Autonomous task executors with specific capabilities Bundles Composable packages of behaviors and tools Modules Kernel extension points and contracts Hooks Event-driven extensibility system Skills Domain knowledge packages Recipes Declarative multi-step workflows Architecture System design and philosophy Quick Tips \u00b6 Sessions are stateful - Each conversation maintains history and can be resumed Agents are specialists - Delegate complex tasks to purpose-built agents Bundles compose - Layer multiple bundles to build custom capabilities Modules extend - Add new functionality without modifying the kernel Context is king - What the model sees determines what it can do Key Principles \u00b6 Modular Design \u00b6 Everything in Amplifier is designed to be composed, replaced, and extended. No monoliths. Thin Bundles \u00b6 Bundles should be minimal\u2014just enough to define behavior, composed from reusable parts. Ruthless Simplicity \u00b6 Complexity is the enemy. Every abstraction must justify its existence. Trust in Emergence \u00b6 Complex behaviors emerge from simple, well-defined components working together. Where to Start \u00b6 Understanding architecture? Read Architecture first\u2014understanding the system design is fundamental. Building custom behaviors? Start with Bundles to see how capabilities compose. Extending the system? Modules explains the kernel's extension contracts. Concept Map \u00b6 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 Application \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 Bundle \u2502 Bundle \u2502 Bundle \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 Agents \u2502 Tools \u2502 Context \u2502 Hooks \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 Kernel (Modules) \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 Providers (LLMs) \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 Next Steps \u00b6 Once you grasp these concepts, move to Bundles to see them applied in practice.","title":"Overview"},{"location":"concepts/index.html#core-concepts","text":"Understanding Amplifier's architecture and design philosophy is essential for building effective AI-powered applications. These concepts form the mental model you'll use throughout your work. This section explains the foundational ideas, patterns, and principles that make Amplifier work.","title":"Core Concepts"},{"location":"concepts/index.html#section-contents","text":"Page Description Agents Autonomous task executors with specific capabilities Bundles Composable packages of behaviors and tools Modules Kernel extension points and contracts Hooks Event-driven extensibility system Skills Domain knowledge packages Recipes Declarative multi-step workflows Architecture System design and philosophy","title":"Section Contents"},{"location":"concepts/index.html#quick-tips","text":"Sessions are stateful - Each conversation maintains history and can be resumed Agents are specialists - Delegate complex tasks to purpose-built agents Bundles compose - Layer multiple bundles to build custom capabilities Modules extend - Add new functionality without modifying the kernel Context is king - What the model sees determines what it can do","title":"Quick Tips"},{"location":"concepts/index.html#key-principles","text":"","title":"Key Principles"},{"location":"concepts/index.html#modular-design","text":"Everything in Amplifier is designed to be composed, replaced, and extended. No monoliths.","title":"Modular Design"},{"location":"concepts/index.html#thin-bundles","text":"Bundles should be minimal\u2014just enough to define behavior, composed from reusable parts.","title":"Thin Bundles"},{"location":"concepts/index.html#ruthless-simplicity","text":"Complexity is the enemy. Every abstraction must justify its existence.","title":"Ruthless Simplicity"},{"location":"concepts/index.html#trust-in-emergence","text":"Complex behaviors emerge from simple, well-defined components working together.","title":"Trust in Emergence"},{"location":"concepts/index.html#where-to-start","text":"Understanding architecture? Read Architecture first\u2014understanding the system design is fundamental. Building custom behaviors? Start with Bundles to see how capabilities compose. Extending the system? Modules explains the kernel's extension contracts.","title":"Where to Start"},{"location":"concepts/index.html#concept-map","text":"\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 Application \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 Bundle \u2502 Bundle \u2502 Bundle \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 Agents \u2502 Tools \u2502 Context \u2502 Hooks \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 Kernel (Modules) \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 Providers (LLMs) \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Concept Map"},{"location":"concepts/index.html#next-steps","text":"Once you grasp these concepts, move to Bundles to see them applied in practice.","title":"Next Steps"},{"location":"concepts/agents.html","text":"Understanding Agents \u00b6 Agents are one of Amplifier's most powerful features for handling complex, multi-step tasks. They enable delegation, parallel execution, and specialized expertise\u2014all while maintaining the simplicity of the bundle format you already know. What is an Agent? \u00b6 Key Insight: Agents ARE bundles. Same file format. An agent is simply a bundle that gets spawned as a sub-session to handle a specific task. There's no special \"agent format\" to learn. If you can write a bundle, you can write an agent. The only difference is how it's used: Bundle : Loaded into your current session, adds capabilities Agent : Spawned as a separate sub-session, works independently # This is both a valid bundle AND a valid agent name : code-reviewer version : \"1.0.0\" description : \"Reviews code for quality and best practices\" instructions : - role : system content : | You are a code review specialist. Analyze code for: - Security vulnerabilities - Performance issues - Best practice violations - Maintainability concerns When you load this as a bundle, its instructions enhance your session. When you spawn it as an agent, it runs independently and reports back. How Agents Work \u00b6 Agents operate as isolated sub-sessions with their own context and tools: \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 Main Session \u2502 \u2502 Sub-Session \u2502 \u2502 (you) \u2502 \u2502 (agent) \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 task \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 \u2502 \u2502 Your \u2502\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25b6\u2502 \u2502 Agent \u2502 \u2502 \u2502 \u2502 Context \u2502 \u2502 \u2502 \u2502 Context \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 Continues... \u2502\u25c0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500 Final Report \u2502 \u2502 \u2502 result \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 Key characteristics: Stateless : Each agent invocation starts fresh with no memory of previous calls Isolated : Agents have their own context window, separate from yours One-shot : You send instructions, they work, they report back once Autonomous : Agents decide how to accomplish the task you give them The agent receives: - Your instruction (the task to perform) - Its own bundle configuration (instructions, tools, context) - Access to the filesystem and configured tools The agent returns: - A single final report with results - No intermediate communication (they work autonomously) Using Agents \u00b6 Agents are invoked through the task tool with an instruction and agent type: Use the task tool: agent: \"foundation:code-reviewer\" instruction: \"Review the authentication module in src/auth/ for security issues\" Writing Effective Instructions \u00b6 Since agents work autonomously with a single instruction, clarity is essential: Good instruction: Analyze src/api/handlers.py for security vulnerabilities. Focus on: input validation, SQL injection, XSS risks. Return: A list of issues with severity, line numbers, and fix suggestions. Poor instruction: Check the code. Parallel Execution \u00b6 One of the most powerful patterns is running multiple agents simultaneously: # These run in parallel when called in the same message task(agent=\"foundation:test-coverage\", instruction=\"Analyze test coverage for src/auth/\") task(agent=\"foundation:security-guardian\", instruction=\"Security audit of src/auth/\") task(agent=\"foundation:zen-architect\", instruction=\"Review architecture of src/auth/\") All three agents work concurrently, dramatically reducing total time. Built-in Agents \u00b6 Amplifier Foundation provides specialized agents for common development tasks: Agent Purpose When to Use foundation:zen-architect Architecture design and code planning Starting new features, system design foundation:modular-builder Implementation from specifications Building code from architect specs foundation:bug-hunter Systematic debugging Tracking down errors and failures foundation:explorer Deep codebase reconnaissance Understanding unfamiliar code foundation:test-coverage Test analysis and gap identification Ensuring adequate test coverage foundation:security-guardian Security audits and vulnerability detection Pre-deployment security checks foundation:git-ops Git and GitHub operations Commits, PRs, branch management foundation:web-research Internet research and documentation lookup Finding external information foundation:file-ops Precise file operations Batch file changes, targeted edits foundation:integration-specialist External service integration API connections, MCP setup Agent Selection Guidelines \u00b6 Choose agents based on the task type: Analysis tasks \u2192 explorer , test-coverage , security-guardian Implementation tasks \u2192 modular-builder , file-ops Design tasks \u2192 zen-architect Debugging tasks \u2192 bug-hunter External tasks \u2192 web-research , integration-specialist Creating Your Own Agents \u00b6 Since agents are just bundles, creating one is straightforward: Step 1: Define the Bundle \u00b6 # .amplifier/agents/my-agent.yaml name : my-custom-agent version : \"1.0.0\" description : \"Specialized agent for my domain\" instructions : - role : system content : | You are a specialist in [domain]. Your task execution process: 1. Analyze the instruction provided 2. Gather necessary information using your tools 3. Perform the requested work 4. Return a clear, structured report Always include in your final report: - Summary of what was done - Key findings or results - Any issues encountered - Recommendations for next steps Step 2: Add Tools (Optional) \u00b6 tools : - tool-bash - tool-files - tool-grep Step 3: Add Context (Optional) \u00b6 context : - path : ./domain-knowledge.md - path : ./coding-standards.md Step 4: Register in Your Collection \u00b6 Add to your collection's agents section or place in .amplifier/agents/ . Agent Design Best Practices \u00b6 Single responsibility : Each agent should excel at one thing Clear output contract : Define what the agent should return Appropriate tools : Only include tools the agent actually needs Good instructions : Guide the agent's approach and output format Domain context : Include relevant knowledge files Agents vs Bundles \u00b6 Understanding when to use each: Aspect Bundle Agent Loading Into current session As separate sub-session Context Shares your context Has its own context Interaction Continuous, conversational One-shot task/report Best for Adding capabilities Delegating tasks Memory Persists in session Stateless per invocation Parallelism N/A Can run multiple simultaneously When to Use Bundles \u00b6 Adding tools and capabilities to your session Loading persistent context (coding standards, domain knowledge) Enhancing the main agent's abilities When you need conversational back-and-forth When to Use Agents \u00b6 Delegating specific, well-defined tasks Running multiple analyses in parallel Isolating complex work from your main context When the task can be described in a single instruction The Same File, Two Uses \u00b6 The same YAML file can serve both purposes: # code-quality.yaml name : code-quality description : \"Code quality analysis\" instructions : - role : system content : \"Analyze code for quality issues...\" tools : - tool-files - tool-grep As bundle : amp --bundle code-quality \u2192 Adds quality analysis to your session As agent : task(agent=\"code-quality\", ...) \u2192 Spawns quality analyzer Advanced Patterns \u00b6 Chained Agents \u00b6 Use one agent's output as input for another: 1. zen-architect analyzes and creates spec 2. modular-builder implements from spec 3. test-coverage verifies implementation 4. security-guardian audits result Specialist Teams \u00b6 Create domain-specific agent teams: # Your collection could include: agents : - api-designer # Designs REST APIs - schema-validator # Validates data schemas - docs-generator # Generates documentation Context Handoff \u00b6 Pass relevant context in your instruction: instruction: | Review the following code changes: Files modified: src/auth.py, src/session.py PR description: Adds JWT token refresh Related issue: #142 Focus on security implications of the token handling. Key Takeaways \u00b6 Agents ARE bundles \u2014 Same YAML format, different execution model Delegation, not conversation \u2014 Send clear instructions, get back reports Parallelism is powerful \u2014 Run multiple agents simultaneously for speed Stateless by design \u2014 Each invocation starts fresh Single responsibility \u2014 Best agents do one thing exceptionally well Clear instructions matter \u2014 Agents work autonomously from your instruction Built-in agents cover common needs \u2014 Use Foundation agents before building custom Same file, two uses \u2014 Any bundle can be used as an agent and vice versa Next Steps \u00b6 Advanced Topics \u2014 Build custom bundles and agents Bundles Guide \u2014 Learn about bundle composition Task Tool Reference \u2014 Complete task tool documentation","title":"Agents"},{"location":"concepts/agents.html#understanding-agents","text":"Agents are one of Amplifier's most powerful features for handling complex, multi-step tasks. They enable delegation, parallel execution, and specialized expertise\u2014all while maintaining the simplicity of the bundle format you already know.","title":"Understanding Agents"},{"location":"concepts/agents.html#what-is-an-agent","text":"Key Insight: Agents ARE bundles. Same file format. An agent is simply a bundle that gets spawned as a sub-session to handle a specific task. There's no special \"agent format\" to learn. If you can write a bundle, you can write an agent. The only difference is how it's used: Bundle : Loaded into your current session, adds capabilities Agent : Spawned as a separate sub-session, works independently # This is both a valid bundle AND a valid agent name : code-reviewer version : \"1.0.0\" description : \"Reviews code for quality and best practices\" instructions : - role : system content : | You are a code review specialist. Analyze code for: - Security vulnerabilities - Performance issues - Best practice violations - Maintainability concerns When you load this as a bundle, its instructions enhance your session. When you spawn it as an agent, it runs independently and reports back.","title":"What is an Agent?"},{"location":"concepts/agents.html#how-agents-work","text":"Agents operate as isolated sub-sessions with their own context and tools: \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 Main Session \u2502 \u2502 Sub-Session \u2502 \u2502 (you) \u2502 \u2502 (agent) \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 task \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 \u2502 \u2502 Your \u2502\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25b6\u2502 \u2502 Agent \u2502 \u2502 \u2502 \u2502 Context \u2502 \u2502 \u2502 \u2502 Context \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 Continues... \u2502\u25c0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500 Final Report \u2502 \u2502 \u2502 result \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 Key characteristics: Stateless : Each agent invocation starts fresh with no memory of previous calls Isolated : Agents have their own context window, separate from yours One-shot : You send instructions, they work, they report back once Autonomous : Agents decide how to accomplish the task you give them The agent receives: - Your instruction (the task to perform) - Its own bundle configuration (instructions, tools, context) - Access to the filesystem and configured tools The agent returns: - A single final report with results - No intermediate communication (they work autonomously)","title":"How Agents Work"},{"location":"concepts/agents.html#using-agents","text":"Agents are invoked through the task tool with an instruction and agent type: Use the task tool: agent: \"foundation:code-reviewer\" instruction: \"Review the authentication module in src/auth/ for security issues\"","title":"Using Agents"},{"location":"concepts/agents.html#writing-effective-instructions","text":"Since agents work autonomously with a single instruction, clarity is essential: Good instruction: Analyze src/api/handlers.py for security vulnerabilities. Focus on: input validation, SQL injection, XSS risks. Return: A list of issues with severity, line numbers, and fix suggestions. Poor instruction: Check the code.","title":"Writing Effective Instructions"},{"location":"concepts/agents.html#parallel-execution","text":"One of the most powerful patterns is running multiple agents simultaneously: # These run in parallel when called in the same message task(agent=\"foundation:test-coverage\", instruction=\"Analyze test coverage for src/auth/\") task(agent=\"foundation:security-guardian\", instruction=\"Security audit of src/auth/\") task(agent=\"foundation:zen-architect\", instruction=\"Review architecture of src/auth/\") All three agents work concurrently, dramatically reducing total time.","title":"Parallel Execution"},{"location":"concepts/agents.html#built-in-agents","text":"Amplifier Foundation provides specialized agents for common development tasks: Agent Purpose When to Use foundation:zen-architect Architecture design and code planning Starting new features, system design foundation:modular-builder Implementation from specifications Building code from architect specs foundation:bug-hunter Systematic debugging Tracking down errors and failures foundation:explorer Deep codebase reconnaissance Understanding unfamiliar code foundation:test-coverage Test analysis and gap identification Ensuring adequate test coverage foundation:security-guardian Security audits and vulnerability detection Pre-deployment security checks foundation:git-ops Git and GitHub operations Commits, PRs, branch management foundation:web-research Internet research and documentation lookup Finding external information foundation:file-ops Precise file operations Batch file changes, targeted edits foundation:integration-specialist External service integration API connections, MCP setup","title":"Built-in Agents"},{"location":"concepts/agents.html#agent-selection-guidelines","text":"Choose agents based on the task type: Analysis tasks \u2192 explorer , test-coverage , security-guardian Implementation tasks \u2192 modular-builder , file-ops Design tasks \u2192 zen-architect Debugging tasks \u2192 bug-hunter External tasks \u2192 web-research , integration-specialist","title":"Agent Selection Guidelines"},{"location":"concepts/agents.html#creating-your-own-agents","text":"Since agents are just bundles, creating one is straightforward:","title":"Creating Your Own Agents"},{"location":"concepts/agents.html#step-1-define-the-bundle","text":"# .amplifier/agents/my-agent.yaml name : my-custom-agent version : \"1.0.0\" description : \"Specialized agent for my domain\" instructions : - role : system content : | You are a specialist in [domain]. Your task execution process: 1. Analyze the instruction provided 2. Gather necessary information using your tools 3. Perform the requested work 4. Return a clear, structured report Always include in your final report: - Summary of what was done - Key findings or results - Any issues encountered - Recommendations for next steps","title":"Step 1: Define the Bundle"},{"location":"concepts/agents.html#step-2-add-tools-optional","text":"tools : - tool-bash - tool-files - tool-grep","title":"Step 2: Add Tools (Optional)"},{"location":"concepts/agents.html#step-3-add-context-optional","text":"context : - path : ./domain-knowledge.md - path : ./coding-standards.md","title":"Step 3: Add Context (Optional)"},{"location":"concepts/agents.html#step-4-register-in-your-collection","text":"Add to your collection's agents section or place in .amplifier/agents/ .","title":"Step 4: Register in Your Collection"},{"location":"concepts/agents.html#agent-design-best-practices","text":"Single responsibility : Each agent should excel at one thing Clear output contract : Define what the agent should return Appropriate tools : Only include tools the agent actually needs Good instructions : Guide the agent's approach and output format Domain context : Include relevant knowledge files","title":"Agent Design Best Practices"},{"location":"concepts/agents.html#agents-vs-bundles","text":"Understanding when to use each: Aspect Bundle Agent Loading Into current session As separate sub-session Context Shares your context Has its own context Interaction Continuous, conversational One-shot task/report Best for Adding capabilities Delegating tasks Memory Persists in session Stateless per invocation Parallelism N/A Can run multiple simultaneously","title":"Agents vs Bundles"},{"location":"concepts/agents.html#when-to-use-bundles","text":"Adding tools and capabilities to your session Loading persistent context (coding standards, domain knowledge) Enhancing the main agent's abilities When you need conversational back-and-forth","title":"When to Use Bundles"},{"location":"concepts/agents.html#when-to-use-agents","text":"Delegating specific, well-defined tasks Running multiple analyses in parallel Isolating complex work from your main context When the task can be described in a single instruction","title":"When to Use Agents"},{"location":"concepts/agents.html#the-same-file-two-uses","text":"The same YAML file can serve both purposes: # code-quality.yaml name : code-quality description : \"Code quality analysis\" instructions : - role : system content : \"Analyze code for quality issues...\" tools : - tool-files - tool-grep As bundle : amp --bundle code-quality \u2192 Adds quality analysis to your session As agent : task(agent=\"code-quality\", ...) \u2192 Spawns quality analyzer","title":"The Same File, Two Uses"},{"location":"concepts/agents.html#advanced-patterns","text":"","title":"Advanced Patterns"},{"location":"concepts/agents.html#chained-agents","text":"Use one agent's output as input for another: 1. zen-architect analyzes and creates spec 2. modular-builder implements from spec 3. test-coverage verifies implementation 4. security-guardian audits result","title":"Chained Agents"},{"location":"concepts/agents.html#specialist-teams","text":"Create domain-specific agent teams: # Your collection could include: agents : - api-designer # Designs REST APIs - schema-validator # Validates data schemas - docs-generator # Generates documentation","title":"Specialist Teams"},{"location":"concepts/agents.html#context-handoff","text":"Pass relevant context in your instruction: instruction: | Review the following code changes: Files modified: src/auth.py, src/session.py PR description: Adds JWT token refresh Related issue: #142 Focus on security implications of the token handling.","title":"Context Handoff"},{"location":"concepts/agents.html#key-takeaways","text":"Agents ARE bundles \u2014 Same YAML format, different execution model Delegation, not conversation \u2014 Send clear instructions, get back reports Parallelism is powerful \u2014 Run multiple agents simultaneously for speed Stateless by design \u2014 Each invocation starts fresh Single responsibility \u2014 Best agents do one thing exceptionally well Clear instructions matter \u2014 Agents work autonomously from your instruction Built-in agents cover common needs \u2014 Use Foundation agents before building custom Same file, two uses \u2014 Any bundle can be used as an agent and vice versa","title":"Key Takeaways"},{"location":"concepts/agents.html#next-steps","text":"Advanced Topics \u2014 Build custom bundles and agents Bundles Guide \u2014 Learn about bundle composition Task Tool Reference \u2014 Complete task tool documentation","title":"Next Steps"},{"location":"concepts/architecture.html","text":"Architecture Overview \u00b6 This document provides a comprehensive overview of the system architecture, explaining how components interact to create a flexible, extensible AI agent runtime. The Kernel Philosophy \u00b6 The kernel follows a fundamental principle: mechanism, not policy . This means the kernel provides the how but never the what . It offers primitives for: Session management and lifecycle Event emission and subscription Module mounting and discovery Tool invocation and result handling Hook execution chains What it explicitly avoids: Deciding which tools to expose Defining conversation strategies Implementing specific behaviors Making business logic decisions This separation keeps the kernel minimal and stable while allowing infinite customization through modules. The kernel changes rarely; modules change constantly. Session Lifecycle \u00b6 Every interaction flows through a well-defined session lifecycle: User Input \u2193 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 SESSION \u2502 \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 \u2502 \u2502 State: user_id, session_id, context, history \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2193 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 COORDINATOR \u2502 \u2502 \u2022 Validates input \u2502 \u2502 \u2022 Manages conversation flow \u2502 \u2502 \u2022 Handles turn transitions \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2193 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 ORCHESTRATOR \u2502 \u2502 \u2022 Manages the agent loop \u2502 \u2502 \u2022 Dispatches to provider \u2502 \u2502 \u2022 Processes tool calls \u2502 \u2502 \u2022 Executes hooks at each phase \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2193 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2193 \u2193 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 PROVIDER \u2502 \u2502 TOOLS/HOOKS \u2502 \u2502 (Claude, GPT, etc.) \u2502 \u2502 (Mounted Modules) \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 Session States \u00b6 A session progresses through these states: INITIALIZING - Session created, loading configuration READY - All modules mounted, waiting for input PROCESSING - Actively handling a user turn AWAITING_TOOL - Waiting for tool execution results COMPLETED - Session ended normally ERROR - Session ended due to an error The Agent Loop \u00b6 The orchestrator runs the core agent loop: \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 AGENT LOOP \u2502 \u2502 \u2502 \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 \u2502 \u2502 User \u2502\u2500\u2500\u2500\u2192\u2502 Provider \u2502\u2500\u2500\u2500\u2192\u2502 Tool Calls? \u2502 \u2502 \u2502 \u2502 Input \u2502 \u2502 (LLM) \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u2502 \u2502 Yes \u2502 No \u2502 \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 \u2502 \u2193 \u2193 \u2502 \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 \u2502 \u2502 Execute Tools \u2502 \u2502 Return \u2502 \u2502 \u2502 \u2502 (with hooks) \u2502 \u2502 Response \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2192 Back to Provider \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 The loop continues until the provider returns a response without tool calls, or a maximum iteration limit is reached. Event Flow \u00b6 The system uses an event-driven architecture for observability and extensibility. Events flow through a central bus, allowing modules to subscribe to what they need. Event Categories \u00b6 Category Purpose Examples session.* Session lifecycle session.started , session.ended turn.* Turn processing turn.started , turn.completed tool.* Tool invocation tool.called , tool.result provider.* LLM interactions provider.request , provider.response hook.* Hook execution hook.before , hook.after Event Structure \u00b6 Every event follows a consistent structure: { \"event_type\" : \"tool.called\" , \"timestamp\" : \"2024-01-15T10:30:00Z\" , \"session_id\" : \"abc123\" , \"payload\" : { \"tool_name\" : \"read_file\" , \"arguments\" : { \"path\" : \"/src/main.py\" }, \"invocation_id\" : \"inv_456\" }, \"metadata\" : { \"source_module\" : \"tool-filesystem\" , \"turn_number\" : 3 } } Subscribing to Events \u00b6 Modules subscribe to events using pattern matching: # Subscribe to all tool events @event_handler ( \"tool.*\" ) async def on_tool_event ( event ): logger . info ( f \"Tool event: { event . event_type } \" ) # Subscribe to specific event @event_handler ( \"session.started\" ) async def on_session_start ( event ): await initialize_user_context ( event . payload . user_id ) Module Mounting \u00b6 Modules are the primary extension mechanism. They provide tools, hooks, context, and behaviors that customize the system. Module Types \u00b6 Type Purpose Examples Tool Modules Provide callable tools tool-filesystem , tool-web Hook Modules Intercept/modify flows hook-auth , hook-logging Context Modules Inject system prompts context-project , context-user Provider Modules LLM integrations provider-anthropic , provider-openai Behavior Modules Complex behaviors behavior-agents , behavior-memory Mount Order \u00b6 Modules are mounted in a specific order: Core modules - Kernel-provided fundamentals Provider modules - LLM connectivity Context modules - System prompt building Tool modules - Available capabilities Hook modules - Processing interceptors Behavior modules - High-level behaviors Within each category, modules mount in the order specified in configuration. Module Resolution \u00b6 When mounting, the system follows this flow: \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 Discover \u2502\u2500\u2500\u2500\u2192\u2502 Validate \u2502\u2500\u2500\u2500\u2192\u2502 Initialize \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u2193 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 Activate \u2502\u2190\u2500\u2500\u2500\u2502 Register \u2502\u2190\u2500\u2500\u2500\u2502 Ready \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 Discovers - Finds the module by name/path Validates - Checks dependencies and compatibility Initializes - Calls the module's init function Registers - Adds tools/hooks to the session Activates - Marks the module as ready Module Dependencies \u00b6 Modules can declare dependencies on other modules: # module.yaml name : my-tool version : 1.0.0 dependencies : - tool-filesystem : \">=1.0.0\" - hook-auth : \">=2.0.0\" The mount system ensures dependencies are satisfied before loading. Tool Registration \u00b6 When a tool module mounts, it registers its tools: class FilesystemModule : def register_tools ( self , registry ): registry . add_tool ( name = \"read_file\" , description = \"Read contents of a file\" , parameters = ReadFileParams , handler = self . read_file ) Hook Execution \u00b6 Hooks allow modules to intercept and modify the processing flow at defined points. Hook Points \u00b6 Hook Point When Use Cases pre_turn Before processing starts Auth, rate limiting pre_provider Before LLM call Prompt modification post_provider After LLM response Response filtering pre_tool Before tool execution Permission checks post_tool After tool execution Result transformation post_turn After turn completes Logging, cleanup Hook Chain \u00b6 Multiple hooks at the same point form a chain: Input \u2192 Hook1 \u2192 Hook2 \u2192 Hook3 \u2192 Continue Processing \u2191 (can modify or abort) Hooks execute in registration order. Any hook can: - Pass through - Let the chain continue - Modify - Change the data and continue - Abort - Stop the chain and return early Hook Example \u00b6 @hook ( \"pre_tool\" ) async def validate_file_access ( context , tool_name , arguments ): if tool_name == \"write_file\" : path = arguments . get ( \"path\" , \"\" ) if not is_allowed_path ( path ): raise PermissionError ( f \"Cannot write to: { path } \" ) return arguments # Continue with (possibly modified) args Key Takeaways \u00b6 Understanding the architecture helps you work effectively with the system: 1. Kernel is Minimal \u00b6 The kernel provides mechanisms, not policies. It's deliberately simple and stable. Customize through modules, not kernel changes. 2. Sessions are Stateful \u00b6 Each session maintains its own state, mounted modules, and conversation history. Sessions are isolated from each other. 3. Events Enable Observability \u00b6 Everything emits events. Use them for logging, debugging, metrics, and extending behavior without modifying core code. 4. Modules are the Extension Point \u00b6 Need new functionality? Create a module. Need to modify behavior? Create a hook. The module system is designed for this. 5. Order Matters \u00b6 Mount order, hook order, and event order all affect behavior. Be intentional about ordering in your configurations. 6. The Agent Loop is Central \u00b6 Understanding the orchestrator's agent loop is key to understanding how conversations flow and how tools integrate. Next Steps \u00b6 With this architectural understanding, explore: Modules Deep Dive - Creating and configuring modules Hooks Guide - Building effective hooks Bundles Guide - Bundle composition patterns Advanced Topics - Custom modules and tools","title":"Architecture Deep Dive"},{"location":"concepts/architecture.html#architecture-overview","text":"This document provides a comprehensive overview of the system architecture, explaining how components interact to create a flexible, extensible AI agent runtime.","title":"Architecture Overview"},{"location":"concepts/architecture.html#the-kernel-philosophy","text":"The kernel follows a fundamental principle: mechanism, not policy . This means the kernel provides the how but never the what . It offers primitives for: Session management and lifecycle Event emission and subscription Module mounting and discovery Tool invocation and result handling Hook execution chains What it explicitly avoids: Deciding which tools to expose Defining conversation strategies Implementing specific behaviors Making business logic decisions This separation keeps the kernel minimal and stable while allowing infinite customization through modules. The kernel changes rarely; modules change constantly.","title":"The Kernel Philosophy"},{"location":"concepts/architecture.html#session-lifecycle","text":"Every interaction flows through a well-defined session lifecycle: User Input \u2193 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 SESSION \u2502 \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 \u2502 \u2502 State: user_id, session_id, context, history \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2193 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 COORDINATOR \u2502 \u2502 \u2022 Validates input \u2502 \u2502 \u2022 Manages conversation flow \u2502 \u2502 \u2022 Handles turn transitions \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2193 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 ORCHESTRATOR \u2502 \u2502 \u2022 Manages the agent loop \u2502 \u2502 \u2022 Dispatches to provider \u2502 \u2502 \u2022 Processes tool calls \u2502 \u2502 \u2022 Executes hooks at each phase \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2193 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2193 \u2193 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 PROVIDER \u2502 \u2502 TOOLS/HOOKS \u2502 \u2502 (Claude, GPT, etc.) \u2502 \u2502 (Mounted Modules) \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Session Lifecycle"},{"location":"concepts/architecture.html#session-states","text":"A session progresses through these states: INITIALIZING - Session created, loading configuration READY - All modules mounted, waiting for input PROCESSING - Actively handling a user turn AWAITING_TOOL - Waiting for tool execution results COMPLETED - Session ended normally ERROR - Session ended due to an error","title":"Session States"},{"location":"concepts/architecture.html#the-agent-loop","text":"The orchestrator runs the core agent loop: \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 AGENT LOOP \u2502 \u2502 \u2502 \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 \u2502 \u2502 User \u2502\u2500\u2500\u2500\u2192\u2502 Provider \u2502\u2500\u2500\u2500\u2192\u2502 Tool Calls? \u2502 \u2502 \u2502 \u2502 Input \u2502 \u2502 (LLM) \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u2502 \u2502 Yes \u2502 No \u2502 \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 \u2502 \u2193 \u2193 \u2502 \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 \u2502 \u2502 Execute Tools \u2502 \u2502 Return \u2502 \u2502 \u2502 \u2502 (with hooks) \u2502 \u2502 Response \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2192 Back to Provider \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 The loop continues until the provider returns a response without tool calls, or a maximum iteration limit is reached.","title":"The Agent Loop"},{"location":"concepts/architecture.html#event-flow","text":"The system uses an event-driven architecture for observability and extensibility. Events flow through a central bus, allowing modules to subscribe to what they need.","title":"Event Flow"},{"location":"concepts/architecture.html#event-categories","text":"Category Purpose Examples session.* Session lifecycle session.started , session.ended turn.* Turn processing turn.started , turn.completed tool.* Tool invocation tool.called , tool.result provider.* LLM interactions provider.request , provider.response hook.* Hook execution hook.before , hook.after","title":"Event Categories"},{"location":"concepts/architecture.html#event-structure","text":"Every event follows a consistent structure: { \"event_type\" : \"tool.called\" , \"timestamp\" : \"2024-01-15T10:30:00Z\" , \"session_id\" : \"abc123\" , \"payload\" : { \"tool_name\" : \"read_file\" , \"arguments\" : { \"path\" : \"/src/main.py\" }, \"invocation_id\" : \"inv_456\" }, \"metadata\" : { \"source_module\" : \"tool-filesystem\" , \"turn_number\" : 3 } }","title":"Event Structure"},{"location":"concepts/architecture.html#subscribing-to-events","text":"Modules subscribe to events using pattern matching: # Subscribe to all tool events @event_handler ( \"tool.*\" ) async def on_tool_event ( event ): logger . info ( f \"Tool event: { event . event_type } \" ) # Subscribe to specific event @event_handler ( \"session.started\" ) async def on_session_start ( event ): await initialize_user_context ( event . payload . user_id )","title":"Subscribing to Events"},{"location":"concepts/architecture.html#module-mounting","text":"Modules are the primary extension mechanism. They provide tools, hooks, context, and behaviors that customize the system.","title":"Module Mounting"},{"location":"concepts/architecture.html#module-types","text":"Type Purpose Examples Tool Modules Provide callable tools tool-filesystem , tool-web Hook Modules Intercept/modify flows hook-auth , hook-logging Context Modules Inject system prompts context-project , context-user Provider Modules LLM integrations provider-anthropic , provider-openai Behavior Modules Complex behaviors behavior-agents , behavior-memory","title":"Module Types"},{"location":"concepts/architecture.html#mount-order","text":"Modules are mounted in a specific order: Core modules - Kernel-provided fundamentals Provider modules - LLM connectivity Context modules - System prompt building Tool modules - Available capabilities Hook modules - Processing interceptors Behavior modules - High-level behaviors Within each category, modules mount in the order specified in configuration.","title":"Mount Order"},{"location":"concepts/architecture.html#module-resolution","text":"When mounting, the system follows this flow: \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 Discover \u2502\u2500\u2500\u2500\u2192\u2502 Validate \u2502\u2500\u2500\u2500\u2192\u2502 Initialize \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u2193 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 Activate \u2502\u2190\u2500\u2500\u2500\u2502 Register \u2502\u2190\u2500\u2500\u2500\u2502 Ready \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 Discovers - Finds the module by name/path Validates - Checks dependencies and compatibility Initializes - Calls the module's init function Registers - Adds tools/hooks to the session Activates - Marks the module as ready","title":"Module Resolution"},{"location":"concepts/architecture.html#module-dependencies","text":"Modules can declare dependencies on other modules: # module.yaml name : my-tool version : 1.0.0 dependencies : - tool-filesystem : \">=1.0.0\" - hook-auth : \">=2.0.0\" The mount system ensures dependencies are satisfied before loading.","title":"Module Dependencies"},{"location":"concepts/architecture.html#tool-registration","text":"When a tool module mounts, it registers its tools: class FilesystemModule : def register_tools ( self , registry ): registry . add_tool ( name = \"read_file\" , description = \"Read contents of a file\" , parameters = ReadFileParams , handler = self . read_file )","title":"Tool Registration"},{"location":"concepts/architecture.html#hook-execution","text":"Hooks allow modules to intercept and modify the processing flow at defined points.","title":"Hook Execution"},{"location":"concepts/architecture.html#hook-points","text":"Hook Point When Use Cases pre_turn Before processing starts Auth, rate limiting pre_provider Before LLM call Prompt modification post_provider After LLM response Response filtering pre_tool Before tool execution Permission checks post_tool After tool execution Result transformation post_turn After turn completes Logging, cleanup","title":"Hook Points"},{"location":"concepts/architecture.html#hook-chain","text":"Multiple hooks at the same point form a chain: Input \u2192 Hook1 \u2192 Hook2 \u2192 Hook3 \u2192 Continue Processing \u2191 (can modify or abort) Hooks execute in registration order. Any hook can: - Pass through - Let the chain continue - Modify - Change the data and continue - Abort - Stop the chain and return early","title":"Hook Chain"},{"location":"concepts/architecture.html#hook-example","text":"@hook ( \"pre_tool\" ) async def validate_file_access ( context , tool_name , arguments ): if tool_name == \"write_file\" : path = arguments . get ( \"path\" , \"\" ) if not is_allowed_path ( path ): raise PermissionError ( f \"Cannot write to: { path } \" ) return arguments # Continue with (possibly modified) args","title":"Hook Example"},{"location":"concepts/architecture.html#key-takeaways","text":"Understanding the architecture helps you work effectively with the system:","title":"Key Takeaways"},{"location":"concepts/architecture.html#1-kernel-is-minimal","text":"The kernel provides mechanisms, not policies. It's deliberately simple and stable. Customize through modules, not kernel changes.","title":"1. Kernel is Minimal"},{"location":"concepts/architecture.html#2-sessions-are-stateful","text":"Each session maintains its own state, mounted modules, and conversation history. Sessions are isolated from each other.","title":"2. Sessions are Stateful"},{"location":"concepts/architecture.html#3-events-enable-observability","text":"Everything emits events. Use them for logging, debugging, metrics, and extending behavior without modifying core code.","title":"3. Events Enable Observability"},{"location":"concepts/architecture.html#4-modules-are-the-extension-point","text":"Need new functionality? Create a module. Need to modify behavior? Create a hook. The module system is designed for this.","title":"4. Modules are the Extension Point"},{"location":"concepts/architecture.html#5-order-matters","text":"Mount order, hook order, and event order all affect behavior. Be intentional about ordering in your configurations.","title":"5. Order Matters"},{"location":"concepts/architecture.html#6-the-agent-loop-is-central","text":"Understanding the orchestrator's agent loop is key to understanding how conversations flow and how tools integrate.","title":"6. The Agent Loop is Central"},{"location":"concepts/architecture.html#next-steps","text":"With this architectural understanding, explore: Modules Deep Dive - Creating and configuring modules Hooks Guide - Building effective hooks Bundles Guide - Bundle composition patterns Advanced Topics - Custom modules and tools","title":"Next Steps"},{"location":"concepts/bundles.html","text":"Understanding Bundles \u00b6 Bundles are the fundamental unit of composition in Amplifier. They package capabilities, behaviors, and configuration into reusable, shareable units that can be combined to create powerful AI-powered applications. What is a Bundle? \u00b6 A bundle is a composable configuration package that defines what an AI assistant can do. Think of bundles like LEGO sets\u2014each one provides specific pieces that snap together with other bundles to build complete solutions. Core Characteristics \u00b6 Bundles share several defining characteristics: Self-contained : Each bundle includes everything it needs to function Composable : Bundles can include other bundles to build on existing capabilities Declarative : Configuration is specified in YAML, not imperative code Portable : Bundles can be shared, versioned, and distributed independently What Bundles Contain \u00b6 A typical bundle may include: Configuration : YAML frontmatter defining metadata and settings Instructions : Markdown content providing guidance to the AI Behaviors : References to specific capabilities or tools Context files : Supporting documentation and examples Includes : References to other bundles to compose functionality The Thin Bundle Pattern \u00b6 Amplifier follows the \"thin bundle\" philosophy\u2014bundles should be minimal wrappers that compose existing capabilities rather than reinventing functionality. A well-designed bundle: References behaviors instead of duplicating logic Includes foundation bundles for common capabilities Adds only the specific instructions needed for its use case Stays focused on a single domain or purpose Bundle Structure \u00b6 Every bundle consists of a markdown file with YAML frontmatter. The frontmatter defines the bundle's metadata and configuration, while the markdown body provides instructions and context for the AI. Anatomy of a Bundle File \u00b6 --- id : my-bundle name : My Custom Bundle version : 1.0.0 description : A bundle that does something useful # Include other bundles includes : - foundation:core - foundation:file-ops # Reference specific behaviors behaviors : - code-review - testing # Configure providers (optional) providers : primary : model : claude-sonnet-4-20250514 # Define custom settings (optional) settings : max_file_size : 10000 output_format : markdown --- # My Custom Bundle Instructions for the AI go here in markdown format. ## What This Bundle Does Explain the purpose and capabilities... ## How to Use Provide guidance on usage patterns... Frontmatter Fields \u00b6 Required Fields \u00b6 Field Description id Unique identifier for the bundle (lowercase, hyphens) name Human-readable display name Common Optional Fields \u00b6 Field Description version Semantic version string (e.g., \"1.0.0\") description Brief description of the bundle's purpose includes List of other bundles to include behaviors List of behaviors to enable providers Provider configuration (models, endpoints) settings Custom key-value settings tools Tool configurations and restrictions context Additional context files to load Markdown Body \u00b6 The markdown body serves as the primary instruction set for the AI. Write clear, actionable guidance that helps the AI understand: What the bundle is designed to do How to approach tasks within its domain What patterns and practices to follow What to avoid or be careful about Composition \u00b6 Composition is where bundles become powerful. Instead of building monolithic configurations, you compose small, focused bundles into complete solutions. The includes Field \u00b6 The includes field specifies which bundles to incorporate: includes : - foundation:core # Core capabilities - foundation:file-ops # File operations - foundation:git-ops # Git operations - my-org:code-standards # Organization standards Include Resolution \u00b6 Bundles are resolved using a namespace:name pattern: foundation:core \u2192 Built-in foundation bundle my-collection:my-bundle \u2192 Bundle from a custom collection ./local-bundle \u2192 Relative path to a local bundle file Composition Order \u00b6 When multiple bundles are composed, they're processed in order: Base bundles (from includes ) are loaded first Each included bundle's includes are resolved recursively The current bundle's configuration is applied last Later configurations can override earlier ones Behaviors \u00b6 Behaviors are reusable capability definitions that bundles can reference: behaviors : - code-review # Enable code review capabilities - testing # Enable testing capabilities - documentation # Enable documentation generation Behaviors differ from includes in that they represent specific capabilities rather than complete bundle configurations. A behavior might enable certain tools, add specific instructions, or configure particular patterns. Practical Composition Example \u00b6 Here's how you might compose a code review bundle: --- id : team-code-review name : Team Code Review includes : - foundation:core - foundation:git-ops behaviors : - code-review - security-review --- # Team Code Review Use this bundle when reviewing pull requests for our team. ## Review Checklist 1. Check for security vulnerabilities 2. Verify test coverage 3. Ensure code follows our style guide 4. Look for performance issues ## Our Standards - All functions must have docstrings - Maximum cyclomatic complexity : 10 - No hardcoded secrets Creating a Bundle \u00b6 Follow these steps to create your own bundle. Step 1: Define the Purpose \u00b6 Before writing any configuration, clearly define: What problem does this bundle solve? Who will use it? What capabilities does it need? What existing bundles can it build on? Step 2: Choose Your Base \u00b6 Start by identifying which foundation bundles to include: includes : - foundation:core # Almost always needed Add additional foundations based on your needs: foundation:file-ops for file manipulation foundation:git-ops for version control foundation:web-research for internet access Step 3: Write the Frontmatter \u00b6 Create your bundle file with appropriate metadata: --- id : my-project-helper name : My Project Helper version : 1.0.0 description : Helps with tasks specific to my project includes : - foundation:core - foundation:file-ops behaviors : - testing --- Step 4: Write Instructions \u00b6 Add clear, specific instructions in the markdown body: # My Project Helper You help developers work on the MyProject codebase. ## Project Structure - `src/` - Source code - `tests/` - Test files - `docs/` - Documentation ## Coding Standards - Use TypeScript strict mode - Write tests for all public functions - Follow the error handling patterns in `src/utils/errors.ts` ## Common Tasks ### Adding a New Feature 1. Create a branch from main 2. Implement the feature in `src/features/` 3. Add tests in `tests/features/` 4. Update documentation if needed Step 5: Test Your Bundle \u00b6 Test your bundle by running Amplifier with it: amp --bundle ./my-bundle.md Verify that: All includes resolve correctly The AI understands your instructions Tools and capabilities work as expected Step 6: Iterate and Refine \u00b6 Based on testing, refine your bundle: Add missing instructions Remove unnecessary includes Clarify ambiguous guidance Add examples for complex tasks Best Practices \u00b6 Keep Bundles Focused \u00b6 Each bundle should have a clear, singular purpose. If you find yourself adding unrelated capabilities, consider splitting into multiple bundles. Use Semantic Versioning \u00b6 Version your bundles to track changes: Major : Breaking changes to behavior or structure Minor : New capabilities, backward compatible Patch : Bug fixes and documentation updates Document Your Bundles \u00b6 Include clear documentation in the markdown body: What the bundle does How to use it effectively What it doesn't do (scope boundaries) Examples of common tasks Leverage Composition \u00b6 Don't duplicate functionality. If another bundle provides what you need, include it rather than recreating it. Test with Real Scenarios \u00b6 Validate your bundle with actual use cases, not just theoretical ones. Real-world testing reveals gaps in instructions and missing capabilities. Key Takeaways \u00b6 Bundles are composable packages that define AI assistant capabilities through declarative YAML configuration and markdown instructions. Structure matters : Use frontmatter for configuration (id, includes, behaviors) and markdown for instructions and context. Composition over duplication : Build on existing bundles using includes rather than recreating functionality. Follow the thin bundle pattern. Behaviors extend capabilities : Reference behaviors to add specific capabilities without including full bundle configurations. Start minimal : Begin with the smallest set of includes and behaviors needed, then add more as requirements emerge. Instructions are key : The markdown body is where you differentiate your bundle. Write clear, actionable guidance for the AI. Test iteratively : Create your bundle, test it with real scenarios, and refine based on what you learn. Bundles embody Amplifier's philosophy of modular, composable design. By creating well-structured bundles, you build reusable capabilities that can be shared across projects and teams, enabling consistent AI-powered workflows wherever they're needed.","title":"Bundles"},{"location":"concepts/bundles.html#understanding-bundles","text":"Bundles are the fundamental unit of composition in Amplifier. They package capabilities, behaviors, and configuration into reusable, shareable units that can be combined to create powerful AI-powered applications.","title":"Understanding Bundles"},{"location":"concepts/bundles.html#what-is-a-bundle","text":"A bundle is a composable configuration package that defines what an AI assistant can do. Think of bundles like LEGO sets\u2014each one provides specific pieces that snap together with other bundles to build complete solutions.","title":"What is a Bundle?"},{"location":"concepts/bundles.html#core-characteristics","text":"Bundles share several defining characteristics: Self-contained : Each bundle includes everything it needs to function Composable : Bundles can include other bundles to build on existing capabilities Declarative : Configuration is specified in YAML, not imperative code Portable : Bundles can be shared, versioned, and distributed independently","title":"Core Characteristics"},{"location":"concepts/bundles.html#what-bundles-contain","text":"A typical bundle may include: Configuration : YAML frontmatter defining metadata and settings Instructions : Markdown content providing guidance to the AI Behaviors : References to specific capabilities or tools Context files : Supporting documentation and examples Includes : References to other bundles to compose functionality","title":"What Bundles Contain"},{"location":"concepts/bundles.html#the-thin-bundle-pattern","text":"Amplifier follows the \"thin bundle\" philosophy\u2014bundles should be minimal wrappers that compose existing capabilities rather than reinventing functionality. A well-designed bundle: References behaviors instead of duplicating logic Includes foundation bundles for common capabilities Adds only the specific instructions needed for its use case Stays focused on a single domain or purpose","title":"The Thin Bundle Pattern"},{"location":"concepts/bundles.html#bundle-structure","text":"Every bundle consists of a markdown file with YAML frontmatter. The frontmatter defines the bundle's metadata and configuration, while the markdown body provides instructions and context for the AI.","title":"Bundle Structure"},{"location":"concepts/bundles.html#anatomy-of-a-bundle-file","text":"--- id : my-bundle name : My Custom Bundle version : 1.0.0 description : A bundle that does something useful # Include other bundles includes : - foundation:core - foundation:file-ops # Reference specific behaviors behaviors : - code-review - testing # Configure providers (optional) providers : primary : model : claude-sonnet-4-20250514 # Define custom settings (optional) settings : max_file_size : 10000 output_format : markdown --- # My Custom Bundle Instructions for the AI go here in markdown format. ## What This Bundle Does Explain the purpose and capabilities... ## How to Use Provide guidance on usage patterns...","title":"Anatomy of a Bundle File"},{"location":"concepts/bundles.html#frontmatter-fields","text":"","title":"Frontmatter Fields"},{"location":"concepts/bundles.html#required-fields","text":"Field Description id Unique identifier for the bundle (lowercase, hyphens) name Human-readable display name","title":"Required Fields"},{"location":"concepts/bundles.html#common-optional-fields","text":"Field Description version Semantic version string (e.g., \"1.0.0\") description Brief description of the bundle's purpose includes List of other bundles to include behaviors List of behaviors to enable providers Provider configuration (models, endpoints) settings Custom key-value settings tools Tool configurations and restrictions context Additional context files to load","title":"Common Optional Fields"},{"location":"concepts/bundles.html#markdown-body","text":"The markdown body serves as the primary instruction set for the AI. Write clear, actionable guidance that helps the AI understand: What the bundle is designed to do How to approach tasks within its domain What patterns and practices to follow What to avoid or be careful about","title":"Markdown Body"},{"location":"concepts/bundles.html#composition","text":"Composition is where bundles become powerful. Instead of building monolithic configurations, you compose small, focused bundles into complete solutions.","title":"Composition"},{"location":"concepts/bundles.html#the-includes-field","text":"The includes field specifies which bundles to incorporate: includes : - foundation:core # Core capabilities - foundation:file-ops # File operations - foundation:git-ops # Git operations - my-org:code-standards # Organization standards","title":"The includes Field"},{"location":"concepts/bundles.html#include-resolution","text":"Bundles are resolved using a namespace:name pattern: foundation:core \u2192 Built-in foundation bundle my-collection:my-bundle \u2192 Bundle from a custom collection ./local-bundle \u2192 Relative path to a local bundle file","title":"Include Resolution"},{"location":"concepts/bundles.html#composition-order","text":"When multiple bundles are composed, they're processed in order: Base bundles (from includes ) are loaded first Each included bundle's includes are resolved recursively The current bundle's configuration is applied last Later configurations can override earlier ones","title":"Composition Order"},{"location":"concepts/bundles.html#behaviors","text":"Behaviors are reusable capability definitions that bundles can reference: behaviors : - code-review # Enable code review capabilities - testing # Enable testing capabilities - documentation # Enable documentation generation Behaviors differ from includes in that they represent specific capabilities rather than complete bundle configurations. A behavior might enable certain tools, add specific instructions, or configure particular patterns.","title":"Behaviors"},{"location":"concepts/bundles.html#practical-composition-example","text":"Here's how you might compose a code review bundle: --- id : team-code-review name : Team Code Review includes : - foundation:core - foundation:git-ops behaviors : - code-review - security-review --- # Team Code Review Use this bundle when reviewing pull requests for our team. ## Review Checklist 1. Check for security vulnerabilities 2. Verify test coverage 3. Ensure code follows our style guide 4. Look for performance issues ## Our Standards - All functions must have docstrings - Maximum cyclomatic complexity : 10 - No hardcoded secrets","title":"Practical Composition Example"},{"location":"concepts/bundles.html#creating-a-bundle","text":"Follow these steps to create your own bundle.","title":"Creating a Bundle"},{"location":"concepts/bundles.html#step-1-define-the-purpose","text":"Before writing any configuration, clearly define: What problem does this bundle solve? Who will use it? What capabilities does it need? What existing bundles can it build on?","title":"Step 1: Define the Purpose"},{"location":"concepts/bundles.html#step-2-choose-your-base","text":"Start by identifying which foundation bundles to include: includes : - foundation:core # Almost always needed Add additional foundations based on your needs: foundation:file-ops for file manipulation foundation:git-ops for version control foundation:web-research for internet access","title":"Step 2: Choose Your Base"},{"location":"concepts/bundles.html#step-3-write-the-frontmatter","text":"Create your bundle file with appropriate metadata: --- id : my-project-helper name : My Project Helper version : 1.0.0 description : Helps with tasks specific to my project includes : - foundation:core - foundation:file-ops behaviors : - testing ---","title":"Step 3: Write the Frontmatter"},{"location":"concepts/bundles.html#step-4-write-instructions","text":"Add clear, specific instructions in the markdown body: # My Project Helper You help developers work on the MyProject codebase. ## Project Structure - `src/` - Source code - `tests/` - Test files - `docs/` - Documentation ## Coding Standards - Use TypeScript strict mode - Write tests for all public functions - Follow the error handling patterns in `src/utils/errors.ts` ## Common Tasks ### Adding a New Feature 1. Create a branch from main 2. Implement the feature in `src/features/` 3. Add tests in `tests/features/` 4. Update documentation if needed","title":"Step 4: Write Instructions"},{"location":"concepts/bundles.html#step-5-test-your-bundle","text":"Test your bundle by running Amplifier with it: amp --bundle ./my-bundle.md Verify that: All includes resolve correctly The AI understands your instructions Tools and capabilities work as expected","title":"Step 5: Test Your Bundle"},{"location":"concepts/bundles.html#step-6-iterate-and-refine","text":"Based on testing, refine your bundle: Add missing instructions Remove unnecessary includes Clarify ambiguous guidance Add examples for complex tasks","title":"Step 6: Iterate and Refine"},{"location":"concepts/bundles.html#best-practices","text":"","title":"Best Practices"},{"location":"concepts/bundles.html#keep-bundles-focused","text":"Each bundle should have a clear, singular purpose. If you find yourself adding unrelated capabilities, consider splitting into multiple bundles.","title":"Keep Bundles Focused"},{"location":"concepts/bundles.html#use-semantic-versioning","text":"Version your bundles to track changes: Major : Breaking changes to behavior or structure Minor : New capabilities, backward compatible Patch : Bug fixes and documentation updates","title":"Use Semantic Versioning"},{"location":"concepts/bundles.html#document-your-bundles","text":"Include clear documentation in the markdown body: What the bundle does How to use it effectively What it doesn't do (scope boundaries) Examples of common tasks","title":"Document Your Bundles"},{"location":"concepts/bundles.html#leverage-composition","text":"Don't duplicate functionality. If another bundle provides what you need, include it rather than recreating it.","title":"Leverage Composition"},{"location":"concepts/bundles.html#test-with-real-scenarios","text":"Validate your bundle with actual use cases, not just theoretical ones. Real-world testing reveals gaps in instructions and missing capabilities.","title":"Test with Real Scenarios"},{"location":"concepts/bundles.html#key-takeaways","text":"Bundles are composable packages that define AI assistant capabilities through declarative YAML configuration and markdown instructions. Structure matters : Use frontmatter for configuration (id, includes, behaviors) and markdown for instructions and context. Composition over duplication : Build on existing bundles using includes rather than recreating functionality. Follow the thin bundle pattern. Behaviors extend capabilities : Reference behaviors to add specific capabilities without including full bundle configurations. Start minimal : Begin with the smallest set of includes and behaviors needed, then add more as requirements emerge. Instructions are key : The markdown body is where you differentiate your bundle. Write clear, actionable guidance for the AI. Test iteratively : Create your bundle, test it with real scenarios, and refine based on what you learn. Bundles embody Amplifier's philosophy of modular, composable design. By creating well-structured bundles, you build reusable capabilities that can be shared across projects and teams, enabling consistent AI-powered workflows wherever they're needed.","title":"Key Takeaways"},{"location":"concepts/hooks.html","text":"Understanding Hooks \u00b6 Hooks are the observation layer of the Amplifier ecosystem. They allow you to monitor, react to, and extend agent behavior without modifying core logic. Think of hooks as event listeners that tap into the agent lifecycle at specific points. What is a Hook? \u00b6 A hook is a lifecycle observer that receives notifications about events occurring during agent execution. Unlike tools that perform actions, hooks observe and react to what's already happening. from amplifier import Hook , HookContext class LoggingHook ( Hook ): \"\"\"Simple hook that logs all events.\"\"\" async def on_event ( self , ctx : HookContext ) -> None : print ( f \"[ { ctx . event_type } ] { ctx . timestamp } : { ctx . data } \" ) Hooks are passive by design. They receive event data, can perform side effects (logging, metrics, notifications), but they don't modify the agent's execution flow. This separation keeps your agent logic clean while enabling rich observability. Key Characteristics \u00b6 Non-blocking : Hooks should complete quickly to avoid slowing the agent Read-only context : Hooks observe events but don't modify them Fail-safe : Hook failures don't crash the agent Ordered execution : Multiple hooks run in registration order Hook vs Tool \u00b6 Understanding the difference between hooks and tools is fundamental: Aspect Hook Tool Purpose Observe and react Perform actions Invocation Automatic on events Explicit by agent Modifies state No (observation only) Yes (side effects expected) Blocking Should be fast Can be long-running Failure impact Logged, continues Reported to agent Use a hook when you want to: - Log or audit agent activity - Collect metrics and telemetry - Send notifications on specific events - Validate or monitor behavior patterns Use a tool when you need to: - Perform an action the agent requests - Return data the agent will use - Modify external state - Execute long-running operations Event Types \u00b6 Hooks subscribe to specific event types that occur during the agent lifecycle: Session Events \u00b6 class SessionEvents : SESSION_START = \"session.start\" # Agent session begins SESSION_END = \"session.end\" # Agent session completes SESSION_ERROR = \"session.error\" # Unhandled error in session Message Events \u00b6 class MessageEvents : USER_MESSAGE = \"message.user\" # User sends a message ASSISTANT_MESSAGE = \"message.assistant\" # Agent responds SYSTEM_MESSAGE = \"message.system\" # System injects context Tool Events \u00b6 class ToolEvents : TOOL_CALL = \"tool.call\" # Agent invokes a tool TOOL_RESULT = \"tool.result\" # Tool returns a result TOOL_ERROR = \"tool.error\" # Tool execution fails LLM Events \u00b6 class LLMEvents : LLM_REQUEST = \"llm.request\" # Request sent to LLM LLM_RESPONSE = \"llm.response\" # Response received from LLM LLM_STREAM_CHUNK = \"llm.stream\" # Streaming chunk received Built-in Hooks \u00b6 Amplifier provides several hooks out of the box for common observability needs: ConsoleLoggingHook \u00b6 Logs all events to the console with configurable verbosity: from amplifier.hooks import ConsoleLoggingHook hook = ConsoleLoggingHook ( level = \"INFO\" , include_events = [ \"tool.call\" , \"tool.result\" ] ) MetricsHook \u00b6 Collects timing and count metrics for analysis: from amplifier.hooks import MetricsHook hook = MetricsHook () # After session, access metrics print ( hook . metrics . tool_call_count ) print ( hook . metrics . avg_response_time ) FileAuditHook \u00b6 Writes a complete audit trail to a file: from amplifier.hooks import FileAuditHook hook = FileAuditHook ( path = \"./logs/session- {session_id} .jsonl\" , include_content = True # Include full message content ) WebhookNotifierHook \u00b6 Sends HTTP notifications on specific events: from amplifier.hooks import WebhookNotifierHook hook = WebhookNotifierHook ( url = \"https://api.example.com/events\" , events = [ \"session.end\" , \"tool.error\" ], headers = { \"Authorization\" : \"Bearer token\" } ) Creating Hooks \u00b6 Building custom hooks is straightforward. Extend the base Hook class and implement the methods you need: Basic Hook Structure \u00b6 from amplifier import Hook , HookContext class MyCustomHook ( Hook ): \"\"\"A custom hook with selective event handling.\"\"\" def __init__ ( self , config : dict = None ): self . config = config or {} self . event_count = 0 @property def subscribed_events ( self ) -> list [ str ]: \"\"\"Specify which events this hook receives.\"\"\" return [ \"tool.call\" , \"tool.result\" , \"session.end\" ] async def on_event ( self , ctx : HookContext ) -> None : \"\"\"Handle incoming events.\"\"\" self . event_count += 1 if ctx . event_type == \"tool.call\" : await self . _handle_tool_call ( ctx ) elif ctx . event_type == \"session.end\" : await self . _handle_session_end ( ctx ) async def _handle_tool_call ( self , ctx : HookContext ) -> None : tool_name = ctx . data . get ( \"tool_name\" ) print ( f \"Tool called: { tool_name } \" ) async def _handle_session_end ( self , ctx : HookContext ) -> None : print ( f \"Session ended. Total events observed: { self . event_count } \" ) Registering Hooks \u00b6 Register hooks when configuring your agent: from amplifier import Agent agent = Agent ( hooks = [ ConsoleLoggingHook (), MyCustomHook ({ \"verbose\" : True }), MetricsHook () ] ) Hook Context \u00b6 The HookContext object provides rich information about each event: class HookContext : event_type : str # The event type (e.g., \"tool.call\") timestamp : datetime # When the event occurred session_id : str # Current session identifier data : dict # Event-specific payload metadata : dict # Additional context (user_id, etc.) Best Practices \u00b6 Keep hooks fast : Offload heavy work to background tasks Handle errors gracefully : Don't let hook failures affect the agent Be selective : Subscribe only to events you need Use async patterns : Leverage async for I/O operations async def on_event ( self , ctx : HookContext ) -> None : try : # Quick validation if not self . _should_process ( ctx ): return # Offload heavy work asyncio . create_task ( self . _process_async ( ctx )) except Exception as e : # Log but don't raise logger . warning ( f \"Hook error: { e } \" ) Key Takeaways \u00b6 Hooks are observers : They watch the agent lifecycle without modifying it. Use them for logging, metrics, notifications, and auditing. Hooks complement tools : While tools perform actions for the agent, hooks monitor what's happening. Both are essential for production systems. Event types are granular : Subscribe to specific events like tool.call or session.end rather than receiving everything. Built-in hooks cover common cases : Use ConsoleLoggingHook , MetricsHook , and FileAuditHook before building custom solutions. Custom hooks are simple : Extend Hook , specify subscribed_events , and implement on_event . Keep them fast and error-tolerant. Observability enables reliability : Hooks provide the visibility needed to debug, optimize, and trust your agent systems in production. Hooks transform opaque agent execution into transparent, observable systems. Start with built-in hooks to understand behavior, then create custom hooks as your monitoring needs evolve.","title":"Hooks"},{"location":"concepts/hooks.html#understanding-hooks","text":"Hooks are the observation layer of the Amplifier ecosystem. They allow you to monitor, react to, and extend agent behavior without modifying core logic. Think of hooks as event listeners that tap into the agent lifecycle at specific points.","title":"Understanding Hooks"},{"location":"concepts/hooks.html#what-is-a-hook","text":"A hook is a lifecycle observer that receives notifications about events occurring during agent execution. Unlike tools that perform actions, hooks observe and react to what's already happening. from amplifier import Hook , HookContext class LoggingHook ( Hook ): \"\"\"Simple hook that logs all events.\"\"\" async def on_event ( self , ctx : HookContext ) -> None : print ( f \"[ { ctx . event_type } ] { ctx . timestamp } : { ctx . data } \" ) Hooks are passive by design. They receive event data, can perform side effects (logging, metrics, notifications), but they don't modify the agent's execution flow. This separation keeps your agent logic clean while enabling rich observability.","title":"What is a Hook?"},{"location":"concepts/hooks.html#key-characteristics","text":"Non-blocking : Hooks should complete quickly to avoid slowing the agent Read-only context : Hooks observe events but don't modify them Fail-safe : Hook failures don't crash the agent Ordered execution : Multiple hooks run in registration order","title":"Key Characteristics"},{"location":"concepts/hooks.html#hook-vs-tool","text":"Understanding the difference between hooks and tools is fundamental: Aspect Hook Tool Purpose Observe and react Perform actions Invocation Automatic on events Explicit by agent Modifies state No (observation only) Yes (side effects expected) Blocking Should be fast Can be long-running Failure impact Logged, continues Reported to agent Use a hook when you want to: - Log or audit agent activity - Collect metrics and telemetry - Send notifications on specific events - Validate or monitor behavior patterns Use a tool when you need to: - Perform an action the agent requests - Return data the agent will use - Modify external state - Execute long-running operations","title":"Hook vs Tool"},{"location":"concepts/hooks.html#event-types","text":"Hooks subscribe to specific event types that occur during the agent lifecycle:","title":"Event Types"},{"location":"concepts/hooks.html#session-events","text":"class SessionEvents : SESSION_START = \"session.start\" # Agent session begins SESSION_END = \"session.end\" # Agent session completes SESSION_ERROR = \"session.error\" # Unhandled error in session","title":"Session Events"},{"location":"concepts/hooks.html#message-events","text":"class MessageEvents : USER_MESSAGE = \"message.user\" # User sends a message ASSISTANT_MESSAGE = \"message.assistant\" # Agent responds SYSTEM_MESSAGE = \"message.system\" # System injects context","title":"Message Events"},{"location":"concepts/hooks.html#tool-events","text":"class ToolEvents : TOOL_CALL = \"tool.call\" # Agent invokes a tool TOOL_RESULT = \"tool.result\" # Tool returns a result TOOL_ERROR = \"tool.error\" # Tool execution fails","title":"Tool Events"},{"location":"concepts/hooks.html#llm-events","text":"class LLMEvents : LLM_REQUEST = \"llm.request\" # Request sent to LLM LLM_RESPONSE = \"llm.response\" # Response received from LLM LLM_STREAM_CHUNK = \"llm.stream\" # Streaming chunk received","title":"LLM Events"},{"location":"concepts/hooks.html#built-in-hooks","text":"Amplifier provides several hooks out of the box for common observability needs:","title":"Built-in Hooks"},{"location":"concepts/hooks.html#consolelogginghook","text":"Logs all events to the console with configurable verbosity: from amplifier.hooks import ConsoleLoggingHook hook = ConsoleLoggingHook ( level = \"INFO\" , include_events = [ \"tool.call\" , \"tool.result\" ] )","title":"ConsoleLoggingHook"},{"location":"concepts/hooks.html#metricshook","text":"Collects timing and count metrics for analysis: from amplifier.hooks import MetricsHook hook = MetricsHook () # After session, access metrics print ( hook . metrics . tool_call_count ) print ( hook . metrics . avg_response_time )","title":"MetricsHook"},{"location":"concepts/hooks.html#fileaudithook","text":"Writes a complete audit trail to a file: from amplifier.hooks import FileAuditHook hook = FileAuditHook ( path = \"./logs/session- {session_id} .jsonl\" , include_content = True # Include full message content )","title":"FileAuditHook"},{"location":"concepts/hooks.html#webhooknotifierhook","text":"Sends HTTP notifications on specific events: from amplifier.hooks import WebhookNotifierHook hook = WebhookNotifierHook ( url = \"https://api.example.com/events\" , events = [ \"session.end\" , \"tool.error\" ], headers = { \"Authorization\" : \"Bearer token\" } )","title":"WebhookNotifierHook"},{"location":"concepts/hooks.html#creating-hooks","text":"Building custom hooks is straightforward. Extend the base Hook class and implement the methods you need:","title":"Creating Hooks"},{"location":"concepts/hooks.html#basic-hook-structure","text":"from amplifier import Hook , HookContext class MyCustomHook ( Hook ): \"\"\"A custom hook with selective event handling.\"\"\" def __init__ ( self , config : dict = None ): self . config = config or {} self . event_count = 0 @property def subscribed_events ( self ) -> list [ str ]: \"\"\"Specify which events this hook receives.\"\"\" return [ \"tool.call\" , \"tool.result\" , \"session.end\" ] async def on_event ( self , ctx : HookContext ) -> None : \"\"\"Handle incoming events.\"\"\" self . event_count += 1 if ctx . event_type == \"tool.call\" : await self . _handle_tool_call ( ctx ) elif ctx . event_type == \"session.end\" : await self . _handle_session_end ( ctx ) async def _handle_tool_call ( self , ctx : HookContext ) -> None : tool_name = ctx . data . get ( \"tool_name\" ) print ( f \"Tool called: { tool_name } \" ) async def _handle_session_end ( self , ctx : HookContext ) -> None : print ( f \"Session ended. Total events observed: { self . event_count } \" )","title":"Basic Hook Structure"},{"location":"concepts/hooks.html#registering-hooks","text":"Register hooks when configuring your agent: from amplifier import Agent agent = Agent ( hooks = [ ConsoleLoggingHook (), MyCustomHook ({ \"verbose\" : True }), MetricsHook () ] )","title":"Registering Hooks"},{"location":"concepts/hooks.html#hook-context","text":"The HookContext object provides rich information about each event: class HookContext : event_type : str # The event type (e.g., \"tool.call\") timestamp : datetime # When the event occurred session_id : str # Current session identifier data : dict # Event-specific payload metadata : dict # Additional context (user_id, etc.)","title":"Hook Context"},{"location":"concepts/hooks.html#best-practices","text":"Keep hooks fast : Offload heavy work to background tasks Handle errors gracefully : Don't let hook failures affect the agent Be selective : Subscribe only to events you need Use async patterns : Leverage async for I/O operations async def on_event ( self , ctx : HookContext ) -> None : try : # Quick validation if not self . _should_process ( ctx ): return # Offload heavy work asyncio . create_task ( self . _process_async ( ctx )) except Exception as e : # Log but don't raise logger . warning ( f \"Hook error: { e } \" )","title":"Best Practices"},{"location":"concepts/hooks.html#key-takeaways","text":"Hooks are observers : They watch the agent lifecycle without modifying it. Use them for logging, metrics, notifications, and auditing. Hooks complement tools : While tools perform actions for the agent, hooks monitor what's happening. Both are essential for production systems. Event types are granular : Subscribe to specific events like tool.call or session.end rather than receiving everything. Built-in hooks cover common cases : Use ConsoleLoggingHook , MetricsHook , and FileAuditHook before building custom solutions. Custom hooks are simple : Extend Hook , specify subscribed_events , and implement on_event . Keep them fast and error-tolerant. Observability enables reliability : Hooks provide the visibility needed to debug, optimize, and trust your agent systems in production. Hooks transform opaque agent execution into transparent, observable systems. Start with built-in hooks to understand behavior, then create custom hooks as your monitoring needs evolve.","title":"Key Takeaways"},{"location":"concepts/modules.html","text":"Understanding Modules \u00b6 What is a Module? \u00b6 A module is a pluggable component that extends your agent's capabilities. Think of modules as LEGO blocks\u2014each one serves a specific purpose, and you can mix and match them to build the exact agent you need. Modules are the foundation of the framework's architecture. Instead of building a monolithic agent with hardcoded behaviors, you compose your agent from independent, reusable modules. This design makes your agent: Flexible : Swap modules without rewriting code Testable : Test each module in isolation Maintainable : Update one module without breaking others Extensible : Add new capabilities by adding modules Every module in the system implements a specific interface (or \"contract\") that defines how it communicates with the rest of the agent. This contract ensures that modules work together seamlessly, regardless of who wrote them or when they were created. The Module Lifecycle \u00b6 When an agent starts, it: Loads all configured modules Initializes them with configuration Registers them with the appropriate systems Executes them during the agent loop Cleans up when the agent shuts down Modules can maintain state between invocations, access shared resources, and communicate with each other through well-defined interfaces. The 5 Module Types \u00b6 The framework defines five core module types, each serving a distinct architectural role: Type Purpose Contract Provider LLM backends complete() Tool Agent capabilities execute() Orchestrator Main engine The loop Context Memory messages Hook Observers events Provider Modules \u00b6 Purpose : Connect to language model backends Providers abstract away the details of different LLM APIs (OpenAI, Anthropic, local models, etc.). They implement a single complete() method that takes a conversation history and returns the next response. Example use cases : - OpenAI GPT-4 provider - Anthropic Claude provider - Local Llama model provider - Custom fine-tuned model provider Key characteristics : - Stateless request/response - Handles authentication and rate limiting - Transforms between framework format and API format - Supports streaming responses class Provider : def complete ( self , messages : list ) -> Response : \"\"\"Generate next response from conversation history\"\"\" pass Tool Modules \u00b6 Purpose : Give your agent capabilities to interact with the world Tools are functions that the LLM can call to perform actions\u2014reading files, searching the web, executing code, querying databases, etc. The LLM decides which tool to use based on the conversation context. Example use cases : - File system operations (read, write, edit) - Web search and scraping - Database queries - API integrations - Code execution Key characteristics : - LLM-triggered (agent decides when to use) - Synchronous or asynchronous execution - Structured input parameters - Returns results to the LLM class Tool : def execute ( self , ** params ) -> dict : \"\"\"Execute the tool with given parameters\"\"\" pass Orchestrator Modules \u00b6 Purpose : Control the main agent loop The orchestrator is the \"brain\" of your agent. It manages the conversation flow, decides when to call the LLM, processes tool calls, handles errors, and determines when the agent's work is complete. Example use cases : - Simple loop (call LLM \u2192 execute tools \u2192 repeat) - Tree search orchestrator (explore multiple paths) - Reflection orchestrator (self-critique and improve) - Multi-agent orchestrator (coordinate multiple agents) Key characteristics : - Runs the main agent loop - Manages state and conversation history - Decides when to stop - Handles errors and retries class Orchestrator : def run ( self ) -> Result : \"\"\"Execute the main agent loop\"\"\" while not self . is_complete (): response = self . provider . complete ( self . context . messages ) self . process_response ( response ) return self . result Context Modules \u00b6 Purpose : Manage conversation memory and state Context modules store and organize the conversation history. They decide what information to keep, what to summarize, and what to discard. This is crucial for long conversations where the full history exceeds the LLM's context window. Example use cases : - Simple in-memory context (store all messages) - Sliding window context (keep last N messages) - Semantic context (keep most relevant messages) - Persistent context (save to database) Key characteristics : - Stores conversation messages - Provides access to history - May implement compression or summarization - Can persist across sessions class Context : @property def messages ( self ) -> list : \"\"\"Get current conversation history\"\"\" pass def add_message ( self , message : dict ): \"\"\"Add message to history\"\"\" pass Hook Modules \u00b6 Purpose : Observe and react to agent events Hooks are passive observers that get notified when specific events occur in the agent's lifecycle. Unlike tools (which the LLM chooses to use), hooks are triggered by code events automatically. Example use cases : - Logging and debugging - Performance monitoring - Cost tracking - Safety guardrails - Analytics and telemetry Key characteristics : - Code-triggered (not LLM-triggered) - Cannot be chosen by the agent - Observe without blocking - Multiple hooks can respond to same event class Hook : def on_event ( self , event : Event ): \"\"\"Handle an agent event\"\"\" pass Tool vs Hook \u00b6 Understanding the difference between Tools and Hooks is crucial for proper module design: Tool Hook Triggered by LLM decides Code events Choosable Yes, agent picks from available tools No, always runs on events Blocks execution Yes, agent waits for result No, runs async or returns quickly Returns value Yes, result goes to LLM No, side effects only Example \"search_web\" tool called when agent needs info Logging hook records all LLM calls When to Use a Tool \u00b6 Create a Tool when: - The agent should decide when to use it - The action produces a result the LLM needs - It's an explicit capability you want to advertise Example : A read_file tool that the agent calls when it needs to see file contents. When to Use a Hook \u00b6 Create a Hook when: - The action should happen automatically on events - It's an observation or side effect, not a core capability - You want to monitor or modify agent behavior Example : A cost_tracker hook that logs every LLM API call to track spending. Can It Be Both? \u00b6 Sometimes! You might have a Hook that monitors for unsafe behavior AND a Tool that lets the agent explicitly check safety. The key is understanding the use case: Tool version : \"Is this action safe?\" (agent decides to check) Hook version : \"Log every action and alert on unsafe patterns\" (always runs) Module Configuration \u00b6 Modules are typically configured in a YAML or JSON file: modules : provider : type : openai model : gpt-4 tools : - name : file_ops enabled : true - name : web_search api_key : ${SEARCH_API_KEY} orchestrator : type : simple_loop max_iterations : 20 context : type : sliding_window window_size : 10 hooks : - name : logger level : info - name : cost_tracker alert_threshold : 10.00 Creating Custom Modules \u00b6 To create a custom module: Choose the right type based on architectural role Implement the contract (required interface) Register with the framework (add to config) Test in isolation before integration Each module type has a base class you extend: from framework import ToolModule class MyCustomTool ( ToolModule ): name = \"my_tool\" description = \"What this tool does\" parameters = { \"param1\" : { \"type\" : \"string\" , \"description\" : \"...\" }, \"param2\" : { \"type\" : \"number\" , \"description\" : \"...\" } } def execute ( self , param1 : str , param2 : int ) -> dict : # Your implementation result = self . do_something ( param1 , param2 ) return { \"result\" : result } Key Takeaways \u00b6 Modules are pluggable components that extend agent capabilities through well-defined interfaces Five module types serve different architectural roles: Provider (LLM), Tool (capabilities), Orchestrator (loop), Context (memory), Hook (observers) Tools vs Hooks : Tools are chosen by the LLM and return results; Hooks are triggered by code events for observation Composition over inheritance : Build agents by combining modules rather than writing monolithic code Each module has a contract : Implement the required interface, and your module works with the framework Modules enable reusability : Write once, use across multiple agents and projects Testing is easier : Test each module independently before integration Configuration-driven : Change agent behavior by swapping modules in config, not code The modular architecture is what makes the framework powerful and flexible. By understanding these five module types and their roles, you can build sophisticated agents that are maintainable, testable, and extensible. Start simple\u2014use built-in modules first, then create custom modules as you understand the patterns. The framework handles the complexity of wiring modules together, so you can focus on building great capabilities.","title":"Modules"},{"location":"concepts/modules.html#understanding-modules","text":"","title":"Understanding Modules"},{"location":"concepts/modules.html#what-is-a-module","text":"A module is a pluggable component that extends your agent's capabilities. Think of modules as LEGO blocks\u2014each one serves a specific purpose, and you can mix and match them to build the exact agent you need. Modules are the foundation of the framework's architecture. Instead of building a monolithic agent with hardcoded behaviors, you compose your agent from independent, reusable modules. This design makes your agent: Flexible : Swap modules without rewriting code Testable : Test each module in isolation Maintainable : Update one module without breaking others Extensible : Add new capabilities by adding modules Every module in the system implements a specific interface (or \"contract\") that defines how it communicates with the rest of the agent. This contract ensures that modules work together seamlessly, regardless of who wrote them or when they were created.","title":"What is a Module?"},{"location":"concepts/modules.html#the-module-lifecycle","text":"When an agent starts, it: Loads all configured modules Initializes them with configuration Registers them with the appropriate systems Executes them during the agent loop Cleans up when the agent shuts down Modules can maintain state between invocations, access shared resources, and communicate with each other through well-defined interfaces.","title":"The Module Lifecycle"},{"location":"concepts/modules.html#the-5-module-types","text":"The framework defines five core module types, each serving a distinct architectural role: Type Purpose Contract Provider LLM backends complete() Tool Agent capabilities execute() Orchestrator Main engine The loop Context Memory messages Hook Observers events","title":"The 5 Module Types"},{"location":"concepts/modules.html#provider-modules","text":"Purpose : Connect to language model backends Providers abstract away the details of different LLM APIs (OpenAI, Anthropic, local models, etc.). They implement a single complete() method that takes a conversation history and returns the next response. Example use cases : - OpenAI GPT-4 provider - Anthropic Claude provider - Local Llama model provider - Custom fine-tuned model provider Key characteristics : - Stateless request/response - Handles authentication and rate limiting - Transforms between framework format and API format - Supports streaming responses class Provider : def complete ( self , messages : list ) -> Response : \"\"\"Generate next response from conversation history\"\"\" pass","title":"Provider Modules"},{"location":"concepts/modules.html#tool-modules","text":"Purpose : Give your agent capabilities to interact with the world Tools are functions that the LLM can call to perform actions\u2014reading files, searching the web, executing code, querying databases, etc. The LLM decides which tool to use based on the conversation context. Example use cases : - File system operations (read, write, edit) - Web search and scraping - Database queries - API integrations - Code execution Key characteristics : - LLM-triggered (agent decides when to use) - Synchronous or asynchronous execution - Structured input parameters - Returns results to the LLM class Tool : def execute ( self , ** params ) -> dict : \"\"\"Execute the tool with given parameters\"\"\" pass","title":"Tool Modules"},{"location":"concepts/modules.html#orchestrator-modules","text":"Purpose : Control the main agent loop The orchestrator is the \"brain\" of your agent. It manages the conversation flow, decides when to call the LLM, processes tool calls, handles errors, and determines when the agent's work is complete. Example use cases : - Simple loop (call LLM \u2192 execute tools \u2192 repeat) - Tree search orchestrator (explore multiple paths) - Reflection orchestrator (self-critique and improve) - Multi-agent orchestrator (coordinate multiple agents) Key characteristics : - Runs the main agent loop - Manages state and conversation history - Decides when to stop - Handles errors and retries class Orchestrator : def run ( self ) -> Result : \"\"\"Execute the main agent loop\"\"\" while not self . is_complete (): response = self . provider . complete ( self . context . messages ) self . process_response ( response ) return self . result","title":"Orchestrator Modules"},{"location":"concepts/modules.html#context-modules","text":"Purpose : Manage conversation memory and state Context modules store and organize the conversation history. They decide what information to keep, what to summarize, and what to discard. This is crucial for long conversations where the full history exceeds the LLM's context window. Example use cases : - Simple in-memory context (store all messages) - Sliding window context (keep last N messages) - Semantic context (keep most relevant messages) - Persistent context (save to database) Key characteristics : - Stores conversation messages - Provides access to history - May implement compression or summarization - Can persist across sessions class Context : @property def messages ( self ) -> list : \"\"\"Get current conversation history\"\"\" pass def add_message ( self , message : dict ): \"\"\"Add message to history\"\"\" pass","title":"Context Modules"},{"location":"concepts/modules.html#hook-modules","text":"Purpose : Observe and react to agent events Hooks are passive observers that get notified when specific events occur in the agent's lifecycle. Unlike tools (which the LLM chooses to use), hooks are triggered by code events automatically. Example use cases : - Logging and debugging - Performance monitoring - Cost tracking - Safety guardrails - Analytics and telemetry Key characteristics : - Code-triggered (not LLM-triggered) - Cannot be chosen by the agent - Observe without blocking - Multiple hooks can respond to same event class Hook : def on_event ( self , event : Event ): \"\"\"Handle an agent event\"\"\" pass","title":"Hook Modules"},{"location":"concepts/modules.html#tool-vs-hook","text":"Understanding the difference between Tools and Hooks is crucial for proper module design: Tool Hook Triggered by LLM decides Code events Choosable Yes, agent picks from available tools No, always runs on events Blocks execution Yes, agent waits for result No, runs async or returns quickly Returns value Yes, result goes to LLM No, side effects only Example \"search_web\" tool called when agent needs info Logging hook records all LLM calls","title":"Tool vs Hook"},{"location":"concepts/modules.html#when-to-use-a-tool","text":"Create a Tool when: - The agent should decide when to use it - The action produces a result the LLM needs - It's an explicit capability you want to advertise Example : A read_file tool that the agent calls when it needs to see file contents.","title":"When to Use a Tool"},{"location":"concepts/modules.html#when-to-use-a-hook","text":"Create a Hook when: - The action should happen automatically on events - It's an observation or side effect, not a core capability - You want to monitor or modify agent behavior Example : A cost_tracker hook that logs every LLM API call to track spending.","title":"When to Use a Hook"},{"location":"concepts/modules.html#can-it-be-both","text":"Sometimes! You might have a Hook that monitors for unsafe behavior AND a Tool that lets the agent explicitly check safety. The key is understanding the use case: Tool version : \"Is this action safe?\" (agent decides to check) Hook version : \"Log every action and alert on unsafe patterns\" (always runs)","title":"Can It Be Both?"},{"location":"concepts/modules.html#module-configuration","text":"Modules are typically configured in a YAML or JSON file: modules : provider : type : openai model : gpt-4 tools : - name : file_ops enabled : true - name : web_search api_key : ${SEARCH_API_KEY} orchestrator : type : simple_loop max_iterations : 20 context : type : sliding_window window_size : 10 hooks : - name : logger level : info - name : cost_tracker alert_threshold : 10.00","title":"Module Configuration"},{"location":"concepts/modules.html#creating-custom-modules","text":"To create a custom module: Choose the right type based on architectural role Implement the contract (required interface) Register with the framework (add to config) Test in isolation before integration Each module type has a base class you extend: from framework import ToolModule class MyCustomTool ( ToolModule ): name = \"my_tool\" description = \"What this tool does\" parameters = { \"param1\" : { \"type\" : \"string\" , \"description\" : \"...\" }, \"param2\" : { \"type\" : \"number\" , \"description\" : \"...\" } } def execute ( self , param1 : str , param2 : int ) -> dict : # Your implementation result = self . do_something ( param1 , param2 ) return { \"result\" : result }","title":"Creating Custom Modules"},{"location":"concepts/modules.html#key-takeaways","text":"Modules are pluggable components that extend agent capabilities through well-defined interfaces Five module types serve different architectural roles: Provider (LLM), Tool (capabilities), Orchestrator (loop), Context (memory), Hook (observers) Tools vs Hooks : Tools are chosen by the LLM and return results; Hooks are triggered by code events for observation Composition over inheritance : Build agents by combining modules rather than writing monolithic code Each module has a contract : Implement the required interface, and your module works with the framework Modules enable reusability : Write once, use across multiple agents and projects Testing is easier : Test each module independently before integration Configuration-driven : Change agent behavior by swapping modules in config, not code The modular architecture is what makes the framework powerful and flexible. By understanding these five module types and their roles, you can build sophisticated agents that are maintainable, testable, and extensible. Start simple\u2014use built-in modules first, then create custom modules as you understand the patterns. The framework handles the complexity of wiring modules together, so you can focus on building great capabilities.","title":"Key Takeaways"},{"location":"concepts/recipes.html","text":"Understanding Recipes \u00b6 Recipes are declarative YAML specifications that define multi-step AI agent workflows. They provide a structured way to orchestrate complex tasks that require multiple sequential or parallel operations, with built-in support for state persistence, error handling, and human approval gates. What is a Recipe? \u00b6 A recipe is essentially a blueprint for AI-assisted work. Rather than manually guiding an agent through each step of a complex process, you define the entire workflow upfront in a YAML file. The recipe system then executes each step in order, passing context between steps and handling failures gracefully. Think of recipes like cooking recipes: they specify ingredients (context), steps (operations), and expected outcomes. Just as a cooking recipe ensures consistent results regardless of who follows it, an agent recipe ensures consistent, reproducible workflows. Core Characteristics \u00b6 Declarative : You specify what should happen, not how to do it. The recipe executor handles the mechanics of step execution, context management, and error recovery. Sequential with State : Each step can access the accumulated context from all previous steps. This creates a natural flow where early steps gather information that later steps act upon. Resumable : If a recipe is interrupted (network failure, timeout, manual stop), it can be resumed from the last successful checkpoint. No work is lost. Composable : Recipes can be simple (3-4 steps) or complex (dozens of steps with conditional branching). You build what you need. When to Use Recipes \u00b6 Recipes shine in scenarios where manual orchestration would be tedious, error-prone, or inconsistent. Ideal Use Cases \u00b6 Code Review Workflows : A recipe can analyze code changes, check for security issues, verify test coverage, and generate a comprehensive review report - all in one automated flow. Research and Synthesis : Gather information from multiple sources, analyze patterns, synthesize findings, and produce a structured report. Multi-Stage Deployments : Validate configuration, run tests, build artifacts, deploy to staging, run smoke tests, and optionally promote to production. Document Generation : Analyze a codebase, extract documentation, generate API references, and compile everything into a cohesive document. Refactoring Operations : Analyze current code, identify patterns to change, plan modifications, execute changes across files, and verify results. When NOT to Use Recipes \u00b6 Simple one-shot tasks : If a single agent call suffices, skip the recipe overhead Highly interactive work : Recipes are designed for autonomous execution, not back-and-forth conversation Exploratory tasks : When you don't know the steps upfront, manual guidance is better Recipe Structure \u00b6 A recipe file has a clear structure with metadata, context, and steps. Basic Anatomy \u00b6 # Recipe metadata name : code-review description : Comprehensive code review workflow version : \"1.0\" # Input context (variables passed at execution time) context : required : - file_path # Path to file being reviewed optional : - focus_areas # Specific areas to emphasize # The workflow steps steps : - name : analyze-structure agent : foundation:explorer prompt : | Analyze the structure of {{ file_path }}. Identify key components, dependencies, and patterns. - name : security-check agent : foundation:security-guardian prompt : | Review {{ file_path }} for security vulnerabilities. Previous analysis: {{ steps.analyze-structure.result }} - name : generate-report agent : foundation:file-ops prompt : | Generate a code review report based on: - Structure analysis: {{ steps.analyze-structure.result }} - Security findings: {{ steps.security-check.result }} Key Elements \u00b6 name : A unique identifier for the recipe. Used for execution and logging. description : Human-readable explanation of what the recipe does. context : Defines inputs the recipe expects. Required context must be provided at execution time; optional context has defaults or can be omitted. steps : The ordered list of operations to execute. Each step has a name, an agent to invoke, and a prompt template. Steps and Context \u00b6 Steps are the building blocks of recipes. Each step represents a discrete unit of work performed by an agent. Step Definition \u00b6 steps : - name : step-identifier # Unique name within recipe agent : foundation:explorer # Agent to invoke prompt : | # Instructions for the agent Your task description here. You can reference context: {{ variable_name }} And previous results: {{ steps.previous-step.result }} Context Flow \u00b6 Context flows through recipes in a predictable way: Initial Context : Variables provided at recipe execution Step Results : Each step's output is stored and accessible to later steps Accumulated State : Later steps have access to all prior results # Step 1 receives initial context - name : gather-info prompt : \"Analyze {{ target_directory }}\" # target_directory from initial context # Step 2 receives initial context + step 1 results - name : process-info prompt : | Based on: {{ steps.gather-info.result }} Process the information... # Step 3 receives everything - name : synthesize prompt : | Original target: {{ target_directory }} Gathered info: {{ steps.gather-info.result }} Processed info: {{ steps.process-info.result }} Template Syntax \u00b6 Recipes use Jinja2-style templating for dynamic content: {{ variable }} : Insert a context variable {{ steps.step-name.result }} : Insert a previous step's result {{ context.required_var }} : Explicitly reference required context Step Options \u00b6 Steps support additional configuration: - name : critical-operation agent : foundation:modular-builder prompt : \"Implement the feature...\" # Error handling on_error : continue # Options: fail (default), continue, retry max_retries : 3 # For retry strategy # Timeouts timeout : 300 # Seconds before timeout # Conditional execution when : \"{{ steps.validation.result.passed }}\" Approval Gates \u00b6 For workflows that require human oversight, recipes support approval gates. These pause execution at critical points, allowing humans to review progress before continuing. Staged Recipes \u00b6 Approval gates are implemented through staged recipes - recipes divided into stages that require explicit approval between them. name : production-deployment description : Deploy to production with approval gates stages : - name : preparation steps : - name : validate-config agent : foundation:explorer prompt : \"Validate deployment configuration...\" - name : run-tests agent : foundation:test-coverage prompt : \"Execute full test suite...\" - name : staging-deployment approval_required : true approval_message : | Preparation complete. Test results: {{ steps.run-tests.result }} Approve to deploy to staging? steps : - name : deploy-staging agent : foundation:modular-builder prompt : \"Deploy to staging environment...\" - name : production-release approval_required : true approval_message : | Staging deployment successful. Approve production release? steps : - name : deploy-production agent : foundation:modular-builder prompt : \"Deploy to production...\" Approval Workflow \u00b6 Recipe executes until it hits a stage with approval_required: true Execution pauses and the approval message is displayed Human reviews the state and either approves or denies On approval: execution continues to the next stage On denial: execution stops with the provided reason Managing Approvals \u00b6 # List pending approvals across all sessions amp recipes approvals # Approve a pending stage amp recipes approve --session-id <id> --stage-name staging-deployment # Deny with reason amp recipes deny --session-id <id> --stage-name production-release \\ --reason \"Test coverage below threshold\" Use Cases for Approval Gates \u00b6 Production deployments : Human sign-off before going live Data migrations : Review migration plan before execution Bulk operations : Approve after seeing what will be affected Compliance workflows : Required human verification for audit trails Advanced Features \u00b6 Foreach Loops \u00b6 Execute steps for each item in a collection: - name : process-files foreach : \"{{ discovered_files }}\" as : current_file steps : - name : analyze agent : foundation:explorer prompt : \"Analyze {{ current_file }}...\" Conditional Steps \u00b6 Skip steps based on conditions: - name : security-scan when : \"{{ context.security_required }}\" agent : foundation:security-guardian prompt : \"Perform security scan...\" Error Recovery \u00b6 Configure how failures are handled: - name : optional-optimization agent : foundation:zen-architect prompt : \"Optimize if possible...\" on_error : continue # Don't fail the whole recipe Key Takeaways \u00b6 Recipes are declarative workflows : Define what you want, not how to do it. The recipe system handles execution mechanics. State flows automatically : Each step can access all previous results. No manual state management required. Resumability is built-in : Interrupted recipes can be resumed. Checkpointing happens automatically. Approval gates enable human oversight : For critical workflows, pause and require human approval before proceeding. Start simple, grow as needed : Begin with linear sequences of steps. Add stages, conditions, and loops only when your workflow demands it. Recipes are reusable : Once defined, a recipe can be executed repeatedly with different inputs. Build a library of workflows for common tasks. Think in discrete steps : Each step should have a clear, focused purpose. Avoid monolithic steps that try to do everything. Recipes transform complex, multi-step processes into repeatable, reliable workflows. They bridge the gap between manual agent interaction and fully automated pipelines, giving you control over the workflow design while letting AI handle the execution.","title":"Recipes"},{"location":"concepts/recipes.html#understanding-recipes","text":"Recipes are declarative YAML specifications that define multi-step AI agent workflows. They provide a structured way to orchestrate complex tasks that require multiple sequential or parallel operations, with built-in support for state persistence, error handling, and human approval gates.","title":"Understanding Recipes"},{"location":"concepts/recipes.html#what-is-a-recipe","text":"A recipe is essentially a blueprint for AI-assisted work. Rather than manually guiding an agent through each step of a complex process, you define the entire workflow upfront in a YAML file. The recipe system then executes each step in order, passing context between steps and handling failures gracefully. Think of recipes like cooking recipes: they specify ingredients (context), steps (operations), and expected outcomes. Just as a cooking recipe ensures consistent results regardless of who follows it, an agent recipe ensures consistent, reproducible workflows.","title":"What is a Recipe?"},{"location":"concepts/recipes.html#core-characteristics","text":"Declarative : You specify what should happen, not how to do it. The recipe executor handles the mechanics of step execution, context management, and error recovery. Sequential with State : Each step can access the accumulated context from all previous steps. This creates a natural flow where early steps gather information that later steps act upon. Resumable : If a recipe is interrupted (network failure, timeout, manual stop), it can be resumed from the last successful checkpoint. No work is lost. Composable : Recipes can be simple (3-4 steps) or complex (dozens of steps with conditional branching). You build what you need.","title":"Core Characteristics"},{"location":"concepts/recipes.html#when-to-use-recipes","text":"Recipes shine in scenarios where manual orchestration would be tedious, error-prone, or inconsistent.","title":"When to Use Recipes"},{"location":"concepts/recipes.html#ideal-use-cases","text":"Code Review Workflows : A recipe can analyze code changes, check for security issues, verify test coverage, and generate a comprehensive review report - all in one automated flow. Research and Synthesis : Gather information from multiple sources, analyze patterns, synthesize findings, and produce a structured report. Multi-Stage Deployments : Validate configuration, run tests, build artifacts, deploy to staging, run smoke tests, and optionally promote to production. Document Generation : Analyze a codebase, extract documentation, generate API references, and compile everything into a cohesive document. Refactoring Operations : Analyze current code, identify patterns to change, plan modifications, execute changes across files, and verify results.","title":"Ideal Use Cases"},{"location":"concepts/recipes.html#when-not-to-use-recipes","text":"Simple one-shot tasks : If a single agent call suffices, skip the recipe overhead Highly interactive work : Recipes are designed for autonomous execution, not back-and-forth conversation Exploratory tasks : When you don't know the steps upfront, manual guidance is better","title":"When NOT to Use Recipes"},{"location":"concepts/recipes.html#recipe-structure","text":"A recipe file has a clear structure with metadata, context, and steps.","title":"Recipe Structure"},{"location":"concepts/recipes.html#basic-anatomy","text":"# Recipe metadata name : code-review description : Comprehensive code review workflow version : \"1.0\" # Input context (variables passed at execution time) context : required : - file_path # Path to file being reviewed optional : - focus_areas # Specific areas to emphasize # The workflow steps steps : - name : analyze-structure agent : foundation:explorer prompt : | Analyze the structure of {{ file_path }}. Identify key components, dependencies, and patterns. - name : security-check agent : foundation:security-guardian prompt : | Review {{ file_path }} for security vulnerabilities. Previous analysis: {{ steps.analyze-structure.result }} - name : generate-report agent : foundation:file-ops prompt : | Generate a code review report based on: - Structure analysis: {{ steps.analyze-structure.result }} - Security findings: {{ steps.security-check.result }}","title":"Basic Anatomy"},{"location":"concepts/recipes.html#key-elements","text":"name : A unique identifier for the recipe. Used for execution and logging. description : Human-readable explanation of what the recipe does. context : Defines inputs the recipe expects. Required context must be provided at execution time; optional context has defaults or can be omitted. steps : The ordered list of operations to execute. Each step has a name, an agent to invoke, and a prompt template.","title":"Key Elements"},{"location":"concepts/recipes.html#steps-and-context","text":"Steps are the building blocks of recipes. Each step represents a discrete unit of work performed by an agent.","title":"Steps and Context"},{"location":"concepts/recipes.html#step-definition","text":"steps : - name : step-identifier # Unique name within recipe agent : foundation:explorer # Agent to invoke prompt : | # Instructions for the agent Your task description here. You can reference context: {{ variable_name }} And previous results: {{ steps.previous-step.result }}","title":"Step Definition"},{"location":"concepts/recipes.html#context-flow","text":"Context flows through recipes in a predictable way: Initial Context : Variables provided at recipe execution Step Results : Each step's output is stored and accessible to later steps Accumulated State : Later steps have access to all prior results # Step 1 receives initial context - name : gather-info prompt : \"Analyze {{ target_directory }}\" # target_directory from initial context # Step 2 receives initial context + step 1 results - name : process-info prompt : | Based on: {{ steps.gather-info.result }} Process the information... # Step 3 receives everything - name : synthesize prompt : | Original target: {{ target_directory }} Gathered info: {{ steps.gather-info.result }} Processed info: {{ steps.process-info.result }}","title":"Context Flow"},{"location":"concepts/recipes.html#template-syntax","text":"Recipes use Jinja2-style templating for dynamic content: {{ variable }} : Insert a context variable {{ steps.step-name.result }} : Insert a previous step's result {{ context.required_var }} : Explicitly reference required context","title":"Template Syntax"},{"location":"concepts/recipes.html#step-options","text":"Steps support additional configuration: - name : critical-operation agent : foundation:modular-builder prompt : \"Implement the feature...\" # Error handling on_error : continue # Options: fail (default), continue, retry max_retries : 3 # For retry strategy # Timeouts timeout : 300 # Seconds before timeout # Conditional execution when : \"{{ steps.validation.result.passed }}\"","title":"Step Options"},{"location":"concepts/recipes.html#approval-gates","text":"For workflows that require human oversight, recipes support approval gates. These pause execution at critical points, allowing humans to review progress before continuing.","title":"Approval Gates"},{"location":"concepts/recipes.html#staged-recipes","text":"Approval gates are implemented through staged recipes - recipes divided into stages that require explicit approval between them. name : production-deployment description : Deploy to production with approval gates stages : - name : preparation steps : - name : validate-config agent : foundation:explorer prompt : \"Validate deployment configuration...\" - name : run-tests agent : foundation:test-coverage prompt : \"Execute full test suite...\" - name : staging-deployment approval_required : true approval_message : | Preparation complete. Test results: {{ steps.run-tests.result }} Approve to deploy to staging? steps : - name : deploy-staging agent : foundation:modular-builder prompt : \"Deploy to staging environment...\" - name : production-release approval_required : true approval_message : | Staging deployment successful. Approve production release? steps : - name : deploy-production agent : foundation:modular-builder prompt : \"Deploy to production...\"","title":"Staged Recipes"},{"location":"concepts/recipes.html#approval-workflow","text":"Recipe executes until it hits a stage with approval_required: true Execution pauses and the approval message is displayed Human reviews the state and either approves or denies On approval: execution continues to the next stage On denial: execution stops with the provided reason","title":"Approval Workflow"},{"location":"concepts/recipes.html#managing-approvals","text":"# List pending approvals across all sessions amp recipes approvals # Approve a pending stage amp recipes approve --session-id <id> --stage-name staging-deployment # Deny with reason amp recipes deny --session-id <id> --stage-name production-release \\ --reason \"Test coverage below threshold\"","title":"Managing Approvals"},{"location":"concepts/recipes.html#use-cases-for-approval-gates","text":"Production deployments : Human sign-off before going live Data migrations : Review migration plan before execution Bulk operations : Approve after seeing what will be affected Compliance workflows : Required human verification for audit trails","title":"Use Cases for Approval Gates"},{"location":"concepts/recipes.html#advanced-features","text":"","title":"Advanced Features"},{"location":"concepts/recipes.html#foreach-loops","text":"Execute steps for each item in a collection: - name : process-files foreach : \"{{ discovered_files }}\" as : current_file steps : - name : analyze agent : foundation:explorer prompt : \"Analyze {{ current_file }}...\"","title":"Foreach Loops"},{"location":"concepts/recipes.html#conditional-steps","text":"Skip steps based on conditions: - name : security-scan when : \"{{ context.security_required }}\" agent : foundation:security-guardian prompt : \"Perform security scan...\"","title":"Conditional Steps"},{"location":"concepts/recipes.html#error-recovery","text":"Configure how failures are handled: - name : optional-optimization agent : foundation:zen-architect prompt : \"Optimize if possible...\" on_error : continue # Don't fail the whole recipe","title":"Error Recovery"},{"location":"concepts/recipes.html#key-takeaways","text":"Recipes are declarative workflows : Define what you want, not how to do it. The recipe system handles execution mechanics. State flows automatically : Each step can access all previous results. No manual state management required. Resumability is built-in : Interrupted recipes can be resumed. Checkpointing happens automatically. Approval gates enable human oversight : For critical workflows, pause and require human approval before proceeding. Start simple, grow as needed : Begin with linear sequences of steps. Add stages, conditions, and loops only when your workflow demands it. Recipes are reusable : Once defined, a recipe can be executed repeatedly with different inputs. Build a library of workflows for common tasks. Think in discrete steps : Each step should have a clear, focused purpose. Avoid monolithic steps that try to do everything. Recipes transform complex, multi-step processes into repeatable, reliable workflows. They bridge the gap between manual agent interaction and fully automated pipelines, giving you control over the workflow design while letting AI handle the execution.","title":"Key Takeaways"},{"location":"concepts/skills.html","text":"Understanding Skills \u00b6 Skills are one of Amplifier's most powerful features for extending agent capabilities. They provide a way to inject domain-specific knowledge, best practices, and workflows into your agents without modifying core system code. What is a Skill? \u00b6 A skill is loadable domain knowledge packaged as markdown files that agents can access on demand. Think of skills as specialized instruction manuals that agents can consult when they need expertise in a particular area. Key Characteristics \u00b6 On-demand loading : Skills are loaded only when needed, keeping agent context lean Domain-specific : Each skill focuses on a particular area of expertise Declarative : Skills describe what to do, not how to implement it Composable : Multiple skills can be loaded together for complex tasks Versionable : Skills can be versioned and updated independently Anatomy of a Skill \u00b6 A skill typically consists of: my-skill/ \u251c\u2500\u2500 skill.md # Main skill content (required) \u251c\u2500\u2500 examples/ # Optional companion files \u2502 \u251c\u2500\u2500 basic.py \u2502 \u2514\u2500\u2500 advanced.py \u2514\u2500\u2500 templates/ # Optional templates \u2514\u2500\u2500 config.yaml The skill.md file contains: Frontmatter : Metadata about the skill (name, version, description) Context : Background knowledge the agent needs Guidelines : Best practices and decision frameworks Workflows : Step-by-step procedures for common tasks Examples : Concrete illustrations of concepts Discovering Skills \u00b6 Before loading a skill, you need to know what's available. Amplifier provides several ways to discover skills. Listing All Skills \u00b6 Use the load_skill tool with the list parameter: load_skill ( list = True ) This returns all available skills with their names and descriptions. Searching for Skills \u00b6 If you're looking for skills in a specific domain: load_skill ( search = \"python\" ) This filters skills by name or description matching your search term. Getting Skill Metadata \u00b6 Before loading a full skill (which consumes context), you can inspect its metadata: load_skill ( info = \"design-patterns\" ) This returns the skill's name, description, version, and path without loading the full content. Skill Discovery Locations \u00b6 Skills are discovered from multiple directories in priority order: Workspace skills ( .amplifier/skills/ ) - Project-specific skills User skills ( ~/.amplifier/skills/ ) - Personal skills across projects Collection skills - Skills bundled with Amplifier collections First-match-wins: if the same skill exists in multiple locations, the first one found is used. Loading Skills \u00b6 When you need domain expertise, load the relevant skill into context. Basic Loading \u00b6 load_skill ( skill_name = \"python-standards\" ) This loads the full skill content and returns: - The skill content itself - The skill_directory path for accessing companion files Accessing Companion Files \u00b6 Many skills include additional resources like examples, templates, or reference files. Use the returned skill_directory to access them: # Load the skill result = load_skill ( skill_name = \"api-design\" ) skill_dir = result [ \"skill_directory\" ] # Read a companion file read_file ( f \" { skill_dir } /examples/rest-api.py\" ) When to Load Skills \u00b6 Load skills when you need: Domain expertise : Working in an unfamiliar area Best practices : Ensuring code follows established patterns Consistency : Applying the same standards across a project Complex workflows : Following multi-step procedures correctly Context Management \u00b6 Skills consume context tokens when loaded. Best practices: Load skills on-demand, not preemptively Use info to check skill size before loading Load only the skills you actually need Consider skill size when working with limited context Creating Skills \u00b6 You can create custom skills for your projects or personal use. Skill Structure \u00b6 Create a directory with at least a skill.md file: --- name: my-custom-skill description: Brief description of what this skill provides version: 1.0.0 --- # My Custom Skill ## Overview Explain the domain this skill covers. ## Guidelines List best practices and decision frameworks. ## Workflows Document step-by-step procedures. ## Examples Provide concrete illustrations. Where to Place Skills \u00b6 Choose based on scope: Location Scope Use Case .amplifier/skills/ Project Team-specific patterns ~/.amplifier/skills/ User Personal workflows Collection Distribution Shared with community Writing Effective Skills \u00b6 Be specific : Focus on one domain or problem area. # Good: Focused skill --- name: react-testing description: Testing patterns for React components --- # Bad: Too broad --- name: frontend description: Everything about frontend development --- Be actionable : Provide clear guidance, not just information. # Good: Actionable guideline When testing async components, always: 1. Use `waitFor` for state changes 2. Mock API calls at the network level 3. Test loading and error states # Bad: Vague advice Make sure to test your components properly. Include examples : Show, don't just tell. ## Example: Testing a Form Component ```tsx test('submits form data', async () => { render(<ContactForm />); await userEvent.type(screen.getByLabelText('Email'), 'test@example.com'); await userEvent.click(screen.getByRole('button', { name: 'Submit' })); await waitFor(() => { expect(mockSubmit).toHaveBeenCalledWith({ email: 'test@example.com' }); }); }); ### Companion Files For complex skills, include additional resources: my-skill/ \u251c\u2500\u2500 skill.md \u251c\u2500\u2500 examples/ \u2502 \u251c\u2500\u2500 basic-usage.py \u2502 \u2514\u2500\u2500 advanced-patterns.py \u251c\u2500\u2500 templates/ \u2502 \u2514\u2500\u2500 project-structure/ \u2514\u2500\u2500 reference/ \u2514\u2500\u2500 cheatsheet.md Reference these in your skill content: ```markdown ## Getting Started See `examples/basic-usage.py` for a minimal working example. For production patterns, refer to `examples/advanced-patterns.py`. Key Takeaways \u00b6 Skills are loadable expertise : They inject domain knowledge into agents on demand, keeping base context lean while enabling deep specialization. Discovery before loading : Use list , search , and info operations to find the right skill without consuming context unnecessarily. Location determines scope : Workspace skills override user skills, enabling project-specific customization while maintaining personal defaults. Focus on actionability : The best skills provide clear guidelines, decision frameworks, and concrete examples\u2014not just reference information. Companion files extend capabilities : Skills can include examples, templates, and reference materials that agents access via the skill_directory path. Context is precious : Load skills judiciously. Each loaded skill consumes tokens that could be used for other context. Related Concepts \u00b6 Agents - How agents use skills Bundles - Packaging skills with other components Architecture - System design and structure","title":"Skills"},{"location":"concepts/skills.html#understanding-skills","text":"Skills are one of Amplifier's most powerful features for extending agent capabilities. They provide a way to inject domain-specific knowledge, best practices, and workflows into your agents without modifying core system code.","title":"Understanding Skills"},{"location":"concepts/skills.html#what-is-a-skill","text":"A skill is loadable domain knowledge packaged as markdown files that agents can access on demand. Think of skills as specialized instruction manuals that agents can consult when they need expertise in a particular area.","title":"What is a Skill?"},{"location":"concepts/skills.html#key-characteristics","text":"On-demand loading : Skills are loaded only when needed, keeping agent context lean Domain-specific : Each skill focuses on a particular area of expertise Declarative : Skills describe what to do, not how to implement it Composable : Multiple skills can be loaded together for complex tasks Versionable : Skills can be versioned and updated independently","title":"Key Characteristics"},{"location":"concepts/skills.html#anatomy-of-a-skill","text":"A skill typically consists of: my-skill/ \u251c\u2500\u2500 skill.md # Main skill content (required) \u251c\u2500\u2500 examples/ # Optional companion files \u2502 \u251c\u2500\u2500 basic.py \u2502 \u2514\u2500\u2500 advanced.py \u2514\u2500\u2500 templates/ # Optional templates \u2514\u2500\u2500 config.yaml The skill.md file contains: Frontmatter : Metadata about the skill (name, version, description) Context : Background knowledge the agent needs Guidelines : Best practices and decision frameworks Workflows : Step-by-step procedures for common tasks Examples : Concrete illustrations of concepts","title":"Anatomy of a Skill"},{"location":"concepts/skills.html#discovering-skills","text":"Before loading a skill, you need to know what's available. Amplifier provides several ways to discover skills.","title":"Discovering Skills"},{"location":"concepts/skills.html#listing-all-skills","text":"Use the load_skill tool with the list parameter: load_skill ( list = True ) This returns all available skills with their names and descriptions.","title":"Listing All Skills"},{"location":"concepts/skills.html#searching-for-skills","text":"If you're looking for skills in a specific domain: load_skill ( search = \"python\" ) This filters skills by name or description matching your search term.","title":"Searching for Skills"},{"location":"concepts/skills.html#getting-skill-metadata","text":"Before loading a full skill (which consumes context), you can inspect its metadata: load_skill ( info = \"design-patterns\" ) This returns the skill's name, description, version, and path without loading the full content.","title":"Getting Skill Metadata"},{"location":"concepts/skills.html#skill-discovery-locations","text":"Skills are discovered from multiple directories in priority order: Workspace skills ( .amplifier/skills/ ) - Project-specific skills User skills ( ~/.amplifier/skills/ ) - Personal skills across projects Collection skills - Skills bundled with Amplifier collections First-match-wins: if the same skill exists in multiple locations, the first one found is used.","title":"Skill Discovery Locations"},{"location":"concepts/skills.html#loading-skills","text":"When you need domain expertise, load the relevant skill into context.","title":"Loading Skills"},{"location":"concepts/skills.html#basic-loading","text":"load_skill ( skill_name = \"python-standards\" ) This loads the full skill content and returns: - The skill content itself - The skill_directory path for accessing companion files","title":"Basic Loading"},{"location":"concepts/skills.html#accessing-companion-files","text":"Many skills include additional resources like examples, templates, or reference files. Use the returned skill_directory to access them: # Load the skill result = load_skill ( skill_name = \"api-design\" ) skill_dir = result [ \"skill_directory\" ] # Read a companion file read_file ( f \" { skill_dir } /examples/rest-api.py\" )","title":"Accessing Companion Files"},{"location":"concepts/skills.html#when-to-load-skills","text":"Load skills when you need: Domain expertise : Working in an unfamiliar area Best practices : Ensuring code follows established patterns Consistency : Applying the same standards across a project Complex workflows : Following multi-step procedures correctly","title":"When to Load Skills"},{"location":"concepts/skills.html#context-management","text":"Skills consume context tokens when loaded. Best practices: Load skills on-demand, not preemptively Use info to check skill size before loading Load only the skills you actually need Consider skill size when working with limited context","title":"Context Management"},{"location":"concepts/skills.html#creating-skills","text":"You can create custom skills for your projects or personal use.","title":"Creating Skills"},{"location":"concepts/skills.html#skill-structure","text":"Create a directory with at least a skill.md file: --- name: my-custom-skill description: Brief description of what this skill provides version: 1.0.0 --- # My Custom Skill ## Overview Explain the domain this skill covers. ## Guidelines List best practices and decision frameworks. ## Workflows Document step-by-step procedures. ## Examples Provide concrete illustrations.","title":"Skill Structure"},{"location":"concepts/skills.html#where-to-place-skills","text":"Choose based on scope: Location Scope Use Case .amplifier/skills/ Project Team-specific patterns ~/.amplifier/skills/ User Personal workflows Collection Distribution Shared with community","title":"Where to Place Skills"},{"location":"concepts/skills.html#writing-effective-skills","text":"Be specific : Focus on one domain or problem area. # Good: Focused skill --- name: react-testing description: Testing patterns for React components --- # Bad: Too broad --- name: frontend description: Everything about frontend development --- Be actionable : Provide clear guidance, not just information. # Good: Actionable guideline When testing async components, always: 1. Use `waitFor` for state changes 2. Mock API calls at the network level 3. Test loading and error states # Bad: Vague advice Make sure to test your components properly. Include examples : Show, don't just tell. ## Example: Testing a Form Component ```tsx test('submits form data', async () => { render(<ContactForm />); await userEvent.type(screen.getByLabelText('Email'), 'test@example.com'); await userEvent.click(screen.getByRole('button', { name: 'Submit' })); await waitFor(() => { expect(mockSubmit).toHaveBeenCalledWith({ email: 'test@example.com' }); }); }); ### Companion Files For complex skills, include additional resources: my-skill/ \u251c\u2500\u2500 skill.md \u251c\u2500\u2500 examples/ \u2502 \u251c\u2500\u2500 basic-usage.py \u2502 \u2514\u2500\u2500 advanced-patterns.py \u251c\u2500\u2500 templates/ \u2502 \u2514\u2500\u2500 project-structure/ \u2514\u2500\u2500 reference/ \u2514\u2500\u2500 cheatsheet.md Reference these in your skill content: ```markdown ## Getting Started See `examples/basic-usage.py` for a minimal working example. For production patterns, refer to `examples/advanced-patterns.py`.","title":"Writing Effective Skills"},{"location":"concepts/skills.html#key-takeaways","text":"Skills are loadable expertise : They inject domain knowledge into agents on demand, keeping base context lean while enabling deep specialization. Discovery before loading : Use list , search , and info operations to find the right skill without consuming context unnecessarily. Location determines scope : Workspace skills override user skills, enabling project-specific customization while maintaining personal defaults. Focus on actionability : The best skills provide clear guidelines, decision frameworks, and concrete examples\u2014not just reference information. Companion files extend capabilities : Skills can include examples, templates, and reference materials that agents access via the skill_directory path. Context is precious : Load skills judiciously. Each loaded skill consumes tokens that could be used for other context.","title":"Key Takeaways"},{"location":"concepts/skills.html#related-concepts","text":"Agents - How agents use skills Bundles - Packaging skills with other components Architecture - System design and structure","title":"Related Concepts"},{"location":"dev-setup/index.html","text":"Development Setup \u00b6 Set up an optimal development environment for working with Amplifier. This section covers IDE configuration, debugging tools, testing workflows, and developer productivity tips. Get your local environment tuned for efficient Amplifier development. Section Contents \u00b6 Page Description CLI Tools Essential command-line utilities Shadow Workspace Isolated testing environments Remote Development Working with remote systems Debugging Troubleshooting and debugging workflows Quick Tips \u00b6 Use virtual environments - Isolate Amplifier dependencies Enable LSP - Get code intelligence in your editor Set up pre-commit - Catch issues before committing Use session logs - Debug with full conversation traces Test incrementally - Run focused tests during development Environment Checklist \u00b6 Before starting development: [ ] Python 3.10+ installed [ ] Virtual environment created [ ] Amplifier installed in editable mode [ ] Editor/IDE configured with Python support [ ] LSP server (Pyright) available [ ] Git configured with hooks [ ] API keys in environment variables Recommended Stack \u00b6 Tool Purpose uv Fast Python package manager pyright Type checking and LSP pytest Test framework ruff Linting and formatting VS Code Editor with Python extension Where to Start \u00b6 Setting up fresh? Begin with CLI Tools for essential command-line utilities. Testing locally? Jump to Shadow Workspace for isolated testing environments. Working remotely? See Remote Development for remote system workflows. Development Commands \u00b6 # Install in development mode uv pip install -e \".[dev]\" # Run tests pytest tests/ # Type check pyright src/ # Format code ruff format src/ # Lint ruff check src/ --fix Debugging Workflow \u00b6 Check session logs - ~/.amplifier/sessions/ Use session-analyst - Delegate to specialist agent Enable verbose mode - More detailed output Inspect events.jsonl - Raw conversation data Next Steps \u00b6 After setting up your environment, start with Quickstart to build your first application, or explore Tools to understand available capabilities.","title":"Overview"},{"location":"dev-setup/index.html#development-setup","text":"Set up an optimal development environment for working with Amplifier. This section covers IDE configuration, debugging tools, testing workflows, and developer productivity tips. Get your local environment tuned for efficient Amplifier development.","title":"Development Setup"},{"location":"dev-setup/index.html#section-contents","text":"Page Description CLI Tools Essential command-line utilities Shadow Workspace Isolated testing environments Remote Development Working with remote systems Debugging Troubleshooting and debugging workflows","title":"Section Contents"},{"location":"dev-setup/index.html#quick-tips","text":"Use virtual environments - Isolate Amplifier dependencies Enable LSP - Get code intelligence in your editor Set up pre-commit - Catch issues before committing Use session logs - Debug with full conversation traces Test incrementally - Run focused tests during development","title":"Quick Tips"},{"location":"dev-setup/index.html#environment-checklist","text":"Before starting development: [ ] Python 3.10+ installed [ ] Virtual environment created [ ] Amplifier installed in editable mode [ ] Editor/IDE configured with Python support [ ] LSP server (Pyright) available [ ] Git configured with hooks [ ] API keys in environment variables","title":"Environment Checklist"},{"location":"dev-setup/index.html#recommended-stack","text":"Tool Purpose uv Fast Python package manager pyright Type checking and LSP pytest Test framework ruff Linting and formatting VS Code Editor with Python extension","title":"Recommended Stack"},{"location":"dev-setup/index.html#where-to-start","text":"Setting up fresh? Begin with CLI Tools for essential command-line utilities. Testing locally? Jump to Shadow Workspace for isolated testing environments. Working remotely? See Remote Development for remote system workflows.","title":"Where to Start"},{"location":"dev-setup/index.html#development-commands","text":"# Install in development mode uv pip install -e \".[dev]\" # Run tests pytest tests/ # Type check pyright src/ # Format code ruff format src/ # Lint ruff check src/ --fix","title":"Development Commands"},{"location":"dev-setup/index.html#debugging-workflow","text":"Check session logs - ~/.amplifier/sessions/ Use session-analyst - Delegate to specialist agent Enable verbose mode - More detailed output Inspect events.jsonl - Raw conversation data","title":"Debugging Workflow"},{"location":"dev-setup/index.html#next-steps","text":"After setting up your environment, start with Quickstart to build your first application, or explore Tools to understand available capabilities.","title":"Next Steps"},{"location":"dev-setup/cli-tools.html","text":"CLI Tools \u00b6 Useful command-line tools for Amplifier development. Overview \u00b6 These tools enhance your Amplifier development workflow: Tool Purpose amp Main Amplifier CLI uv Fast Python package manager jq JSON processor fzf Fuzzy finder bat Better cat ripgrep Fast search amp (Amplifier CLI) \u00b6 Installation \u00b6 # Via uv (recommended) uv tool install amplifier # Verify amp --version Key Commands \u00b6 # Start interactive session amp # Run single prompt amp run \"explain this code\" # Use specific bundle amp --bundle recipes # List sessions amp session list # Resume session amp session resume [ id ] Bundle Management \u00b6 # Add a bundle amp bundle add git+https://github.com/microsoft/amplifier-bundle-recipes@main # List bundles amp bundle list # Use a bundle amp bundle use recipes # Remove a bundle amp bundle remove recipes Recipe Commands \u00b6 # Run recipe amp recipes execute recipe.yaml --context '{}' # List sessions amp recipes list # Resume recipe amp recipes resume [ session-id ] # Validate recipe amp recipes validate recipe.yaml uv (Python Package Manager) \u00b6 Fast, modern Python package management. Installation \u00b6 curl -LsSf https://astral.sh/uv/install.sh | sh Key Commands \u00b6 # Create virtual environment uv venv # Install packages uv pip install requests # Install from requirements uv pip install -r requirements.txt # Install tool globally uv tool install ruff Why uv? \u00b6 10-100x faster than pip Automatic venv detection Lockfile support Tool management jq (JSON Processor) \u00b6 Query and manipulate JSON from the command line. Installation \u00b6 # macOS brew install jq # Ubuntu/Debian sudo apt install jq # Windows winget install jqlang.jq Common Uses \u00b6 # Pretty print JSON curl https://api.example.com/users | jq . # Extract field cat data.json | jq '.name' # Filter array cat users.json | jq '.[] | select(.active == true)' # Count items cat items.json | jq 'length' # Transform data cat users.json | jq '{count: length, names: [.[].name]}' With Amplifier Logs \u00b6 # Parse session events cat events.jsonl | jq 'select(.event_type == \"tool:call\")' # Get tool names used cat events.jsonl | jq -r 'select(.event_type == \"tool:call\") | .tool_name' fzf (Fuzzy Finder) \u00b6 Interactive fuzzy search for anything. Installation \u00b6 # macOS brew install fzf # Ubuntu/Debian sudo apt install fzf # Setup shell integration $( brew --prefix ) /opt/fzf/install Common Uses \u00b6 # Find and open file vim $( fzf ) # Search command history history | fzf # Git branch checkout git checkout $( git branch | fzf ) # Find session amp session resume $( amp session list | fzf | awk '{print $1}' ) With Amplifier \u00b6 # Find recipe to run amp recipes execute $( find recipes -name \"*.yaml\" | fzf ) # Resume session interactively amp session list | fzf | xargs amp session resume bat (Better cat) \u00b6 Syntax-highlighted file viewer. Installation \u00b6 # macOS brew install bat # Ubuntu/Debian sudo apt install bat # Note: on Ubuntu, the command is 'batcat' Common Uses \u00b6 # View file with syntax highlighting bat config.yaml # Show line numbers bat -n script.py # Show specific lines bat --line-range 10 :20 app.py # Compare files bat --diff file1.py file2.py ripgrep (rg) \u00b6 Faster grep with smart defaults. Installation \u00b6 # macOS brew install ripgrep # Ubuntu/Debian sudo apt install ripgrep Common Uses \u00b6 # Search for pattern rg \"TODO\" # Search specific file type rg \"function\" --type js # Show context rg \"error\" -C 3 # Ignore case rg -i \"config\" # List files only rg -l \"import pandas\" vs Amplifier grep \u00b6 Amplifier's built-in grep uses ripgrep when available, with added features like output limits and smart exclusions. Use rg directly when you need full control. Shell Aliases \u00b6 Add to your ~/.bashrc or ~/.zshrc : # Amplifier shortcuts alias a = 'amp' alias ar = 'amp run' alias as = 'amp session' alias ab = 'amp bundle' # Development alias py = 'python3' alias pip = 'uv pip' # Navigation alias .. = 'cd ..' alias ... = 'cd ../..' # Git alias gs = 'git status' alias gd = 'git diff' alias gc = 'git commit' alias gp = 'git push' Try It Yourself \u00b6 Exercise 1: Install Tools \u00b6 # Install the essentials uv tool install amplifier brew install jq fzf bat ripgrep # or apt equivalent Exercise 2: Explore Session Logs \u00b6 # Find latest session ls -t ~/.amplifier/sessions/ | head -1 # Parse events cat ~/.amplifier/sessions/ [ id ] /events.jsonl | jq '.event_type' | sort | uniq -c Exercise 3: Fuzzy Find \u00b6 # Install fzf if needed brew install fzf # Use it vim $( fzf ) Next \u00b6 Set up your development environment: \u2192 Shadow Workspace","title":"CLI Tools"},{"location":"dev-setup/cli-tools.html#cli-tools","text":"Useful command-line tools for Amplifier development.","title":"CLI Tools"},{"location":"dev-setup/cli-tools.html#overview","text":"These tools enhance your Amplifier development workflow: Tool Purpose amp Main Amplifier CLI uv Fast Python package manager jq JSON processor fzf Fuzzy finder bat Better cat ripgrep Fast search","title":"Overview"},{"location":"dev-setup/cli-tools.html#amp-amplifier-cli","text":"","title":"amp (Amplifier CLI)"},{"location":"dev-setup/cli-tools.html#installation","text":"# Via uv (recommended) uv tool install amplifier # Verify amp --version","title":"Installation"},{"location":"dev-setup/cli-tools.html#key-commands","text":"# Start interactive session amp # Run single prompt amp run \"explain this code\" # Use specific bundle amp --bundle recipes # List sessions amp session list # Resume session amp session resume [ id ]","title":"Key Commands"},{"location":"dev-setup/cli-tools.html#bundle-management","text":"# Add a bundle amp bundle add git+https://github.com/microsoft/amplifier-bundle-recipes@main # List bundles amp bundle list # Use a bundle amp bundle use recipes # Remove a bundle amp bundle remove recipes","title":"Bundle Management"},{"location":"dev-setup/cli-tools.html#recipe-commands","text":"# Run recipe amp recipes execute recipe.yaml --context '{}' # List sessions amp recipes list # Resume recipe amp recipes resume [ session-id ] # Validate recipe amp recipes validate recipe.yaml","title":"Recipe Commands"},{"location":"dev-setup/cli-tools.html#uv-python-package-manager","text":"Fast, modern Python package management.","title":"uv (Python Package Manager)"},{"location":"dev-setup/cli-tools.html#installation_1","text":"curl -LsSf https://astral.sh/uv/install.sh | sh","title":"Installation"},{"location":"dev-setup/cli-tools.html#key-commands_1","text":"# Create virtual environment uv venv # Install packages uv pip install requests # Install from requirements uv pip install -r requirements.txt # Install tool globally uv tool install ruff","title":"Key Commands"},{"location":"dev-setup/cli-tools.html#why-uv","text":"10-100x faster than pip Automatic venv detection Lockfile support Tool management","title":"Why uv?"},{"location":"dev-setup/cli-tools.html#jq-json-processor","text":"Query and manipulate JSON from the command line.","title":"jq (JSON Processor)"},{"location":"dev-setup/cli-tools.html#installation_2","text":"# macOS brew install jq # Ubuntu/Debian sudo apt install jq # Windows winget install jqlang.jq","title":"Installation"},{"location":"dev-setup/cli-tools.html#common-uses","text":"# Pretty print JSON curl https://api.example.com/users | jq . # Extract field cat data.json | jq '.name' # Filter array cat users.json | jq '.[] | select(.active == true)' # Count items cat items.json | jq 'length' # Transform data cat users.json | jq '{count: length, names: [.[].name]}'","title":"Common Uses"},{"location":"dev-setup/cli-tools.html#with-amplifier-logs","text":"# Parse session events cat events.jsonl | jq 'select(.event_type == \"tool:call\")' # Get tool names used cat events.jsonl | jq -r 'select(.event_type == \"tool:call\") | .tool_name'","title":"With Amplifier Logs"},{"location":"dev-setup/cli-tools.html#fzf-fuzzy-finder","text":"Interactive fuzzy search for anything.","title":"fzf (Fuzzy Finder)"},{"location":"dev-setup/cli-tools.html#installation_3","text":"# macOS brew install fzf # Ubuntu/Debian sudo apt install fzf # Setup shell integration $( brew --prefix ) /opt/fzf/install","title":"Installation"},{"location":"dev-setup/cli-tools.html#common-uses_1","text":"# Find and open file vim $( fzf ) # Search command history history | fzf # Git branch checkout git checkout $( git branch | fzf ) # Find session amp session resume $( amp session list | fzf | awk '{print $1}' )","title":"Common Uses"},{"location":"dev-setup/cli-tools.html#with-amplifier","text":"# Find recipe to run amp recipes execute $( find recipes -name \"*.yaml\" | fzf ) # Resume session interactively amp session list | fzf | xargs amp session resume","title":"With Amplifier"},{"location":"dev-setup/cli-tools.html#bat-better-cat","text":"Syntax-highlighted file viewer.","title":"bat (Better cat)"},{"location":"dev-setup/cli-tools.html#installation_4","text":"# macOS brew install bat # Ubuntu/Debian sudo apt install bat # Note: on Ubuntu, the command is 'batcat'","title":"Installation"},{"location":"dev-setup/cli-tools.html#common-uses_2","text":"# View file with syntax highlighting bat config.yaml # Show line numbers bat -n script.py # Show specific lines bat --line-range 10 :20 app.py # Compare files bat --diff file1.py file2.py","title":"Common Uses"},{"location":"dev-setup/cli-tools.html#ripgrep-rg","text":"Faster grep with smart defaults.","title":"ripgrep (rg)"},{"location":"dev-setup/cli-tools.html#installation_5","text":"# macOS brew install ripgrep # Ubuntu/Debian sudo apt install ripgrep","title":"Installation"},{"location":"dev-setup/cli-tools.html#common-uses_3","text":"# Search for pattern rg \"TODO\" # Search specific file type rg \"function\" --type js # Show context rg \"error\" -C 3 # Ignore case rg -i \"config\" # List files only rg -l \"import pandas\"","title":"Common Uses"},{"location":"dev-setup/cli-tools.html#vs-amplifier-grep","text":"Amplifier's built-in grep uses ripgrep when available, with added features like output limits and smart exclusions. Use rg directly when you need full control.","title":"vs Amplifier grep"},{"location":"dev-setup/cli-tools.html#shell-aliases","text":"Add to your ~/.bashrc or ~/.zshrc : # Amplifier shortcuts alias a = 'amp' alias ar = 'amp run' alias as = 'amp session' alias ab = 'amp bundle' # Development alias py = 'python3' alias pip = 'uv pip' # Navigation alias .. = 'cd ..' alias ... = 'cd ../..' # Git alias gs = 'git status' alias gd = 'git diff' alias gc = 'git commit' alias gp = 'git push'","title":"Shell Aliases"},{"location":"dev-setup/cli-tools.html#try-it-yourself","text":"","title":"Try It Yourself"},{"location":"dev-setup/cli-tools.html#exercise-1-install-tools","text":"# Install the essentials uv tool install amplifier brew install jq fzf bat ripgrep # or apt equivalent","title":"Exercise 1: Install Tools"},{"location":"dev-setup/cli-tools.html#exercise-2-explore-session-logs","text":"# Find latest session ls -t ~/.amplifier/sessions/ | head -1 # Parse events cat ~/.amplifier/sessions/ [ id ] /events.jsonl | jq '.event_type' | sort | uniq -c","title":"Exercise 2: Explore Session Logs"},{"location":"dev-setup/cli-tools.html#exercise-3-fuzzy-find","text":"# Install fzf if needed brew install fzf # Use it vim $( fzf )","title":"Exercise 3: Fuzzy Find"},{"location":"dev-setup/cli-tools.html#next","text":"Set up your development environment: \u2192 Shadow Workspace","title":"Next"},{"location":"dev-setup/debugging.html","text":"Debugging \u00b6 Troubleshoot issues with Amplifier and your AI-assisted workflows. Overview \u00b6 Debugging approaches: Issue Type Where to Look Session errors events.jsonl Tool failures Tool output, logs Provider issues API errors, model limits Recipe problems Step results, context Bundle issues Bundle validation Session Analysis \u00b6 Find Your Session \u00b6 # List recent sessions ls -lt ~/.amplifier/sessions/ | head -10 # Or in Amplifier amp session list Read Session Events \u00b6 Sessions are logged to events.jsonl : cd ~/.amplifier/sessions/ [ session-id ] # View all events cat events.jsonl | jq . # Filter by event type cat events.jsonl | jq 'select(.event_type == \"tool:call\")' # See errors cat events.jsonl | jq 'select(.event_type | contains(\"error\"))' Common Event Types \u00b6 Event Meaning session:start Session began turn:start User message received provider:request API call to LLM provider:response LLM response tool:call Tool invoked tool:result Tool returned turn:end Response complete session:end Session ended Session Analyst Agent \u00b6 For complex issues, use the specialist: > Analyze why session [id] failed The session-analyst agent safely handles large event logs. Tool Debugging \u00b6 See Tool Calls \u00b6 # In session, see what tools were called cat events.jsonl | jq -r 'select(.event_type == \"tool:call\") | .tool_name' Tool Errors \u00b6 # Find tool errors cat events.jsonl | jq 'select(.event_type == \"tool:result\" and .error != null)' Common Tool Issues \u00b6 bash timeout: # Command took too long # Solution: Use explicit timeout timeout 120 long_command File not found: # Check path ls -la [ path ] # Check working directory pwd Permission denied: # Check permissions ls -la [ file ] chmod +x [ script ] Provider Debugging \u00b6 API Errors \u00b6 # Find provider errors cat events.jsonl | jq 'select(.event_type == \"provider:response\" and .error != null)' Common Provider Issues \u00b6 Rate limiting: Error: 429 Too Many Requests Wait and retry Check your API plan limits Consider using a different model Token limits: Error: Context length exceeded Conversation too long Start new session Use smaller context Invalid API key: Error: 401 Unauthorized Check ANTHROPIC_API_KEY is set Verify key is valid Check for typos Test Provider Connection \u00b6 # Anthropic curl https://api.anthropic.com/v1/messages \\ -H \"x-api-key: $ANTHROPIC_API_KEY \" \\ -H \"content-type: application/json\" \\ -H \"anthropic-version: 2023-06-01\" \\ -d '{\"model\": \"claude-sonnet-4-20250514\", \"max_tokens\": 10, \"messages\": [{\"role\": \"user\", \"content\": \"Hi\"}]}' Recipe Debugging \u00b6 Validate Recipe \u00b6 amp recipes validate my-recipe.yaml Check Recipe Session \u00b6 # List recipe sessions amp recipes list # View recipe session events cat ~/.amplifier/sessions/recipe_ [ id ] /events.jsonl | jq . Step Results \u00b6 # See what each step returned cat events.jsonl | jq 'select(.event_type == \"step:complete\")' Common Recipe Issues \u00b6 Context variable missing: Error: Required context variable 'file_path' not provided Add --context '{\"file_path\": \"...\"}' Step failed: - Check the step's agent - Review the instruction - Look at step result in events Bundle Debugging \u00b6 Validate Bundle \u00b6 amp bundle validate ./my-bundle Check What's Loaded \u00b6 > What bundle am I using? > What tools do you have? > What agents are available? Bundle Load Errors \u00b6 Check for: - Missing bundle.yaml - Invalid YAML syntax - Missing included bundles - Invalid module references Verbose Mode \u00b6 Get more output: # Set debug logging export AMPLIFIER_LOG_LEVEL = debug # Run Amplifier amp Log Locations \u00b6 Log Location Session events ~/.amplifier/sessions/[id]/events.jsonl Application logs ~/.amplifier/logs/ Recipe sessions ~/.amplifier/sessions/recipe_[id]/ Debugging Workflow \u00b6 Step 1: Reproduce \u00b6 # Note the session ID amp session list | head -1 Step 2: Find Events \u00b6 cd ~/.amplifier/sessions/ [ id ] cat events.jsonl | jq '.event_type' | sort | uniq -c Step 3: Locate Error \u00b6 # Find errors cat events.jsonl | jq 'select(.error != null)' # Find last event before error cat events.jsonl | tail -20 | jq . Step 4: Understand Context \u00b6 # See what led to error cat events.jsonl | jq 'select(.event_type == \"turn:start\" or .event_type == \"tool:call\")' | tail -10 Step 5: Fix and Retry \u00b6 Based on findings: - Fix configuration - Adjust prompts - Retry operation Try It Yourself \u00b6 Exercise 1: Explore Session \u00b6 # Find latest session SESSION = $( ls -t ~/.amplifier/sessions/ | head -1 ) # Count event types cat ~/.amplifier/sessions/ $SESSION /events.jsonl | jq '.event_type' | sort | uniq -c Exercise 2: Find Tool Calls \u00b6 # What tools were used? cat ~/.amplifier/sessions/ $SESSION /events.jsonl | \\ jq -r 'select(.event_type == \"tool:call\") | .tool_name' | \\ sort | uniq -c | sort -rn Exercise 3: Debug an Error \u00b6 Intentionally cause an error: > Read the file /nonexistent/path/file.txt Then find it in logs: cat events.jsonl | jq 'select(.error != null)' Getting Help \u00b6 If stuck: Search the error - Often others have hit it Check GitHub Issues - Known problems and solutions Ask Amplifier - \"Why did this fail?\" Session analyst - \"Analyze session [id]\"","title":"Debugging"},{"location":"dev-setup/debugging.html#debugging","text":"Troubleshoot issues with Amplifier and your AI-assisted workflows.","title":"Debugging"},{"location":"dev-setup/debugging.html#overview","text":"Debugging approaches: Issue Type Where to Look Session errors events.jsonl Tool failures Tool output, logs Provider issues API errors, model limits Recipe problems Step results, context Bundle issues Bundle validation","title":"Overview"},{"location":"dev-setup/debugging.html#session-analysis","text":"","title":"Session Analysis"},{"location":"dev-setup/debugging.html#find-your-session","text":"# List recent sessions ls -lt ~/.amplifier/sessions/ | head -10 # Or in Amplifier amp session list","title":"Find Your Session"},{"location":"dev-setup/debugging.html#read-session-events","text":"Sessions are logged to events.jsonl : cd ~/.amplifier/sessions/ [ session-id ] # View all events cat events.jsonl | jq . # Filter by event type cat events.jsonl | jq 'select(.event_type == \"tool:call\")' # See errors cat events.jsonl | jq 'select(.event_type | contains(\"error\"))'","title":"Read Session Events"},{"location":"dev-setup/debugging.html#common-event-types","text":"Event Meaning session:start Session began turn:start User message received provider:request API call to LLM provider:response LLM response tool:call Tool invoked tool:result Tool returned turn:end Response complete session:end Session ended","title":"Common Event Types"},{"location":"dev-setup/debugging.html#session-analyst-agent","text":"For complex issues, use the specialist: > Analyze why session [id] failed The session-analyst agent safely handles large event logs.","title":"Session Analyst Agent"},{"location":"dev-setup/debugging.html#tool-debugging","text":"","title":"Tool Debugging"},{"location":"dev-setup/debugging.html#see-tool-calls","text":"# In session, see what tools were called cat events.jsonl | jq -r 'select(.event_type == \"tool:call\") | .tool_name'","title":"See Tool Calls"},{"location":"dev-setup/debugging.html#tool-errors","text":"# Find tool errors cat events.jsonl | jq 'select(.event_type == \"tool:result\" and .error != null)'","title":"Tool Errors"},{"location":"dev-setup/debugging.html#common-tool-issues","text":"bash timeout: # Command took too long # Solution: Use explicit timeout timeout 120 long_command File not found: # Check path ls -la [ path ] # Check working directory pwd Permission denied: # Check permissions ls -la [ file ] chmod +x [ script ]","title":"Common Tool Issues"},{"location":"dev-setup/debugging.html#provider-debugging","text":"","title":"Provider Debugging"},{"location":"dev-setup/debugging.html#api-errors","text":"# Find provider errors cat events.jsonl | jq 'select(.event_type == \"provider:response\" and .error != null)'","title":"API Errors"},{"location":"dev-setup/debugging.html#common-provider-issues","text":"Rate limiting: Error: 429 Too Many Requests Wait and retry Check your API plan limits Consider using a different model Token limits: Error: Context length exceeded Conversation too long Start new session Use smaller context Invalid API key: Error: 401 Unauthorized Check ANTHROPIC_API_KEY is set Verify key is valid Check for typos","title":"Common Provider Issues"},{"location":"dev-setup/debugging.html#test-provider-connection","text":"# Anthropic curl https://api.anthropic.com/v1/messages \\ -H \"x-api-key: $ANTHROPIC_API_KEY \" \\ -H \"content-type: application/json\" \\ -H \"anthropic-version: 2023-06-01\" \\ -d '{\"model\": \"claude-sonnet-4-20250514\", \"max_tokens\": 10, \"messages\": [{\"role\": \"user\", \"content\": \"Hi\"}]}'","title":"Test Provider Connection"},{"location":"dev-setup/debugging.html#recipe-debugging","text":"","title":"Recipe Debugging"},{"location":"dev-setup/debugging.html#validate-recipe","text":"amp recipes validate my-recipe.yaml","title":"Validate Recipe"},{"location":"dev-setup/debugging.html#check-recipe-session","text":"# List recipe sessions amp recipes list # View recipe session events cat ~/.amplifier/sessions/recipe_ [ id ] /events.jsonl | jq .","title":"Check Recipe Session"},{"location":"dev-setup/debugging.html#step-results","text":"# See what each step returned cat events.jsonl | jq 'select(.event_type == \"step:complete\")'","title":"Step Results"},{"location":"dev-setup/debugging.html#common-recipe-issues","text":"Context variable missing: Error: Required context variable 'file_path' not provided Add --context '{\"file_path\": \"...\"}' Step failed: - Check the step's agent - Review the instruction - Look at step result in events","title":"Common Recipe Issues"},{"location":"dev-setup/debugging.html#bundle-debugging","text":"","title":"Bundle Debugging"},{"location":"dev-setup/debugging.html#validate-bundle","text":"amp bundle validate ./my-bundle","title":"Validate Bundle"},{"location":"dev-setup/debugging.html#check-whats-loaded","text":"> What bundle am I using? > What tools do you have? > What agents are available?","title":"Check What's Loaded"},{"location":"dev-setup/debugging.html#bundle-load-errors","text":"Check for: - Missing bundle.yaml - Invalid YAML syntax - Missing included bundles - Invalid module references","title":"Bundle Load Errors"},{"location":"dev-setup/debugging.html#verbose-mode","text":"Get more output: # Set debug logging export AMPLIFIER_LOG_LEVEL = debug # Run Amplifier amp","title":"Verbose Mode"},{"location":"dev-setup/debugging.html#log-locations","text":"Log Location Session events ~/.amplifier/sessions/[id]/events.jsonl Application logs ~/.amplifier/logs/ Recipe sessions ~/.amplifier/sessions/recipe_[id]/","title":"Log Locations"},{"location":"dev-setup/debugging.html#debugging-workflow","text":"","title":"Debugging Workflow"},{"location":"dev-setup/debugging.html#step-1-reproduce","text":"# Note the session ID amp session list | head -1","title":"Step 1: Reproduce"},{"location":"dev-setup/debugging.html#step-2-find-events","text":"cd ~/.amplifier/sessions/ [ id ] cat events.jsonl | jq '.event_type' | sort | uniq -c","title":"Step 2: Find Events"},{"location":"dev-setup/debugging.html#step-3-locate-error","text":"# Find errors cat events.jsonl | jq 'select(.error != null)' # Find last event before error cat events.jsonl | tail -20 | jq .","title":"Step 3: Locate Error"},{"location":"dev-setup/debugging.html#step-4-understand-context","text":"# See what led to error cat events.jsonl | jq 'select(.event_type == \"turn:start\" or .event_type == \"tool:call\")' | tail -10","title":"Step 4: Understand Context"},{"location":"dev-setup/debugging.html#step-5-fix-and-retry","text":"Based on findings: - Fix configuration - Adjust prompts - Retry operation","title":"Step 5: Fix and Retry"},{"location":"dev-setup/debugging.html#try-it-yourself","text":"","title":"Try It Yourself"},{"location":"dev-setup/debugging.html#exercise-1-explore-session","text":"# Find latest session SESSION = $( ls -t ~/.amplifier/sessions/ | head -1 ) # Count event types cat ~/.amplifier/sessions/ $SESSION /events.jsonl | jq '.event_type' | sort | uniq -c","title":"Exercise 1: Explore Session"},{"location":"dev-setup/debugging.html#exercise-2-find-tool-calls","text":"# What tools were used? cat ~/.amplifier/sessions/ $SESSION /events.jsonl | \\ jq -r 'select(.event_type == \"tool:call\") | .tool_name' | \\ sort | uniq -c | sort -rn","title":"Exercise 2: Find Tool Calls"},{"location":"dev-setup/debugging.html#exercise-3-debug-an-error","text":"Intentionally cause an error: > Read the file /nonexistent/path/file.txt Then find it in logs: cat events.jsonl | jq 'select(.error != null)'","title":"Exercise 3: Debug an Error"},{"location":"dev-setup/debugging.html#getting-help","text":"If stuck: Search the error - Often others have hit it Check GitHub Issues - Known problems and solutions Ask Amplifier - \"Why did this fail?\" Session analyst - \"Analyze session [id]\"","title":"Getting Help"},{"location":"dev-setup/remote-dev.html","text":"Remote Development \u00b6 Run Amplifier on remote machines, containers, and cloud environments. Overview \u00b6 Remote development options: Method Best For SSH Remote servers, VMs VS Code Remote Seamless IDE experience Docker Isolated environments GitHub Codespaces Cloud development WSL Windows + Linux SSH \u00b6 Run Amplifier on a remote server. Setup \u00b6 # SSH to your server ssh user@remote-server # Install Amplifier curl -LsSf https://astral.sh/uv/install.sh | sh uv tool install amplifier # Configure provider (on remote) export ANTHROPIC_API_KEY = \"your-key\" # Run amp Port Forwarding \u00b6 For web UIs or local services: ssh -L 8080 :localhost:8080 user@remote-server Persistent Sessions \u00b6 Use tmux to keep sessions alive: # Start tmux ssh user@remote-server tmux new -s amplifier # Run Amplifier amp # Detach: Ctrl+b, then d # Reconnect later ssh user@remote-server tmux attach -t amplifier VS Code Remote \u00b6 Use VS Code's Remote extensions for seamless experience. Remote - SSH \u00b6 # Install extension code --install-extension ms-vscode-remote.remote-ssh # Connect # Ctrl+Shift+P \u2192 \"Remote-SSH: Connect to Host\" # Open terminal in VS Code # Run Amplifier normally amp Remote - Containers \u00b6 # Install extension code --install-extension ms-vscode-remote.remote-containers # Create devcontainer config mkdir .devcontainer .devcontainer/devcontainer.json : { \"name\" : \"Amplifier Dev\" , \"image\" : \"python:3.12\" , \"postCreateCommand\" : \"curl -LsSf https://astral.sh/uv/install.sh | sh && uv tool install amplifier\" , \"remoteEnv\" : { \"ANTHROPIC_API_KEY\" : \"${localEnv:ANTHROPIC_API_KEY}\" } } Docker \u00b6 Run Amplifier in a container. Basic Usage \u00b6 # Run interactive container docker run -it --rm \\ -v $( pwd ) :/workspace \\ -w /workspace \\ -e ANTHROPIC_API_KEY = \" $ANTHROPIC_API_KEY \" \\ python:3.12 bash # Inside container curl -LsSf https://astral.sh/uv/install.sh | sh source ~/.cargo/env uv tool install amplifier amp Dockerfile \u00b6 FROM python:3.12-slim # Install uv RUN curl -LsSf https://astral.sh/uv/install.sh | sh # Add uv to PATH ENV PATH = \"/root/.cargo/bin: $PATH \" # Install Amplifier RUN uv tool install amplifier WORKDIR /workspace CMD [ \"amp\" ] Build and run: docker build -t amplifier-dev . docker run -it --rm \\ -v $( pwd ) :/workspace \\ -e ANTHROPIC_API_KEY \\ amplifier-dev Docker Compose \u00b6 version : '3.8' services : amplifier : build : . volumes : - .:/workspace environment : - ANTHROPIC_API_KEY stdin_open : true tty : true docker compose run amplifier GitHub Codespaces \u00b6 Cloud-hosted development environment. Setup \u00b6 Create .devcontainer/devcontainer.json in your repo: { \"name\" : \"Amplifier Workspace\" , \"image\" : \"mcr.microsoft.com/devcontainers/python:3.12\" , \"postCreateCommand\" : \"curl -LsSf https://astral.sh/uv/install.sh | sh && source ~/.cargo/env && uv tool install amplifier\" , \"secrets\" : { \"ANTHROPIC_API_KEY\" : { \"description\" : \"API key for Anthropic Claude\" } }, \"customizations\" : { \"vscode\" : { \"extensions\" : [ \"ms-python.python\" ] } } } Set secret in GitHub repo settings: Settings \u2192 Secrets \u2192 Codespaces Add ANTHROPIC_API_KEY Create Codespace: Code \u2192 Codespaces \u2192 Create on main In terminal: amp WSL (Windows Subsystem for Linux) \u00b6 Run Amplifier in Linux on Windows. Setup \u00b6 # Install WSL (PowerShell Admin) wsl - -install -d Ubuntu # Start WSL wsl In WSL: # Install uv curl -LsSf https://astral.sh/uv/install.sh | sh source ~/.cargo/env # Install Amplifier uv tool install amplifier # Configure export ANTHROPIC_API_KEY = \"your-key\" echo 'export ANTHROPIC_API_KEY=\"your-key\"' >> ~/.bashrc # Run amp Access Windows Files \u00b6 # Windows drives are mounted at /mnt cd /mnt/c/Users/YourName/Projects # Run Amplifier on Windows project amp VS Code + WSL \u00b6 # From WSL cd /mnt/c/YourProject code . # Opens VS Code connected to WSL Environment Variables \u00b6 Securely handle API keys: Local .env File \u00b6 # .env (gitignored!) ANTHROPIC_API_KEY = sk-ant-... OPENAI_API_KEY = sk-... # Load before running source .env amp direnv \u00b6 Auto-load environment per directory: # Install brew install direnv # Setup echo 'eval \"$(direnv hook bash)\"' >> ~/.bashrc # Create .envrc echo 'export ANTHROPIC_API_KEY=\"sk-ant-...\"' > .envrc direnv allow # Now auto-loads when you cd into directory Try It Yourself \u00b6 Exercise 1: Docker \u00b6 docker run -it --rm \\ -v $( pwd ) :/workspace \\ -e ANTHROPIC_API_KEY \\ python:3.12 bash -c \" curl -LsSf https://astral.sh/uv/install.sh | sh && source ~/.cargo/env && uv tool install amplifier && amp \" Exercise 2: tmux \u00b6 # Start tmux tmux new -s dev # Run Amplifier amp # Detach: Ctrl+b, d # Reattach: tmux attach -t dev Next \u00b6 Learn debugging techniques: \u2192 Debugging","title":"Remote Development"},{"location":"dev-setup/remote-dev.html#remote-development","text":"Run Amplifier on remote machines, containers, and cloud environments.","title":"Remote Development"},{"location":"dev-setup/remote-dev.html#overview","text":"Remote development options: Method Best For SSH Remote servers, VMs VS Code Remote Seamless IDE experience Docker Isolated environments GitHub Codespaces Cloud development WSL Windows + Linux","title":"Overview"},{"location":"dev-setup/remote-dev.html#ssh","text":"Run Amplifier on a remote server.","title":"SSH"},{"location":"dev-setup/remote-dev.html#setup","text":"# SSH to your server ssh user@remote-server # Install Amplifier curl -LsSf https://astral.sh/uv/install.sh | sh uv tool install amplifier # Configure provider (on remote) export ANTHROPIC_API_KEY = \"your-key\" # Run amp","title":"Setup"},{"location":"dev-setup/remote-dev.html#port-forwarding","text":"For web UIs or local services: ssh -L 8080 :localhost:8080 user@remote-server","title":"Port Forwarding"},{"location":"dev-setup/remote-dev.html#persistent-sessions","text":"Use tmux to keep sessions alive: # Start tmux ssh user@remote-server tmux new -s amplifier # Run Amplifier amp # Detach: Ctrl+b, then d # Reconnect later ssh user@remote-server tmux attach -t amplifier","title":"Persistent Sessions"},{"location":"dev-setup/remote-dev.html#vs-code-remote","text":"Use VS Code's Remote extensions for seamless experience.","title":"VS Code Remote"},{"location":"dev-setup/remote-dev.html#remote-ssh","text":"# Install extension code --install-extension ms-vscode-remote.remote-ssh # Connect # Ctrl+Shift+P \u2192 \"Remote-SSH: Connect to Host\" # Open terminal in VS Code # Run Amplifier normally amp","title":"Remote - SSH"},{"location":"dev-setup/remote-dev.html#remote-containers","text":"# Install extension code --install-extension ms-vscode-remote.remote-containers # Create devcontainer config mkdir .devcontainer .devcontainer/devcontainer.json : { \"name\" : \"Amplifier Dev\" , \"image\" : \"python:3.12\" , \"postCreateCommand\" : \"curl -LsSf https://astral.sh/uv/install.sh | sh && uv tool install amplifier\" , \"remoteEnv\" : { \"ANTHROPIC_API_KEY\" : \"${localEnv:ANTHROPIC_API_KEY}\" } }","title":"Remote - Containers"},{"location":"dev-setup/remote-dev.html#docker","text":"Run Amplifier in a container.","title":"Docker"},{"location":"dev-setup/remote-dev.html#basic-usage","text":"# Run interactive container docker run -it --rm \\ -v $( pwd ) :/workspace \\ -w /workspace \\ -e ANTHROPIC_API_KEY = \" $ANTHROPIC_API_KEY \" \\ python:3.12 bash # Inside container curl -LsSf https://astral.sh/uv/install.sh | sh source ~/.cargo/env uv tool install amplifier amp","title":"Basic Usage"},{"location":"dev-setup/remote-dev.html#dockerfile","text":"FROM python:3.12-slim # Install uv RUN curl -LsSf https://astral.sh/uv/install.sh | sh # Add uv to PATH ENV PATH = \"/root/.cargo/bin: $PATH \" # Install Amplifier RUN uv tool install amplifier WORKDIR /workspace CMD [ \"amp\" ] Build and run: docker build -t amplifier-dev . docker run -it --rm \\ -v $( pwd ) :/workspace \\ -e ANTHROPIC_API_KEY \\ amplifier-dev","title":"Dockerfile"},{"location":"dev-setup/remote-dev.html#docker-compose","text":"version : '3.8' services : amplifier : build : . volumes : - .:/workspace environment : - ANTHROPIC_API_KEY stdin_open : true tty : true docker compose run amplifier","title":"Docker Compose"},{"location":"dev-setup/remote-dev.html#github-codespaces","text":"Cloud-hosted development environment.","title":"GitHub Codespaces"},{"location":"dev-setup/remote-dev.html#setup_1","text":"Create .devcontainer/devcontainer.json in your repo: { \"name\" : \"Amplifier Workspace\" , \"image\" : \"mcr.microsoft.com/devcontainers/python:3.12\" , \"postCreateCommand\" : \"curl -LsSf https://astral.sh/uv/install.sh | sh && source ~/.cargo/env && uv tool install amplifier\" , \"secrets\" : { \"ANTHROPIC_API_KEY\" : { \"description\" : \"API key for Anthropic Claude\" } }, \"customizations\" : { \"vscode\" : { \"extensions\" : [ \"ms-python.python\" ] } } } Set secret in GitHub repo settings: Settings \u2192 Secrets \u2192 Codespaces Add ANTHROPIC_API_KEY Create Codespace: Code \u2192 Codespaces \u2192 Create on main In terminal: amp","title":"Setup"},{"location":"dev-setup/remote-dev.html#wsl-windows-subsystem-for-linux","text":"Run Amplifier in Linux on Windows.","title":"WSL (Windows Subsystem for Linux)"},{"location":"dev-setup/remote-dev.html#setup_2","text":"# Install WSL (PowerShell Admin) wsl - -install -d Ubuntu # Start WSL wsl In WSL: # Install uv curl -LsSf https://astral.sh/uv/install.sh | sh source ~/.cargo/env # Install Amplifier uv tool install amplifier # Configure export ANTHROPIC_API_KEY = \"your-key\" echo 'export ANTHROPIC_API_KEY=\"your-key\"' >> ~/.bashrc # Run amp","title":"Setup"},{"location":"dev-setup/remote-dev.html#access-windows-files","text":"# Windows drives are mounted at /mnt cd /mnt/c/Users/YourName/Projects # Run Amplifier on Windows project amp","title":"Access Windows Files"},{"location":"dev-setup/remote-dev.html#vs-code-wsl","text":"# From WSL cd /mnt/c/YourProject code . # Opens VS Code connected to WSL","title":"VS Code + WSL"},{"location":"dev-setup/remote-dev.html#environment-variables","text":"Securely handle API keys:","title":"Environment Variables"},{"location":"dev-setup/remote-dev.html#local-env-file","text":"# .env (gitignored!) ANTHROPIC_API_KEY = sk-ant-... OPENAI_API_KEY = sk-... # Load before running source .env amp","title":"Local .env File"},{"location":"dev-setup/remote-dev.html#direnv","text":"Auto-load environment per directory: # Install brew install direnv # Setup echo 'eval \"$(direnv hook bash)\"' >> ~/.bashrc # Create .envrc echo 'export ANTHROPIC_API_KEY=\"sk-ant-...\"' > .envrc direnv allow # Now auto-loads when you cd into directory","title":"direnv"},{"location":"dev-setup/remote-dev.html#try-it-yourself","text":"","title":"Try It Yourself"},{"location":"dev-setup/remote-dev.html#exercise-1-docker","text":"docker run -it --rm \\ -v $( pwd ) :/workspace \\ -e ANTHROPIC_API_KEY \\ python:3.12 bash -c \" curl -LsSf https://astral.sh/uv/install.sh | sh && source ~/.cargo/env && uv tool install amplifier && amp \"","title":"Exercise 1: Docker"},{"location":"dev-setup/remote-dev.html#exercise-2-tmux","text":"# Start tmux tmux new -s dev # Run Amplifier amp # Detach: Ctrl+b, d # Reattach: tmux attach -t dev","title":"Exercise 2: tmux"},{"location":"dev-setup/remote-dev.html#next","text":"Learn debugging techniques: \u2192 Debugging","title":"Next"},{"location":"dev-setup/shadow-workspace.html","text":"Shadow Workspace \u00b6 Work safely with AI-generated changes using a shadow copy of your project. Overview \u00b6 A shadow workspace lets you: Review AI changes before they touch your real code Test in isolation without risk to your project Compare diffs between original and modified Rollback easily if something goes wrong The Problem \u00b6 When Amplifier writes code, it modifies files directly. This can be risky: Changes might break things Hard to see what changed Difficult to undo The Solution \u00b6 Work in a shadow copy: my-project/ # Your real project (read-only to AI) my-project-shadow/ # Shadow copy (AI writes here) Setup Methods \u00b6 Method 1: Manual Copy \u00b6 # Create shadow workspace cp -r my-project my-project-shadow cd my-project-shadow # Start Amplifier amp Method 2: Git Worktree \u00b6 If your project uses git: cd my-project # Create worktree git worktree add ../my-project-shadow -b ai-changes # Work in shadow cd ../my-project-shadow amp Benefits: - Shares git history - Easy to create PR - Clean branch management Method 3: bkrabach's Shadow Script \u00b6 From bkrabach's setup-tools: # Install curl -o ~/bin/shadow https://raw.githubusercontent.com/bkrabach/setup-tools/main/shadow.sh chmod +x ~/bin/shadow # Use shadow my-project # Creates my-project-shadow and cd's into it Workflow \u00b6 Step 1: Create Shadow \u00b6 shadow my-project # or cp -r my-project my-project-shadow cd my-project-shadow Step 2: Work with Amplifier \u00b6 amp > Refactor the authentication module > Add comprehensive tests > Update the documentation Step 3: Review Changes \u00b6 # See what changed diff -r ../my-project . --exclude = .git --exclude = node_modules # Or with git git diff git status Step 4: Accept or Reject \u00b6 Accept changes: # If using git worktree git add . git commit -m \"AI-assisted refactoring\" git checkout main git merge ai-changes # If manual copy cp -r . ../my-project Reject changes: # Just delete the shadow cd .. rm -rf my-project-shadow Best Practices \u00b6 Keep Shadow Fresh \u00b6 Sync periodically: cd my-project-shadow rsync -av --exclude = '.git' ../my-project/ . Use Git Worktrees for Teams \u00b6 # Create feature branch worktree git worktree add ../feature-auth -b feature/auth-refactor # Work with AI cd ../feature-auth amp # Create PR when done gh pr create Exclude Large Directories \u00b6 When copying: rsync -av --exclude = 'node_modules' --exclude = '.venv' \\ --exclude = 'dist' --exclude = 'build' \\ my-project/ my-project-shadow/ Multiple Shadows \u00b6 For comparing approaches: shadow my-project approach-a shadow my-project approach-b # Try different prompts in each cd ../approach-a && amp cd ../approach-b && amp # Compare results diff -r approach-a approach-b Shadow Script \u00b6 Create ~/bin/shadow : #!/bin/bash # Shadow workspace creator if [ -z \" $1 \" ] ; then echo \"Usage: shadow <project-dir> [shadow-name]\" exit 1 fi PROJECT = \" $1 \" SHADOW = \" ${ 2 :- $1 -shadow } \" if [ -d \" $SHADOW \" ] ; then echo \"Shadow already exists: $SHADOW \" cd \" $SHADOW \" else echo \"Creating shadow workspace: $SHADOW \" if [ -d \" $PROJECT /.git\" ] ; then # Use git worktree if possible cd \" $PROJECT \" git worktree add \"../ $SHADOW \" -b \"shadow- $( date +%Y%m%d-%H%M%S ) \" cd \"../ $SHADOW \" else # Fall back to copy cp -r \" $PROJECT \" \" $SHADOW \" cd \" $SHADOW \" fi echo \"Shadow workspace ready: $SHADOW \" fi # Start shell in shadow exec $SHELL Try It Yourself \u00b6 Exercise 1: Create Shadow \u00b6 # Pick any project shadow my-project # Verify you're in shadow pwd Exercise 2: Make AI Changes \u00b6 amp > Add input validation to all API endpoints Exercise 3: Review and Decide \u00b6 # See changes git diff # Accept or reject Troubleshooting \u00b6 \"Directory already exists\" \u00b6 rm -rf my-project-shadow shadow my-project Large Projects Take Too Long \u00b6 Use rsync with exclusions: rsync -av --exclude = 'node_modules' --exclude = '.venv' \\ --progress my-project/ my-project-shadow/ Git Worktree Conflicts \u00b6 # Clean up orphaned worktree git worktree prune git worktree list Next \u00b6 Learn about remote development options: \u2192 Remote Development","title":"Shadow Workspace"},{"location":"dev-setup/shadow-workspace.html#shadow-workspace","text":"Work safely with AI-generated changes using a shadow copy of your project.","title":"Shadow Workspace"},{"location":"dev-setup/shadow-workspace.html#overview","text":"A shadow workspace lets you: Review AI changes before they touch your real code Test in isolation without risk to your project Compare diffs between original and modified Rollback easily if something goes wrong","title":"Overview"},{"location":"dev-setup/shadow-workspace.html#the-problem","text":"When Amplifier writes code, it modifies files directly. This can be risky: Changes might break things Hard to see what changed Difficult to undo","title":"The Problem"},{"location":"dev-setup/shadow-workspace.html#the-solution","text":"Work in a shadow copy: my-project/ # Your real project (read-only to AI) my-project-shadow/ # Shadow copy (AI writes here)","title":"The Solution"},{"location":"dev-setup/shadow-workspace.html#setup-methods","text":"","title":"Setup Methods"},{"location":"dev-setup/shadow-workspace.html#method-1-manual-copy","text":"# Create shadow workspace cp -r my-project my-project-shadow cd my-project-shadow # Start Amplifier amp","title":"Method 1: Manual Copy"},{"location":"dev-setup/shadow-workspace.html#method-2-git-worktree","text":"If your project uses git: cd my-project # Create worktree git worktree add ../my-project-shadow -b ai-changes # Work in shadow cd ../my-project-shadow amp Benefits: - Shares git history - Easy to create PR - Clean branch management","title":"Method 2: Git Worktree"},{"location":"dev-setup/shadow-workspace.html#method-3-bkrabachs-shadow-script","text":"From bkrabach's setup-tools: # Install curl -o ~/bin/shadow https://raw.githubusercontent.com/bkrabach/setup-tools/main/shadow.sh chmod +x ~/bin/shadow # Use shadow my-project # Creates my-project-shadow and cd's into it","title":"Method 3: bkrabach's Shadow Script"},{"location":"dev-setup/shadow-workspace.html#workflow","text":"","title":"Workflow"},{"location":"dev-setup/shadow-workspace.html#step-1-create-shadow","text":"shadow my-project # or cp -r my-project my-project-shadow cd my-project-shadow","title":"Step 1: Create Shadow"},{"location":"dev-setup/shadow-workspace.html#step-2-work-with-amplifier","text":"amp > Refactor the authentication module > Add comprehensive tests > Update the documentation","title":"Step 2: Work with Amplifier"},{"location":"dev-setup/shadow-workspace.html#step-3-review-changes","text":"# See what changed diff -r ../my-project . --exclude = .git --exclude = node_modules # Or with git git diff git status","title":"Step 3: Review Changes"},{"location":"dev-setup/shadow-workspace.html#step-4-accept-or-reject","text":"Accept changes: # If using git worktree git add . git commit -m \"AI-assisted refactoring\" git checkout main git merge ai-changes # If manual copy cp -r . ../my-project Reject changes: # Just delete the shadow cd .. rm -rf my-project-shadow","title":"Step 4: Accept or Reject"},{"location":"dev-setup/shadow-workspace.html#best-practices","text":"","title":"Best Practices"},{"location":"dev-setup/shadow-workspace.html#keep-shadow-fresh","text":"Sync periodically: cd my-project-shadow rsync -av --exclude = '.git' ../my-project/ .","title":"Keep Shadow Fresh"},{"location":"dev-setup/shadow-workspace.html#use-git-worktrees-for-teams","text":"# Create feature branch worktree git worktree add ../feature-auth -b feature/auth-refactor # Work with AI cd ../feature-auth amp # Create PR when done gh pr create","title":"Use Git Worktrees for Teams"},{"location":"dev-setup/shadow-workspace.html#exclude-large-directories","text":"When copying: rsync -av --exclude = 'node_modules' --exclude = '.venv' \\ --exclude = 'dist' --exclude = 'build' \\ my-project/ my-project-shadow/","title":"Exclude Large Directories"},{"location":"dev-setup/shadow-workspace.html#multiple-shadows","text":"For comparing approaches: shadow my-project approach-a shadow my-project approach-b # Try different prompts in each cd ../approach-a && amp cd ../approach-b && amp # Compare results diff -r approach-a approach-b","title":"Multiple Shadows"},{"location":"dev-setup/shadow-workspace.html#shadow-script","text":"Create ~/bin/shadow : #!/bin/bash # Shadow workspace creator if [ -z \" $1 \" ] ; then echo \"Usage: shadow <project-dir> [shadow-name]\" exit 1 fi PROJECT = \" $1 \" SHADOW = \" ${ 2 :- $1 -shadow } \" if [ -d \" $SHADOW \" ] ; then echo \"Shadow already exists: $SHADOW \" cd \" $SHADOW \" else echo \"Creating shadow workspace: $SHADOW \" if [ -d \" $PROJECT /.git\" ] ; then # Use git worktree if possible cd \" $PROJECT \" git worktree add \"../ $SHADOW \" -b \"shadow- $( date +%Y%m%d-%H%M%S ) \" cd \"../ $SHADOW \" else # Fall back to copy cp -r \" $PROJECT \" \" $SHADOW \" cd \" $SHADOW \" fi echo \"Shadow workspace ready: $SHADOW \" fi # Start shell in shadow exec $SHELL","title":"Shadow Script"},{"location":"dev-setup/shadow-workspace.html#try-it-yourself","text":"","title":"Try It Yourself"},{"location":"dev-setup/shadow-workspace.html#exercise-1-create-shadow","text":"# Pick any project shadow my-project # Verify you're in shadow pwd","title":"Exercise 1: Create Shadow"},{"location":"dev-setup/shadow-workspace.html#exercise-2-make-ai-changes","text":"amp > Add input validation to all API endpoints","title":"Exercise 2: Make AI Changes"},{"location":"dev-setup/shadow-workspace.html#exercise-3-review-and-decide","text":"# See changes git diff # Accept or reject","title":"Exercise 3: Review and Decide"},{"location":"dev-setup/shadow-workspace.html#troubleshooting","text":"","title":"Troubleshooting"},{"location":"dev-setup/shadow-workspace.html#directory-already-exists","text":"rm -rf my-project-shadow shadow my-project","title":"\"Directory already exists\""},{"location":"dev-setup/shadow-workspace.html#large-projects-take-too-long","text":"Use rsync with exclusions: rsync -av --exclude = 'node_modules' --exclude = '.venv' \\ --progress my-project/ my-project-shadow/","title":"Large Projects Take Too Long"},{"location":"dev-setup/shadow-workspace.html#git-worktree-conflicts","text":"# Clean up orphaned worktree git worktree prune git worktree list","title":"Git Worktree Conflicts"},{"location":"dev-setup/shadow-workspace.html#next","text":"Learn about remote development options: \u2192 Remote Development","title":"Next"},{"location":"quickstart/index.html","text":"Quickstart Guide \u00b6 Get up and running with Amplifier in minutes. This section provides fast-track paths to productivity, whether you're exploring, building, or deploying. Follow these guides to go from zero to working application with minimal friction. Section Contents \u00b6 Page Description Installation Install Amplifier and dependencies First Conversation Start your first conversation What is Amplifier? Understanding the fundamentals How It's Different What sets Amplifier apart Your First Bundle Create a custom behavior package Key Commands Essential commands and workflows Quick Tips \u00b6 Start simple - Use the default bundle before customizing One provider first - Configure one LLM provider, add more later Check the logs - Most issues reveal themselves in session logs Use todo lists - Track complex tasks to stay organized Ask for help - The built-in agents can explain themselves Fast Track Paths \u00b6 Path 1: Explorer (10 minutes) \u00b6 Installation - Get Amplifier installed First Conversation - Have your first conversation Done! Explore from there. Path 2: Builder (30 minutes) \u00b6 Installation - Get set up What is Amplifier? - Understand the basics Your First Bundle - Create custom behavior Key Commands - Learn essential commands Path 3: Power User (1 hour) \u00b6 Complete Path 2 How It's Different - Master key concepts Explore Advanced topics Where to Start \u00b6 Never used Amplifier? Start with Installation and follow sequentially. Already installed? Jump to First Conversation to start working. Exploring concepts? Check out What is Amplifier? and How It's Different . Prerequisites Checklist \u00b6 Before you begin, ensure you have: [ ] Python 3.10 or higher [ ] An API key for at least one LLM provider [ ] A terminal/command line environment [ ] Git (optional, but recommended) Time Estimates \u00b6 Guide Time Difficulty Installation 5 min Easy First Session 5 min Easy Configuration 10 min Easy First Bundle 15 min Medium Using Agents 10 min Medium Next Steps \u00b6 After completing the quickstart, dive into Concepts for deeper understanding or Bundles for more customization.","title":"Overview"},{"location":"quickstart/index.html#quickstart-guide","text":"Get up and running with Amplifier in minutes. This section provides fast-track paths to productivity, whether you're exploring, building, or deploying. Follow these guides to go from zero to working application with minimal friction.","title":"Quickstart Guide"},{"location":"quickstart/index.html#section-contents","text":"Page Description Installation Install Amplifier and dependencies First Conversation Start your first conversation What is Amplifier? Understanding the fundamentals How It's Different What sets Amplifier apart Your First Bundle Create a custom behavior package Key Commands Essential commands and workflows","title":"Section Contents"},{"location":"quickstart/index.html#quick-tips","text":"Start simple - Use the default bundle before customizing One provider first - Configure one LLM provider, add more later Check the logs - Most issues reveal themselves in session logs Use todo lists - Track complex tasks to stay organized Ask for help - The built-in agents can explain themselves","title":"Quick Tips"},{"location":"quickstart/index.html#fast-track-paths","text":"","title":"Fast Track Paths"},{"location":"quickstart/index.html#path-1-explorer-10-minutes","text":"Installation - Get Amplifier installed First Conversation - Have your first conversation Done! Explore from there.","title":"Path 1: Explorer (10 minutes)"},{"location":"quickstart/index.html#path-2-builder-30-minutes","text":"Installation - Get set up What is Amplifier? - Understand the basics Your First Bundle - Create custom behavior Key Commands - Learn essential commands","title":"Path 2: Builder (30 minutes)"},{"location":"quickstart/index.html#path-3-power-user-1-hour","text":"Complete Path 2 How It's Different - Master key concepts Explore Advanced topics","title":"Path 3: Power User (1 hour)"},{"location":"quickstart/index.html#where-to-start","text":"Never used Amplifier? Start with Installation and follow sequentially. Already installed? Jump to First Conversation to start working. Exploring concepts? Check out What is Amplifier? and How It's Different .","title":"Where to Start"},{"location":"quickstart/index.html#prerequisites-checklist","text":"Before you begin, ensure you have: [ ] Python 3.10 or higher [ ] An API key for at least one LLM provider [ ] A terminal/command line environment [ ] Git (optional, but recommended)","title":"Prerequisites Checklist"},{"location":"quickstart/index.html#time-estimates","text":"Guide Time Difficulty Installation 5 min Easy First Session 5 min Easy Configuration 10 min Easy First Bundle 15 min Medium Using Agents 10 min Medium","title":"Time Estimates"},{"location":"quickstart/index.html#next-steps","text":"After completing the quickstart, dive into Concepts for deeper understanding or Bundles for more customization.","title":"Next Steps"},{"location":"quickstart/first-bundle.html","text":"Your First Bundle \u00b6 Bundles are the heart of the Amplifier ecosystem. They package skills, agents, recipes, and capabilities into reusable modules that extend your AI assistant's abilities. In this tutorial, you'll create a simple but practical bundle from scratch. What You'll Build \u00b6 You'll create a code-review bundle that helps review Python code for common issues. This bundle will include: A custom agent that specializes in code review A skill document with Python best practices A recipe for automated code review workflow By the end, you'll understand how to structure bundles, write agent instructions, and configure tools. Prerequisites \u00b6 Amplifier installed and configured Basic understanding of YAML format A text editor Step 1: Create Bundle Structure \u00b6 Every bundle needs a specific directory structure. Let's create it: mkdir -p ~/.amplifier/bundles/code-review cd ~/.amplifier/bundles/code-review Create the bundle manifest file bundle.yaml : name : code-review version : 1.0.0 description : \"Code review assistant for Python projects\" author : \"Your Name\" license : MIT # Define what this bundle provides provides : agents : - code-reviewer skills : - python-best-practices recipes : - review-pr This manifest tells Amplifier what your bundle provides and how to identify it. Create Directory Structure \u00b6 Create the directories for your bundle components: mkdir -p agents mkdir -p skills mkdir -p recipes Your bundle structure should now look like: ~/.amplifier/bundles/code-review/ \u251c\u2500\u2500 bundle.yaml \u251c\u2500\u2500 agents/ \u251c\u2500\u2500 skills/ \u2514\u2500\u2500 recipes/ Step 2: Create Your Agent \u00b6 Agents are specialized AI assistants with specific instructions. Create agents/code-reviewer.yaml : name : code-reviewer description : \"Reviews Python code for best practices and potential issues\" # Agent's system instructions instructions : | You are an expert Python code reviewer. Your goal is to help developers write better, more maintainable code. When reviewing code: 1. Check for PEP 8 style compliance 2. Look for potential bugs or logic errors 3. Identify security vulnerabilities 4. Suggest performance improvements 5. Recommend better naming or structure Always be constructive and educational in your feedback. Explain WHY something should change, not just WHAT to change. Format your reviews as: - **Issue**: Description of the problem - **Location**: File and line number - **Severity**: Critical / High / Medium / Low - **Recommendation**: Specific suggestion - **Explanation**: Why this matters # Tools this agent can use tools : - read_file - grep - glob - python_check - bash # Optional: Tool-specific configuration tool_config : python_check : checks : [ \"format\" , \"lint\" , \"types\" ] Understanding Agent Configuration \u00b6 instructions : The core prompt that defines the agent's behavior and expertise tools : Which capabilities the agent has access to tool_config : Optional settings for specific tools Step 3: Add Domain Knowledge with Skills \u00b6 Skills provide domain-specific knowledge. Create skills/python-best-practices.md : --- name: python-best-practices description: \"Python coding standards and best practices\" version: 1.0.0 --- # Python Best Practices ## Code Style Follow PEP 8 for consistent code style: - Use 4 spaces for indentation (never tabs) - Limit lines to 88 characters (Black formatter default) - Use snake_case for functions and variables - Use PascalCase for class names - Use UPPER_CASE for constants ## Common Pitfalls ### Mutable Default Arguments \u274c **Bad:** ```python def add_item(item, items=[]): items.append(item) return items \u2705 Good: def add_item ( item , items = None ): if items is None : items = [] items . append ( item ) return items Exception Handling \u00b6 \u274c Bad: try : risky_operation () except : pass \u2705 Good: try : risky_operation () except ValueError as e : logger . error ( f \"Invalid value: { e } \" ) raise Type Hints \u00b6 Always use type hints for function signatures: def greet ( name : str , age : int ) -> str : return f \"Hello { name } , you are { age } years old\" Documentation \u00b6 Use docstrings for all public modules, functions, classes, and methods: def calculate_total ( items : list [ float ], tax_rate : float ) -> float : \"\"\" Calculate total price including tax. Args: items: List of item prices tax_rate: Tax rate as decimal (e.g., 0.08 for 8%) Returns: Total price including tax Raises: ValueError: If tax_rate is negative \"\"\" if tax_rate < 0 : raise ValueError ( \"Tax rate cannot be negative\" ) subtotal = sum ( items ) return subtotal * ( 1 + tax_rate ) Testing \u00b6 Write tests for all public functions Aim for >80% code coverage Use pytest as the testing framework Keep tests isolated and independent Security \u00b6 Never hardcode secrets or credentials Validate all user input Use parameterized queries for SQL Keep dependencies updated ## Step 4: Create an Automated Recipe Recipes define multi-step workflows. Create `recipes/review-pr.yaml`: ```yaml name: review-pr description: \"Automated code review for pull requests\" version: 1.0.0 # Input context the recipe expects context_schema: pr_number: type: integer description: \"Pull request number to review\" required: true # Sequential workflow steps steps: - name: fetch_changes agent: foundation:git-ops instruction: | Get the list of changed files in PR #{{pr_number}}. Return the file paths as a list. - name: review_code agent: code-review:code-reviewer instruction: | Review the following changed files: {{fetch_changes.result}} For each file: 1. Read the file contents 2. Check for style issues using python_check 3. Review code quality and best practices 4. Identify potential bugs Provide a comprehensive review report. - name: summarize agent: core:core-expert instruction: | Summarize the code review: {{review_code.result}} Create a concise summary suitable for posting as a PR comment, organized by severity level. Step 5: Test Your Bundle \u00b6 First, verify your bundle is recognized: cd ~/.amplifier/bundles/code-review ls -la You should see: bundle.yaml agents/code-reviewer.yaml skills/python-best-practices.md recipes/review-pr.yaml Test the Agent \u00b6 Start Amplifier and try your agent: amplifier Then in the chat: @code-reviewer Please review this Python function: def calc(a, b): return a+b Your agent should provide feedback about missing type hints, naming, and documentation. Test the Recipe \u00b6 To test the recipe workflow: Run recipe code-review:review-pr with pr_number=42 Step 6: Refine and Iterate \u00b6 Now that your bundle works, you can enhance it: Add more patterns to the skill document Improve agent instructions based on review quality Add tool configurations for better defaults Create additional recipes for different workflows Next Steps \u00b6 Now that you've created your first bundle, explore: Bundles Guide - Deep dive into bundle design and best practices Advanced Topics - Custom bundles, recipes, and tools Concepts - Understand bundles, agents, and modules Skills Guide - Add domain knowledge to your bundles Share Your Bundle \u00b6 Consider sharing your bundle with the community: Publish to a Git repository Add to the Amplifier bundle registry Get feedback and contributions Troubleshooting \u00b6 Bundle not found : Ensure bundle.yaml is in ~/.amplifier/bundles/code-review/ Agent not working : Check that agent name in bundle.yaml matches the filename Recipe fails : Verify all referenced agents exist and have required tools Summary \u00b6 You've learned: \u2705 How to structure a bundle with manifest, agents, skills, and recipes \u2705 How to write agent instructions and configure tools \u2705 How to create skill documents with domain knowledge \u2705 How to build automated workflows with recipes \u2705 How to test and refine your bundle Bundles are powerful because they're composable\u2014your code-review bundle can be combined with other bundles to create even more sophisticated workflows. Happy building! \ud83d\ude80","title":"Your First Bundle"},{"location":"quickstart/first-bundle.html#your-first-bundle","text":"Bundles are the heart of the Amplifier ecosystem. They package skills, agents, recipes, and capabilities into reusable modules that extend your AI assistant's abilities. In this tutorial, you'll create a simple but practical bundle from scratch.","title":"Your First Bundle"},{"location":"quickstart/first-bundle.html#what-youll-build","text":"You'll create a code-review bundle that helps review Python code for common issues. This bundle will include: A custom agent that specializes in code review A skill document with Python best practices A recipe for automated code review workflow By the end, you'll understand how to structure bundles, write agent instructions, and configure tools.","title":"What You'll Build"},{"location":"quickstart/first-bundle.html#prerequisites","text":"Amplifier installed and configured Basic understanding of YAML format A text editor","title":"Prerequisites"},{"location":"quickstart/first-bundle.html#step-1-create-bundle-structure","text":"Every bundle needs a specific directory structure. Let's create it: mkdir -p ~/.amplifier/bundles/code-review cd ~/.amplifier/bundles/code-review Create the bundle manifest file bundle.yaml : name : code-review version : 1.0.0 description : \"Code review assistant for Python projects\" author : \"Your Name\" license : MIT # Define what this bundle provides provides : agents : - code-reviewer skills : - python-best-practices recipes : - review-pr This manifest tells Amplifier what your bundle provides and how to identify it.","title":"Step 1: Create Bundle Structure"},{"location":"quickstart/first-bundle.html#create-directory-structure","text":"Create the directories for your bundle components: mkdir -p agents mkdir -p skills mkdir -p recipes Your bundle structure should now look like: ~/.amplifier/bundles/code-review/ \u251c\u2500\u2500 bundle.yaml \u251c\u2500\u2500 agents/ \u251c\u2500\u2500 skills/ \u2514\u2500\u2500 recipes/","title":"Create Directory Structure"},{"location":"quickstart/first-bundle.html#step-2-create-your-agent","text":"Agents are specialized AI assistants with specific instructions. Create agents/code-reviewer.yaml : name : code-reviewer description : \"Reviews Python code for best practices and potential issues\" # Agent's system instructions instructions : | You are an expert Python code reviewer. Your goal is to help developers write better, more maintainable code. When reviewing code: 1. Check for PEP 8 style compliance 2. Look for potential bugs or logic errors 3. Identify security vulnerabilities 4. Suggest performance improvements 5. Recommend better naming or structure Always be constructive and educational in your feedback. Explain WHY something should change, not just WHAT to change. Format your reviews as: - **Issue**: Description of the problem - **Location**: File and line number - **Severity**: Critical / High / Medium / Low - **Recommendation**: Specific suggestion - **Explanation**: Why this matters # Tools this agent can use tools : - read_file - grep - glob - python_check - bash # Optional: Tool-specific configuration tool_config : python_check : checks : [ \"format\" , \"lint\" , \"types\" ]","title":"Step 2: Create Your Agent"},{"location":"quickstart/first-bundle.html#understanding-agent-configuration","text":"instructions : The core prompt that defines the agent's behavior and expertise tools : Which capabilities the agent has access to tool_config : Optional settings for specific tools","title":"Understanding Agent Configuration"},{"location":"quickstart/first-bundle.html#step-3-add-domain-knowledge-with-skills","text":"Skills provide domain-specific knowledge. Create skills/python-best-practices.md : --- name: python-best-practices description: \"Python coding standards and best practices\" version: 1.0.0 --- # Python Best Practices ## Code Style Follow PEP 8 for consistent code style: - Use 4 spaces for indentation (never tabs) - Limit lines to 88 characters (Black formatter default) - Use snake_case for functions and variables - Use PascalCase for class names - Use UPPER_CASE for constants ## Common Pitfalls ### Mutable Default Arguments \u274c **Bad:** ```python def add_item(item, items=[]): items.append(item) return items \u2705 Good: def add_item ( item , items = None ): if items is None : items = [] items . append ( item ) return items","title":"Step 3: Add Domain Knowledge with Skills"},{"location":"quickstart/first-bundle.html#exception-handling","text":"\u274c Bad: try : risky_operation () except : pass \u2705 Good: try : risky_operation () except ValueError as e : logger . error ( f \"Invalid value: { e } \" ) raise","title":"Exception Handling"},{"location":"quickstart/first-bundle.html#type-hints","text":"Always use type hints for function signatures: def greet ( name : str , age : int ) -> str : return f \"Hello { name } , you are { age } years old\"","title":"Type Hints"},{"location":"quickstart/first-bundle.html#documentation","text":"Use docstrings for all public modules, functions, classes, and methods: def calculate_total ( items : list [ float ], tax_rate : float ) -> float : \"\"\" Calculate total price including tax. Args: items: List of item prices tax_rate: Tax rate as decimal (e.g., 0.08 for 8%) Returns: Total price including tax Raises: ValueError: If tax_rate is negative \"\"\" if tax_rate < 0 : raise ValueError ( \"Tax rate cannot be negative\" ) subtotal = sum ( items ) return subtotal * ( 1 + tax_rate )","title":"Documentation"},{"location":"quickstart/first-bundle.html#testing","text":"Write tests for all public functions Aim for >80% code coverage Use pytest as the testing framework Keep tests isolated and independent","title":"Testing"},{"location":"quickstart/first-bundle.html#security","text":"Never hardcode secrets or credentials Validate all user input Use parameterized queries for SQL Keep dependencies updated ## Step 4: Create an Automated Recipe Recipes define multi-step workflows. Create `recipes/review-pr.yaml`: ```yaml name: review-pr description: \"Automated code review for pull requests\" version: 1.0.0 # Input context the recipe expects context_schema: pr_number: type: integer description: \"Pull request number to review\" required: true # Sequential workflow steps steps: - name: fetch_changes agent: foundation:git-ops instruction: | Get the list of changed files in PR #{{pr_number}}. Return the file paths as a list. - name: review_code agent: code-review:code-reviewer instruction: | Review the following changed files: {{fetch_changes.result}} For each file: 1. Read the file contents 2. Check for style issues using python_check 3. Review code quality and best practices 4. Identify potential bugs Provide a comprehensive review report. - name: summarize agent: core:core-expert instruction: | Summarize the code review: {{review_code.result}} Create a concise summary suitable for posting as a PR comment, organized by severity level.","title":"Security"},{"location":"quickstart/first-bundle.html#step-5-test-your-bundle","text":"First, verify your bundle is recognized: cd ~/.amplifier/bundles/code-review ls -la You should see: bundle.yaml agents/code-reviewer.yaml skills/python-best-practices.md recipes/review-pr.yaml","title":"Step 5: Test Your Bundle"},{"location":"quickstart/first-bundle.html#test-the-agent","text":"Start Amplifier and try your agent: amplifier Then in the chat: @code-reviewer Please review this Python function: def calc(a, b): return a+b Your agent should provide feedback about missing type hints, naming, and documentation.","title":"Test the Agent"},{"location":"quickstart/first-bundle.html#test-the-recipe","text":"To test the recipe workflow: Run recipe code-review:review-pr with pr_number=42","title":"Test the Recipe"},{"location":"quickstart/first-bundle.html#step-6-refine-and-iterate","text":"Now that your bundle works, you can enhance it: Add more patterns to the skill document Improve agent instructions based on review quality Add tool configurations for better defaults Create additional recipes for different workflows","title":"Step 6: Refine and Iterate"},{"location":"quickstart/first-bundle.html#next-steps","text":"Now that you've created your first bundle, explore: Bundles Guide - Deep dive into bundle design and best practices Advanced Topics - Custom bundles, recipes, and tools Concepts - Understand bundles, agents, and modules Skills Guide - Add domain knowledge to your bundles","title":"Next Steps"},{"location":"quickstart/first-bundle.html#share-your-bundle","text":"Consider sharing your bundle with the community: Publish to a Git repository Add to the Amplifier bundle registry Get feedback and contributions","title":"Share Your Bundle"},{"location":"quickstart/first-bundle.html#troubleshooting","text":"Bundle not found : Ensure bundle.yaml is in ~/.amplifier/bundles/code-review/ Agent not working : Check that agent name in bundle.yaml matches the filename Recipe fails : Verify all referenced agents exist and have required tools","title":"Troubleshooting"},{"location":"quickstart/first-bundle.html#summary","text":"You've learned: \u2705 How to structure a bundle with manifest, agents, skills, and recipes \u2705 How to write agent instructions and configure tools \u2705 How to create skill documents with domain knowledge \u2705 How to build automated workflows with recipes \u2705 How to test and refine your bundle Bundles are powerful because they're composable\u2014your code-review bundle can be combined with other bundles to create even more sophisticated workflows. Happy building! \ud83d\ude80","title":"Summary"},{"location":"quickstart/first-conversation.html","text":"Your First Conversation \u00b6 This guide walks you through your first interaction with Amplifier, helping you understand how to communicate effectively with the AI assistant and what to expect. Starting a Session \u00b6 Launch Amplifier from your terminal: amplifier run You'll see the Amplifier prompt appear: User: This means Amplifier is ready to receive your instructions. You're now in an interactive session where you can have a natural conversation with the AI assistant. Your First Prompt \u00b6 Start with something simple to get a feel for how Amplifier works. Here are some great first prompts: Example 1: Ask About Your Project \u00b6 What files are in the current directory? Amplifier will use the glob or bash tool to explore your workspace and provide a structured summary of what it finds. Example 2: Request Code Analysis \u00b6 Read the main.py file and explain what it does The assistant will use the read_file tool to access the file, then provide a detailed explanation of the code's functionality. Example 3: Simple Code Generation \u00b6 Create a Python function that calculates the factorial of a number Amplifier will write the code and can save it to a file if you specify a location. Example 4: Multi-Step Task \u00b6 Find all TODO comments in my Python files and create a summary This demonstrates Amplifier's ability to chain multiple operations: searching files, reading content, and synthesizing information. Understanding Responses \u00b6 Amplifier responses typically include several components: 1. Thinking Process (Sometimes Visible) \u00b6 The assistant may show its reasoning before taking action. This helps you understand its approach to solving your request. 2. Tool Usage \u00b6 You'll see when Amplifier uses tools to accomplish tasks: [Using read_file: ./src/main.py] [Using bash: pytest tests/] These indicators show what actions are being taken on your behalf. 3. Results and Explanations \u00b6 After using tools, Amplifier provides: - Summaries : Condensed information about what was found or done - Analysis : Interpretation of results - Code blocks : Formatted code with syntax highlighting - Recommendations : Suggestions for next steps 4. Error Handling \u00b6 If something goes wrong, Amplifier will: - Explain what happened - Suggest fixes or alternatives - Often retry with a different approach automatically Tool Usage \u00b6 Amplifier has access to various tools that extend its capabilities. Understanding these helps you make better requests. File Operations \u00b6 Reading files: Read the config.yaml file Writing files: Create a new file called utils.py with a helper function Editing files: Update the README.md to include installation instructions Code Quality \u00b6 Checking Python code: Check this Python file for errors and style issues Amplifier uses ruff for formatting/linting and pyright for type checking. Search Operations \u00b6 Finding files: Find all JavaScript files in the src directory Searching content: Search for all functions named \"calculate\" in Python files Command Execution \u00b6 Running tests: Run the test suite Installing packages: Install the requests library Git operations: Show me the git status Complex Tasks with Sub-Agents \u00b6 For complex, multi-step tasks, Amplifier can delegate work to specialized agents: Review the code I just wrote and suggest improvements This might spawn a code-reviewer agent that works autonomously. Best Practices for Prompts \u00b6 Be Specific \u00b6 \u274c Vague : \"Fix the code\" \u2705 Specific : \"Fix the syntax error in main.py on line 42\" Provide Context \u00b6 \u274c Minimal : \"Add a test\" \u2705 Contextual : \"Add a unit test for the calculate_total function that checks edge cases like negative numbers and zero\" Break Down Complex Requests \u00b6 For very complex tasks, consider breaking them into steps: 1. First, analyze the current authentication system 2. Then suggest improvements for security 3. Finally, implement the changes Or let Amplifier handle it all at once: Analyze the auth system, suggest security improvements, and implement them Iterate and Refine \u00b6 Don't worry about getting it perfect the first time. You can refine: Actually, make that function async instead Add error handling to the code you just wrote Common Workflows \u00b6 Code Review Workflow \u00b6 User: I just updated the payment processor. Can you review it? Assistant: [reads file, analyzes code, provides feedback] User: Make those changes Assistant: [edits file with improvements] User: Now add tests for the edge cases Assistant: [creates test file] Debugging Workflow \u00b6 User: My tests are failing Assistant: [runs tests, analyzes output] User: What's causing the failure? Assistant: [explains issue with specific line numbers] User: How do I fix it? Assistant: [provides solution and can implement it] Learning Workflow \u00b6 User: Explain how async/await works in Python Assistant: [provides explanation with examples] User: Show me a practical example Assistant: [creates working code example] User: What are common pitfalls? Assistant: [explains gotchas and best practices] Ending a Session \u00b6 To exit Amplifier, use: Ctrl+D ( or type 'exit' ) Your conversation history is saved, and any changes made to files are preserved in your workspace. Pro Tips \u00b6 Parallel Operations \u00b6 Request multiple things at once: Read both config.py and utils.py, then tell me how they interact Asking for Alternatives \u00b6 Show me three different ways to implement this feature Context Awareness \u00b6 Amplifier remembers your conversation history: User: Create a User class Assistant: [creates User class] User: Now add a method to validate email addresses Assistant: [knows which class you mean] Skill Loading \u00b6 For specialized domains: Load the REST API design skill and help me design an endpoint What Not to Expect \u00b6 No internet access by default : Amplifier works with local files (unless web-research agent is used) No memory between sessions : Each session starts fresh No real-time interactions : Can't run interactive programs directly No destructive operations without review : Safety guardrails prevent accidental damage Next Steps \u00b6 Now that you understand the basics, explore: Key Commands - Essential commands and workflows Your First Bundle - Create custom behavior packages Concepts - Deeper understanding of how Amplifier works Tools - Complete documentation of available tools Try experimenting with different types of requests to discover what Amplifier can do for you! Quick Reference Card \u00b6 Task Example Prompt Read a file Show me the contents of app.py Edit code Add error handling to the save function Run tests Run pytest and show me the results Search code Find all TODO comments Get help How do I use the grep tool? Check code quality Check this Python file for issues Create files Create a new module for database operations Explain code Explain what the authenticate function does Ready to dive deeper? Continue to Key Commands to learn about Amplifier's capabilities in detail.","title":"Your First Conversation"},{"location":"quickstart/first-conversation.html#your-first-conversation","text":"This guide walks you through your first interaction with Amplifier, helping you understand how to communicate effectively with the AI assistant and what to expect.","title":"Your First Conversation"},{"location":"quickstart/first-conversation.html#starting-a-session","text":"Launch Amplifier from your terminal: amplifier run You'll see the Amplifier prompt appear: User: This means Amplifier is ready to receive your instructions. You're now in an interactive session where you can have a natural conversation with the AI assistant.","title":"Starting a Session"},{"location":"quickstart/first-conversation.html#your-first-prompt","text":"Start with something simple to get a feel for how Amplifier works. Here are some great first prompts:","title":"Your First Prompt"},{"location":"quickstart/first-conversation.html#example-1-ask-about-your-project","text":"What files are in the current directory? Amplifier will use the glob or bash tool to explore your workspace and provide a structured summary of what it finds.","title":"Example 1: Ask About Your Project"},{"location":"quickstart/first-conversation.html#example-2-request-code-analysis","text":"Read the main.py file and explain what it does The assistant will use the read_file tool to access the file, then provide a detailed explanation of the code's functionality.","title":"Example 2: Request Code Analysis"},{"location":"quickstart/first-conversation.html#example-3-simple-code-generation","text":"Create a Python function that calculates the factorial of a number Amplifier will write the code and can save it to a file if you specify a location.","title":"Example 3: Simple Code Generation"},{"location":"quickstart/first-conversation.html#example-4-multi-step-task","text":"Find all TODO comments in my Python files and create a summary This demonstrates Amplifier's ability to chain multiple operations: searching files, reading content, and synthesizing information.","title":"Example 4: Multi-Step Task"},{"location":"quickstart/first-conversation.html#understanding-responses","text":"Amplifier responses typically include several components:","title":"Understanding Responses"},{"location":"quickstart/first-conversation.html#1-thinking-process-sometimes-visible","text":"The assistant may show its reasoning before taking action. This helps you understand its approach to solving your request.","title":"1. Thinking Process (Sometimes Visible)"},{"location":"quickstart/first-conversation.html#2-tool-usage","text":"You'll see when Amplifier uses tools to accomplish tasks: [Using read_file: ./src/main.py] [Using bash: pytest tests/] These indicators show what actions are being taken on your behalf.","title":"2. Tool Usage"},{"location":"quickstart/first-conversation.html#3-results-and-explanations","text":"After using tools, Amplifier provides: - Summaries : Condensed information about what was found or done - Analysis : Interpretation of results - Code blocks : Formatted code with syntax highlighting - Recommendations : Suggestions for next steps","title":"3. Results and Explanations"},{"location":"quickstart/first-conversation.html#4-error-handling","text":"If something goes wrong, Amplifier will: - Explain what happened - Suggest fixes or alternatives - Often retry with a different approach automatically","title":"4. Error Handling"},{"location":"quickstart/first-conversation.html#tool-usage","text":"Amplifier has access to various tools that extend its capabilities. Understanding these helps you make better requests.","title":"Tool Usage"},{"location":"quickstart/first-conversation.html#file-operations","text":"Reading files: Read the config.yaml file Writing files: Create a new file called utils.py with a helper function Editing files: Update the README.md to include installation instructions","title":"File Operations"},{"location":"quickstart/first-conversation.html#code-quality","text":"Checking Python code: Check this Python file for errors and style issues Amplifier uses ruff for formatting/linting and pyright for type checking.","title":"Code Quality"},{"location":"quickstart/first-conversation.html#search-operations","text":"Finding files: Find all JavaScript files in the src directory Searching content: Search for all functions named \"calculate\" in Python files","title":"Search Operations"},{"location":"quickstart/first-conversation.html#command-execution","text":"Running tests: Run the test suite Installing packages: Install the requests library Git operations: Show me the git status","title":"Command Execution"},{"location":"quickstart/first-conversation.html#complex-tasks-with-sub-agents","text":"For complex, multi-step tasks, Amplifier can delegate work to specialized agents: Review the code I just wrote and suggest improvements This might spawn a code-reviewer agent that works autonomously.","title":"Complex Tasks with Sub-Agents"},{"location":"quickstart/first-conversation.html#best-practices-for-prompts","text":"","title":"Best Practices for Prompts"},{"location":"quickstart/first-conversation.html#be-specific","text":"\u274c Vague : \"Fix the code\" \u2705 Specific : \"Fix the syntax error in main.py on line 42\"","title":"Be Specific"},{"location":"quickstart/first-conversation.html#provide-context","text":"\u274c Minimal : \"Add a test\" \u2705 Contextual : \"Add a unit test for the calculate_total function that checks edge cases like negative numbers and zero\"","title":"Provide Context"},{"location":"quickstart/first-conversation.html#break-down-complex-requests","text":"For very complex tasks, consider breaking them into steps: 1. First, analyze the current authentication system 2. Then suggest improvements for security 3. Finally, implement the changes Or let Amplifier handle it all at once: Analyze the auth system, suggest security improvements, and implement them","title":"Break Down Complex Requests"},{"location":"quickstart/first-conversation.html#iterate-and-refine","text":"Don't worry about getting it perfect the first time. You can refine: Actually, make that function async instead Add error handling to the code you just wrote","title":"Iterate and Refine"},{"location":"quickstart/first-conversation.html#common-workflows","text":"","title":"Common Workflows"},{"location":"quickstart/first-conversation.html#code-review-workflow","text":"User: I just updated the payment processor. Can you review it? Assistant: [reads file, analyzes code, provides feedback] User: Make those changes Assistant: [edits file with improvements] User: Now add tests for the edge cases Assistant: [creates test file]","title":"Code Review Workflow"},{"location":"quickstart/first-conversation.html#debugging-workflow","text":"User: My tests are failing Assistant: [runs tests, analyzes output] User: What's causing the failure? Assistant: [explains issue with specific line numbers] User: How do I fix it? Assistant: [provides solution and can implement it]","title":"Debugging Workflow"},{"location":"quickstart/first-conversation.html#learning-workflow","text":"User: Explain how async/await works in Python Assistant: [provides explanation with examples] User: Show me a practical example Assistant: [creates working code example] User: What are common pitfalls? Assistant: [explains gotchas and best practices]","title":"Learning Workflow"},{"location":"quickstart/first-conversation.html#ending-a-session","text":"To exit Amplifier, use: Ctrl+D ( or type 'exit' ) Your conversation history is saved, and any changes made to files are preserved in your workspace.","title":"Ending a Session"},{"location":"quickstart/first-conversation.html#pro-tips","text":"","title":"Pro Tips"},{"location":"quickstart/first-conversation.html#parallel-operations","text":"Request multiple things at once: Read both config.py and utils.py, then tell me how they interact","title":"Parallel Operations"},{"location":"quickstart/first-conversation.html#asking-for-alternatives","text":"Show me three different ways to implement this feature","title":"Asking for Alternatives"},{"location":"quickstart/first-conversation.html#context-awareness","text":"Amplifier remembers your conversation history: User: Create a User class Assistant: [creates User class] User: Now add a method to validate email addresses Assistant: [knows which class you mean]","title":"Context Awareness"},{"location":"quickstart/first-conversation.html#skill-loading","text":"For specialized domains: Load the REST API design skill and help me design an endpoint","title":"Skill Loading"},{"location":"quickstart/first-conversation.html#what-not-to-expect","text":"No internet access by default : Amplifier works with local files (unless web-research agent is used) No memory between sessions : Each session starts fresh No real-time interactions : Can't run interactive programs directly No destructive operations without review : Safety guardrails prevent accidental damage","title":"What Not to Expect"},{"location":"quickstart/first-conversation.html#next-steps","text":"Now that you understand the basics, explore: Key Commands - Essential commands and workflows Your First Bundle - Create custom behavior packages Concepts - Deeper understanding of how Amplifier works Tools - Complete documentation of available tools Try experimenting with different types of requests to discover what Amplifier can do for you!","title":"Next Steps"},{"location":"quickstart/first-conversation.html#quick-reference-card","text":"Task Example Prompt Read a file Show me the contents of app.py Edit code Add error handling to the save function Run tests Run pytest and show me the results Search code Find all TODO comments Get help How do I use the grep tool? Check code quality Check this Python file for issues Create files Create a new module for database operations Explain code Explain what the authenticate function does Ready to dive deeper? Continue to Key Commands to learn about Amplifier's capabilities in detail.","title":"Quick Reference Card"},{"location":"quickstart/how-its-different.html","text":"How Amplifier is Different \u00b6 Amplifier takes a fundamentally different approach to building AI-powered applications. Rather than providing a monolithic framework or a simple API wrapper, Amplifier offers a modular kernel that you compose into exactly what you need. Comparison Overview \u00b6 Most AI development tools fall into one of two categories: Approach Examples Trade-offs Monolithic Frameworks Full-stack AI platforms Feature-rich but opinionated, hard to customize API Wrappers Thin client libraries Flexible but low-level, requires building everything Amplifier Modular kernel + bundles Compose what you need, extend without forking What Makes Amplifier Different \u00b6 Kernel + Module Architecture : A minimal core with pluggable capabilities Composition Over Configuration : Build your stack by composing bundles First-Class Multi-Agent Support : Agents that collaborate, not just respond Open Source Philosophy : Inspect, modify, and contribute to every layer Modular Architecture \u00b6 Amplifier's architecture follows the \"bricks and studs\" philosophy\u2014small, well-defined modules that snap together through standard interfaces. The Kernel \u00b6 The kernel is intentionally minimal. It provides: Session lifecycle management : Start, run, persist, resume Event system : Hooks and observers for extensibility Module protocol : Standard contracts for all module types Provider abstraction : Swap LLM backends without code changes The kernel does NOT include: - Specific tools or capabilities - Business logic - Opinionated workflows Module Types \u00b6 Amplifier defines clear module contracts: Provider \u2192 LLM backends (Anthropic, OpenAI, Azure, etc.) Tool \u2192 Capabilities the agent can use Hook \u2192 Intercept and modify agent behavior Observer \u2192 React to events without modification Context \u2192 Inject information into agent sessions Bundles: Composable Capability Packs \u00b6 Bundles group related modules into reusable packages: # Example: A bundle for web development name : web-dev-bundle modules : tools : - browser-automation - http-client - html-parser context : - web-standards - accessibility-guidelines You compose your Amplifier instance by selecting bundles: # Your application's bundle composition extends : - foundation # Core capabilities - web-dev-bundle # Web development tools - your-custom-bundle # Your domain-specific additions Extensibility \u00b6 Traditional frameworks force a choice: use what they provide, or fork and maintain your own version. Amplifier offers a third path. Extend Without Forking \u00b6 Every extension point in Amplifier is designed for external modification: Extension Point What You Can Do Providers Add new LLM backends or modify existing ones Tools Create custom tools with full type safety Hooks Transform requests/responses in the agent loop Observers Add logging, metrics, or side effects Context Inject domain knowledge and instructions Hook System Example \u00b6 Hooks let you intercept the agent loop at defined points: class ContentFilterHook ( Hook ): \"\"\"Filter sensitive content before it reaches the LLM.\"\"\" async def pre_request ( self , messages : list ) -> list : return [ self . filter_pii ( m ) for m in messages ] async def post_response ( self , response : Response ) -> Response : return self . validate_output ( response ) Skills: Loadable Domain Knowledge \u00b6 Skills are structured knowledge that agents can load on demand: # Agent loads a skill for specific domain expertise load_skill ( \"python-standards\" ) load_skill ( \"security-best-practices\" ) Skills keep specialized knowledge modular and maintainable. Multi-Agent \u00b6 Amplifier treats multi-agent patterns as first-class citizens, not afterthoughts. Agent Hierarchy \u00b6 Agents in Amplifier can spawn sub-agents for specialized tasks: Main Agent \u251c\u2500\u2500 Explorer Agent \u2192 Deep codebase reconnaissance \u251c\u2500\u2500 Builder Agent \u2192 Implementation from specs \u251c\u2500\u2500 Reviewer Agent \u2192 Code quality assessment \u2514\u2500\u2500 Test Agent \u2192 Verification and validation Delegation Patterns \u00b6 The task tool enables clean agent delegation: # Main agent delegates to a specialist result = await task ( agent = \"foundation:bug-hunter\" , instruction = \"Investigate the KeyError in auth.py line 42\" ) Each sub-agent: - Runs in its own session - Has its own tool access - Returns a structured result - Cannot access parent context (isolation by default) Parallel Execution \u00b6 Independent tasks run in parallel: # These execute concurrently results = await parallel ([ task ( agent = \"test-runner\" , instruction = \"Run unit tests\" ), task ( agent = \"linter\" , instruction = \"Check code style\" ), task ( agent = \"security\" , instruction = \"Scan for vulnerabilities\" ), ]) Recipes: Declarative Workflows \u00b6 For complex multi-step workflows, Amplifier provides recipes: name : code-review-workflow steps : - agent : explorer instruction : Map the codebase structure - agent : reviewer instruction : Review changes against standards depends_on : [ 0 ] - agent : summarizer instruction : Create review summary depends_on : [ 1 ] Open Source \u00b6 Amplifier is fully open source under the MIT license. But open source means more than just \"the code is available.\" Inspect Everything \u00b6 Every layer of Amplifier is transparent: Kernel source : See exactly how the agent loop works Bundle contents : Inspect any tool, hook, or context Session logs : Full event history for debugging Decision traces : Understand why agents made choices Modify Anything \u00b6 You can override any component: # Override a specific tool from a bundle modules : tools : - name : file-writer override : my-custom-file-writer Contribute Back \u00b6 The modular architecture makes contributions clean: Add a new provider? Create a provider module Build a useful tool? Package it as a bundle Improve the kernel? Submit a focused PR No need to understand the entire codebase to contribute meaningfully. Community-Driven Evolution \u00b6 Amplifier's design supports: Bundle ecosystem : Share and discover community bundles Skill libraries : Domain knowledge anyone can contribute Recipe patterns : Proven workflows for common tasks Summary \u00b6 Aspect Traditional Approach Amplifier Approach Architecture Monolithic or minimal Modular kernel + composable bundles Customization Fork or workaround Extend through standard contracts Multi-Agent Manual orchestration First-class delegation and recipes Transparency Black box behaviors Full inspection at every layer Philosophy Feature accumulation Ruthless simplicity Amplifier isn't trying to be everything to everyone. It's designed to be exactly what you need\u2014composed from well-defined pieces that you control. Next Steps \u00b6 Installation : Get Amplifier installed and ready First Conversation : Start your first session Concepts : Understand the fundamental building blocks Bundles : Learn to compose your own stack","title":"How It's Different"},{"location":"quickstart/how-its-different.html#how-amplifier-is-different","text":"Amplifier takes a fundamentally different approach to building AI-powered applications. Rather than providing a monolithic framework or a simple API wrapper, Amplifier offers a modular kernel that you compose into exactly what you need.","title":"How Amplifier is Different"},{"location":"quickstart/how-its-different.html#comparison-overview","text":"Most AI development tools fall into one of two categories: Approach Examples Trade-offs Monolithic Frameworks Full-stack AI platforms Feature-rich but opinionated, hard to customize API Wrappers Thin client libraries Flexible but low-level, requires building everything Amplifier Modular kernel + bundles Compose what you need, extend without forking","title":"Comparison Overview"},{"location":"quickstart/how-its-different.html#what-makes-amplifier-different","text":"Kernel + Module Architecture : A minimal core with pluggable capabilities Composition Over Configuration : Build your stack by composing bundles First-Class Multi-Agent Support : Agents that collaborate, not just respond Open Source Philosophy : Inspect, modify, and contribute to every layer","title":"What Makes Amplifier Different"},{"location":"quickstart/how-its-different.html#modular-architecture","text":"Amplifier's architecture follows the \"bricks and studs\" philosophy\u2014small, well-defined modules that snap together through standard interfaces.","title":"Modular Architecture"},{"location":"quickstart/how-its-different.html#the-kernel","text":"The kernel is intentionally minimal. It provides: Session lifecycle management : Start, run, persist, resume Event system : Hooks and observers for extensibility Module protocol : Standard contracts for all module types Provider abstraction : Swap LLM backends without code changes The kernel does NOT include: - Specific tools or capabilities - Business logic - Opinionated workflows","title":"The Kernel"},{"location":"quickstart/how-its-different.html#module-types","text":"Amplifier defines clear module contracts: Provider \u2192 LLM backends (Anthropic, OpenAI, Azure, etc.) Tool \u2192 Capabilities the agent can use Hook \u2192 Intercept and modify agent behavior Observer \u2192 React to events without modification Context \u2192 Inject information into agent sessions","title":"Module Types"},{"location":"quickstart/how-its-different.html#bundles-composable-capability-packs","text":"Bundles group related modules into reusable packages: # Example: A bundle for web development name : web-dev-bundle modules : tools : - browser-automation - http-client - html-parser context : - web-standards - accessibility-guidelines You compose your Amplifier instance by selecting bundles: # Your application's bundle composition extends : - foundation # Core capabilities - web-dev-bundle # Web development tools - your-custom-bundle # Your domain-specific additions","title":"Bundles: Composable Capability Packs"},{"location":"quickstart/how-its-different.html#extensibility","text":"Traditional frameworks force a choice: use what they provide, or fork and maintain your own version. Amplifier offers a third path.","title":"Extensibility"},{"location":"quickstart/how-its-different.html#extend-without-forking","text":"Every extension point in Amplifier is designed for external modification: Extension Point What You Can Do Providers Add new LLM backends or modify existing ones Tools Create custom tools with full type safety Hooks Transform requests/responses in the agent loop Observers Add logging, metrics, or side effects Context Inject domain knowledge and instructions","title":"Extend Without Forking"},{"location":"quickstart/how-its-different.html#hook-system-example","text":"Hooks let you intercept the agent loop at defined points: class ContentFilterHook ( Hook ): \"\"\"Filter sensitive content before it reaches the LLM.\"\"\" async def pre_request ( self , messages : list ) -> list : return [ self . filter_pii ( m ) for m in messages ] async def post_response ( self , response : Response ) -> Response : return self . validate_output ( response )","title":"Hook System Example"},{"location":"quickstart/how-its-different.html#skills-loadable-domain-knowledge","text":"Skills are structured knowledge that agents can load on demand: # Agent loads a skill for specific domain expertise load_skill ( \"python-standards\" ) load_skill ( \"security-best-practices\" ) Skills keep specialized knowledge modular and maintainable.","title":"Skills: Loadable Domain Knowledge"},{"location":"quickstart/how-its-different.html#multi-agent","text":"Amplifier treats multi-agent patterns as first-class citizens, not afterthoughts.","title":"Multi-Agent"},{"location":"quickstart/how-its-different.html#agent-hierarchy","text":"Agents in Amplifier can spawn sub-agents for specialized tasks: Main Agent \u251c\u2500\u2500 Explorer Agent \u2192 Deep codebase reconnaissance \u251c\u2500\u2500 Builder Agent \u2192 Implementation from specs \u251c\u2500\u2500 Reviewer Agent \u2192 Code quality assessment \u2514\u2500\u2500 Test Agent \u2192 Verification and validation","title":"Agent Hierarchy"},{"location":"quickstart/how-its-different.html#delegation-patterns","text":"The task tool enables clean agent delegation: # Main agent delegates to a specialist result = await task ( agent = \"foundation:bug-hunter\" , instruction = \"Investigate the KeyError in auth.py line 42\" ) Each sub-agent: - Runs in its own session - Has its own tool access - Returns a structured result - Cannot access parent context (isolation by default)","title":"Delegation Patterns"},{"location":"quickstart/how-its-different.html#parallel-execution","text":"Independent tasks run in parallel: # These execute concurrently results = await parallel ([ task ( agent = \"test-runner\" , instruction = \"Run unit tests\" ), task ( agent = \"linter\" , instruction = \"Check code style\" ), task ( agent = \"security\" , instruction = \"Scan for vulnerabilities\" ), ])","title":"Parallel Execution"},{"location":"quickstart/how-its-different.html#recipes-declarative-workflows","text":"For complex multi-step workflows, Amplifier provides recipes: name : code-review-workflow steps : - agent : explorer instruction : Map the codebase structure - agent : reviewer instruction : Review changes against standards depends_on : [ 0 ] - agent : summarizer instruction : Create review summary depends_on : [ 1 ]","title":"Recipes: Declarative Workflows"},{"location":"quickstart/how-its-different.html#open-source","text":"Amplifier is fully open source under the MIT license. But open source means more than just \"the code is available.\"","title":"Open Source"},{"location":"quickstart/how-its-different.html#inspect-everything","text":"Every layer of Amplifier is transparent: Kernel source : See exactly how the agent loop works Bundle contents : Inspect any tool, hook, or context Session logs : Full event history for debugging Decision traces : Understand why agents made choices","title":"Inspect Everything"},{"location":"quickstart/how-its-different.html#modify-anything","text":"You can override any component: # Override a specific tool from a bundle modules : tools : - name : file-writer override : my-custom-file-writer","title":"Modify Anything"},{"location":"quickstart/how-its-different.html#contribute-back","text":"The modular architecture makes contributions clean: Add a new provider? Create a provider module Build a useful tool? Package it as a bundle Improve the kernel? Submit a focused PR No need to understand the entire codebase to contribute meaningfully.","title":"Contribute Back"},{"location":"quickstart/how-its-different.html#community-driven-evolution","text":"Amplifier's design supports: Bundle ecosystem : Share and discover community bundles Skill libraries : Domain knowledge anyone can contribute Recipe patterns : Proven workflows for common tasks","title":"Community-Driven Evolution"},{"location":"quickstart/how-its-different.html#summary","text":"Aspect Traditional Approach Amplifier Approach Architecture Monolithic or minimal Modular kernel + composable bundles Customization Fork or workaround Extend through standard contracts Multi-Agent Manual orchestration First-class delegation and recipes Transparency Black box behaviors Full inspection at every layer Philosophy Feature accumulation Ruthless simplicity Amplifier isn't trying to be everything to everyone. It's designed to be exactly what you need\u2014composed from well-defined pieces that you control.","title":"Summary"},{"location":"quickstart/how-its-different.html#next-steps","text":"Installation : Get Amplifier installed and ready First Conversation : Start your first session Concepts : Understand the fundamental building blocks Bundles : Learn to compose your own stack","title":"Next Steps"},{"location":"quickstart/installation.html","text":"Installation \u00b6 This guide walks you through installing Amplifier, a powerful AI development platform that extends Claude's capabilities with specialized tools, agents, and workflows. Prerequisites \u00b6 Before installing Amplifier, ensure your system meets these requirements: Required \u00b6 Python 3.10 or higher - Amplifier requires modern Python features Check your version: python --version or python3 --version Download from python.org if needed Recommended \u00b6 Git - For version control and cloning repositories Terminal - Command-line access (Terminal on macOS/Linux, PowerShell or WSL on Windows) Anthropic API Key - Required for Claude access Get yours at console.anthropic.com Quick Install \u00b6 For most users, the fastest way to get started: # Install UV package manager curl -LsSf https://astral.sh/uv/install.sh | sh # Install Amplifier uvx amplifier # Run setup wizard amplifier init # Verify installation amplifier version Detailed Installation Steps \u00b6 Step 1: Install UV Package Manager \u00b6 UV is a fast, reliable Python package installer and resolver. Amplifier uses UV for efficient dependency management. On macOS and Linux: curl -LsSf https://astral.sh/uv/install.sh | sh On Windows (PowerShell): powershell -c \"irm https://astral.sh/uv/install.ps1 | iex\" Verify UV installation: uv --version You should see output like uv 0.x.x . Alternative: Install UV with pip: pip install uv Step 2: Install Amplifier \u00b6 Once UV is installed, you can install Amplifier using uvx , which runs packages in isolated environments: uvx amplifier This command will: - Download the latest version of Amplifier - Install all required dependencies - Make the amplifier command available in your terminal Alternative: Install globally with pip: pip install amplifier Alternative: Install from source: git clone https://github.com/yourusername/amplifier.git cd amplifier pip install -e . Step 3: Run the Setup Wizard \u00b6 The setup wizard helps you configure Amplifier for first use: amplifier init The wizard will guide you through: API Key Configuration - Enter your Anthropic API key Default Model Selection - Choose your preferred Claude model Workspace Setup - Configure your default workspace directory Bundle Installation - Install recommended bundles (optional) Example wizard session: Welcome to Amplifier Setup! ? Enter your Anthropic API key: sk-ant-*************** \u2713 API key validated successfully ? Select default model: > claude-3-5-sonnet-20241022 (recommended) claude-3-opus-20240229 claude-3-haiku-20240307 ? Workspace directory: ~/amplifier-workspace \u2713 Workspace created at /home/user/amplifier-workspace ? Install recommended bundles? (Y/n): Y \u2713 Installing foundation bundle... \u2713 Installing python-dev bundle... \u2713 Installing recipes bundle... Setup complete! Run 'amplifier chat' to start. Step 4: Verify Installation \u00b6 Confirm everything is working correctly: # Check version amplifier version # View available commands amplifier --help # Test connection amplifier test-connection # List installed bundles amplifier bundle list Expected output for amplifier version : Amplifier v1.0.0 Python 3.11.5 UV 0.4.0 Claude API: Connected Platform-Specific Notes \u00b6 macOS \u00b6 Homebrew installation (coming soon): brew install amplifier Shell configuration: Add to your ~/.zshrc or ~/.bash_profile : export PATH = \" $HOME /.local/bin: $PATH \" Linux \u00b6 System dependencies: On Debian/Ubuntu: sudo apt update sudo apt install python3-pip git curl On Fedora/RHEL: sudo dnf install python3-pip git curl Shell configuration: Add to your ~/.bashrc : export PATH = \" $HOME /.local/bin: $PATH \" Windows \u00b6 Recommended: Use WSL2 (Windows Subsystem for Linux) Install WSL2: wsl --install Open Ubuntu terminal Follow Linux installation steps Native Windows installation: Use PowerShell (not CMD) Install Python from Microsoft Store or python.org Ensure Python is in your PATH Common Windows issue: If you see \"command not found\" errors, add Python to PATH: [Environment] :: SetEnvironmentVariable ( \"Path\" , \"$env:Path;$env:LOCALAPPDATA\\Programs\\Python\\Python311\\Scripts\" , \"User\" ) Configuration \u00b6 API Key Setup \u00b6 Amplifier needs your Anthropic API key to communicate with Claude. You can configure it in several ways: Option 1: Setup wizard (recommended) amplifier init Option 2: Environment variable export ANTHROPIC_API_KEY = \"sk-ant-your-key-here\" Add to your ~/.bashrc or ~/.zshrc to persist. Option 3: Configuration file Create ~/.config/amplifier/config.yaml : api_key : sk-ant-your-key-here default_model : claude-3-5-sonnet-20241022 workspace : ~/amplifier-workspace Option 4: Command-line flag amplifier chat --api-key sk-ant-your-key-here Workspace Configuration \u00b6 Your workspace is where Amplifier stores projects, skills, and bundles: # Set default workspace amplifier config set workspace ~/my-workspace # View current configuration amplifier config show Common Issues \u00b6 Issue: \"command not found: amplifier\" \u00b6 Solution: Ensure the installation directory is in your PATH: echo $PATH | grep -q \" $HOME /.local/bin\" || export PATH = \" $HOME /.local/bin: $PATH \" Make it permanent by adding to your shell config file. Issue: \"API key not configured\" \u00b6 Solution: Run the setup wizard or set the environment variable: amplifier init # or export ANTHROPIC_API_KEY = \"your-key-here\" Issue: \"Python version too old\" \u00b6 Solution: Upgrade Python to 3.10 or higher: # macOS with Homebrew brew install python@3.11 # Ubuntu/Debian sudo apt install python3.11 # Windows # Download from python.org Issue: \"Permission denied\" during installation \u00b6 Solution: Don't use sudo with pip. Install for your user: pip install --user amplifier Issue: UV installation fails \u00b6 Solution: Install via pip instead: pip install uv Then retry Amplifier installation. Issue: SSL certificate verification failed \u00b6 Solution: Update your system's CA certificates: # macOS brew install ca-certificates # Ubuntu/Debian sudo apt install ca-certificates Verifying Your Installation \u00b6 Run this comprehensive check: # Check all components amplifier doctor # Test API connection amplifier test-connection # List available tools amplifier tools list # View system info amplifier info Next Steps \u00b6 Now that Amplifier is installed, you're ready to start building: First Conversation - Have your first chat with Amplifier Key Commands - Learn essential commands First Bundle - Create your first custom bundle Core Concepts - Understand Amplifier's architecture Getting Help \u00b6 If you encounter issues not covered here: Documentation : amplifier.dev/docs GitHub Issues : github.com/yourusername/amplifier/issues Community Discord : discord.gg/amplifier Email Support : support@amplifier.dev Updating Amplifier \u00b6 To update to the latest version: # With uvx uvx --refresh amplifier # With pip pip install --upgrade amplifier # View changelog amplifier changelog Uninstalling \u00b6 If you need to remove Amplifier: # With pip pip uninstall amplifier # Remove configuration rm -rf ~/.config/amplifier # Remove workspace (optional) rm -rf ~/amplifier-workspace Ready to start? Run amplifier chat and say hello to your AI development assistant!","title":"Installation"},{"location":"quickstart/installation.html#installation","text":"This guide walks you through installing Amplifier, a powerful AI development platform that extends Claude's capabilities with specialized tools, agents, and workflows.","title":"Installation"},{"location":"quickstart/installation.html#prerequisites","text":"Before installing Amplifier, ensure your system meets these requirements:","title":"Prerequisites"},{"location":"quickstart/installation.html#required","text":"Python 3.10 or higher - Amplifier requires modern Python features Check your version: python --version or python3 --version Download from python.org if needed","title":"Required"},{"location":"quickstart/installation.html#recommended","text":"Git - For version control and cloning repositories Terminal - Command-line access (Terminal on macOS/Linux, PowerShell or WSL on Windows) Anthropic API Key - Required for Claude access Get yours at console.anthropic.com","title":"Recommended"},{"location":"quickstart/installation.html#quick-install","text":"For most users, the fastest way to get started: # Install UV package manager curl -LsSf https://astral.sh/uv/install.sh | sh # Install Amplifier uvx amplifier # Run setup wizard amplifier init # Verify installation amplifier version","title":"Quick Install"},{"location":"quickstart/installation.html#detailed-installation-steps","text":"","title":"Detailed Installation Steps"},{"location":"quickstart/installation.html#step-1-install-uv-package-manager","text":"UV is a fast, reliable Python package installer and resolver. Amplifier uses UV for efficient dependency management. On macOS and Linux: curl -LsSf https://astral.sh/uv/install.sh | sh On Windows (PowerShell): powershell -c \"irm https://astral.sh/uv/install.ps1 | iex\" Verify UV installation: uv --version You should see output like uv 0.x.x . Alternative: Install UV with pip: pip install uv","title":"Step 1: Install UV Package Manager"},{"location":"quickstart/installation.html#step-2-install-amplifier","text":"Once UV is installed, you can install Amplifier using uvx , which runs packages in isolated environments: uvx amplifier This command will: - Download the latest version of Amplifier - Install all required dependencies - Make the amplifier command available in your terminal Alternative: Install globally with pip: pip install amplifier Alternative: Install from source: git clone https://github.com/yourusername/amplifier.git cd amplifier pip install -e .","title":"Step 2: Install Amplifier"},{"location":"quickstart/installation.html#step-3-run-the-setup-wizard","text":"The setup wizard helps you configure Amplifier for first use: amplifier init The wizard will guide you through: API Key Configuration - Enter your Anthropic API key Default Model Selection - Choose your preferred Claude model Workspace Setup - Configure your default workspace directory Bundle Installation - Install recommended bundles (optional) Example wizard session: Welcome to Amplifier Setup! ? Enter your Anthropic API key: sk-ant-*************** \u2713 API key validated successfully ? Select default model: > claude-3-5-sonnet-20241022 (recommended) claude-3-opus-20240229 claude-3-haiku-20240307 ? Workspace directory: ~/amplifier-workspace \u2713 Workspace created at /home/user/amplifier-workspace ? Install recommended bundles? (Y/n): Y \u2713 Installing foundation bundle... \u2713 Installing python-dev bundle... \u2713 Installing recipes bundle... Setup complete! Run 'amplifier chat' to start.","title":"Step 3: Run the Setup Wizard"},{"location":"quickstart/installation.html#step-4-verify-installation","text":"Confirm everything is working correctly: # Check version amplifier version # View available commands amplifier --help # Test connection amplifier test-connection # List installed bundles amplifier bundle list Expected output for amplifier version : Amplifier v1.0.0 Python 3.11.5 UV 0.4.0 Claude API: Connected","title":"Step 4: Verify Installation"},{"location":"quickstart/installation.html#platform-specific-notes","text":"","title":"Platform-Specific Notes"},{"location":"quickstart/installation.html#macos","text":"Homebrew installation (coming soon): brew install amplifier Shell configuration: Add to your ~/.zshrc or ~/.bash_profile : export PATH = \" $HOME /.local/bin: $PATH \"","title":"macOS"},{"location":"quickstart/installation.html#linux","text":"System dependencies: On Debian/Ubuntu: sudo apt update sudo apt install python3-pip git curl On Fedora/RHEL: sudo dnf install python3-pip git curl Shell configuration: Add to your ~/.bashrc : export PATH = \" $HOME /.local/bin: $PATH \"","title":"Linux"},{"location":"quickstart/installation.html#windows","text":"Recommended: Use WSL2 (Windows Subsystem for Linux) Install WSL2: wsl --install Open Ubuntu terminal Follow Linux installation steps Native Windows installation: Use PowerShell (not CMD) Install Python from Microsoft Store or python.org Ensure Python is in your PATH Common Windows issue: If you see \"command not found\" errors, add Python to PATH: [Environment] :: SetEnvironmentVariable ( \"Path\" , \"$env:Path;$env:LOCALAPPDATA\\Programs\\Python\\Python311\\Scripts\" , \"User\" )","title":"Windows"},{"location":"quickstart/installation.html#configuration","text":"","title":"Configuration"},{"location":"quickstart/installation.html#api-key-setup","text":"Amplifier needs your Anthropic API key to communicate with Claude. You can configure it in several ways: Option 1: Setup wizard (recommended) amplifier init Option 2: Environment variable export ANTHROPIC_API_KEY = \"sk-ant-your-key-here\" Add to your ~/.bashrc or ~/.zshrc to persist. Option 3: Configuration file Create ~/.config/amplifier/config.yaml : api_key : sk-ant-your-key-here default_model : claude-3-5-sonnet-20241022 workspace : ~/amplifier-workspace Option 4: Command-line flag amplifier chat --api-key sk-ant-your-key-here","title":"API Key Setup"},{"location":"quickstart/installation.html#workspace-configuration","text":"Your workspace is where Amplifier stores projects, skills, and bundles: # Set default workspace amplifier config set workspace ~/my-workspace # View current configuration amplifier config show","title":"Workspace Configuration"},{"location":"quickstart/installation.html#common-issues","text":"","title":"Common Issues"},{"location":"quickstart/installation.html#issue-command-not-found-amplifier","text":"Solution: Ensure the installation directory is in your PATH: echo $PATH | grep -q \" $HOME /.local/bin\" || export PATH = \" $HOME /.local/bin: $PATH \" Make it permanent by adding to your shell config file.","title":"Issue: \"command not found: amplifier\""},{"location":"quickstart/installation.html#issue-api-key-not-configured","text":"Solution: Run the setup wizard or set the environment variable: amplifier init # or export ANTHROPIC_API_KEY = \"your-key-here\"","title":"Issue: \"API key not configured\""},{"location":"quickstart/installation.html#issue-python-version-too-old","text":"Solution: Upgrade Python to 3.10 or higher: # macOS with Homebrew brew install python@3.11 # Ubuntu/Debian sudo apt install python3.11 # Windows # Download from python.org","title":"Issue: \"Python version too old\""},{"location":"quickstart/installation.html#issue-permission-denied-during-installation","text":"Solution: Don't use sudo with pip. Install for your user: pip install --user amplifier","title":"Issue: \"Permission denied\" during installation"},{"location":"quickstart/installation.html#issue-uv-installation-fails","text":"Solution: Install via pip instead: pip install uv Then retry Amplifier installation.","title":"Issue: UV installation fails"},{"location":"quickstart/installation.html#issue-ssl-certificate-verification-failed","text":"Solution: Update your system's CA certificates: # macOS brew install ca-certificates # Ubuntu/Debian sudo apt install ca-certificates","title":"Issue: SSL certificate verification failed"},{"location":"quickstart/installation.html#verifying-your-installation","text":"Run this comprehensive check: # Check all components amplifier doctor # Test API connection amplifier test-connection # List available tools amplifier tools list # View system info amplifier info","title":"Verifying Your Installation"},{"location":"quickstart/installation.html#next-steps","text":"Now that Amplifier is installed, you're ready to start building: First Conversation - Have your first chat with Amplifier Key Commands - Learn essential commands First Bundle - Create your first custom bundle Core Concepts - Understand Amplifier's architecture","title":"Next Steps"},{"location":"quickstart/installation.html#getting-help","text":"If you encounter issues not covered here: Documentation : amplifier.dev/docs GitHub Issues : github.com/yourusername/amplifier/issues Community Discord : discord.gg/amplifier Email Support : support@amplifier.dev","title":"Getting Help"},{"location":"quickstart/installation.html#updating-amplifier","text":"To update to the latest version: # With uvx uvx --refresh amplifier # With pip pip install --upgrade amplifier # View changelog amplifier changelog","title":"Updating Amplifier"},{"location":"quickstart/installation.html#uninstalling","text":"If you need to remove Amplifier: # With pip pip uninstall amplifier # Remove configuration rm -rf ~/.config/amplifier # Remove workspace (optional) rm -rf ~/amplifier-workspace Ready to start? Run amplifier chat and say hello to your AI development assistant!","title":"Uninstalling"},{"location":"quickstart/key-commands.html","text":"Key Commands \u00b6 Essential commands for working with Amplifier CLI and managing your AI development sessions. Command Overview \u00b6 Command Purpose When to Use amplifier run Start new session Beginning a new task or conversation amplifier continue Resume last session Pick up where you left off amplifier resume Pick specific session Return to any previous session amplifier list View all sessions See your session history amplifier export Export session Save conversation for sharing amplifier run \u00b6 Start a new Amplifier session with an initial instruction. Basic Usage \u00b6 # Start with a prompt amplifier run \"Create a REST API for user management\" # Start with empty prompt (interactive mode) amplifier run Common Options \u00b6 # Specify an agent amplifier run --agent foundation:explorer \"Analyze the codebase structure\" # Run with a specific model amplifier run --model claude-3-5-sonnet-20241022 \"Review code quality\" # Set working directory amplifier run --dir /path/to/project \"Add unit tests\" # Load a skill before starting amplifier run --skill python-standards \"Refactor this module\" Advanced Options \u00b6 # Run in non-interactive mode (CI/CD) amplifier run --non-interactive \"Run all tests\" # Set temperature for creativity amplifier run --temperature 0 .7 \"Generate creative variable names\" # Enable debug logging amplifier run --debug \"Investigate this bug\" # Use a specific configuration file amplifier run --config custom-config.yaml \"Deploy to production\" Environment Variables \u00b6 # Set API key export ANTHROPIC_API_KEY = your_key_here # Set custom config location export AMPLIFIER_CONFIG_PATH = ~/.config/amplifier/config.yaml # Enable verbose logging export AMPLIFIER_LOG_LEVEL = debug Examples \u00b6 # Web development task amplifier run \"Create a React component for user profile\" # Code review amplifier run --agent foundation:bug-hunter \"Find security issues\" # Documentation amplifier run \"Generate API documentation for all endpoints\" # Testing amplifier run --agent foundation:test-coverage \"Add tests for auth module\" amplifier continue \u00b6 Resume your most recent Amplifier session, picking up exactly where you left off. Basic Usage \u00b6 # Continue the last session amplifier continue # Continue with a new instruction amplifier continue \"Now add authentication to the API\" When to Use \u00b6 Quick iterations : You just closed a session and want to continue Morning workflow : Resume yesterday's work without searching Active development : Rapidly iterate on the current task Options \u00b6 # Continue with different model amplifier continue --model claude-3-5-sonnet-20241022 # Continue with additional context amplifier continue --skill security-best-practices Workflow Example \u00b6 # Day 1: Start working on a feature amplifier run \"Create user authentication system\" # ... work session ... # Exit with Ctrl+D # Day 2: Continue where you left off amplifier continue \"Add password reset functionality\" amplifier resume \u00b6 Select and resume any previous session from your history. Basic Usage \u00b6 # Show list of sessions and pick one amplifier resume # Resume specific session by ID amplifier resume abc123def456 Interactive Session Selection \u00b6 When you run amplifier resume without a session ID, you'll see: Recent Sessions: 1. [2 hours ago] \"Create REST API for user management\" 2. [1 day ago] \"Add unit tests for authentication\" 3. [2 days ago] \"Refactor database models\" 4. [1 week ago] \"Setup CI/CD pipeline\" Select a session (1-4) or enter session ID: Advanced Usage \u00b6 # Resume with filters amplifier resume --agent foundation:bug-hunter amplifier resume --date 2024 -01-15 amplifier resume --grep \"authentication\" # Resume and immediately add instruction amplifier resume abc123 \"Continue with the OAuth integration\" Use Cases \u00b6 Context switching : Return to a paused project Code archaeology : Review past decisions and conversations Learning : Revisit how you solved similar problems Collaboration : Resume a session started by a teammate amplifier list \u00b6 View and manage your session history. Basic Usage \u00b6 # List all sessions amplifier list # List with details amplifier list --verbose # List recent sessions only amplifier list --limit 10 Filtering Options \u00b6 # Filter by date amplifier list --since \"2024-01-01\" amplifier list --until \"2024-01-31\" # Filter by agent amplifier list --agent foundation:explorer # Search by content amplifier list --grep \"authentication\" # Filter by status amplifier list --active amplifier list --completed amplifier export \u00b6 Export session transcripts for sharing, documentation, or archival. Basic Usage \u00b6 # Export last session amplifier export # Export specific session amplifier export abc123def456 # Export to file amplifier export abc123 --output session-log.md Export Formats \u00b6 # Markdown (default) amplifier export --format markdown # JSON for processing amplifier export --format json # HTML for viewing amplifier export --format html Slash Commands \u00b6 Special commands available during an active Amplifier session. Help and Information \u00b6 /help Show available slash commands /tools List available tools and their capabilities /skills Show loaded skills /context Display current context information Display Control \u00b6 /compact Toggle compact mode (less verbose output) /verbose Toggle verbose mode (more detailed output) /clear Clear the terminal screen Session Management \u00b6 /status Show current session status /save Save session checkpoint /export Export current session /quit Exit session (Ctrl+D also works) Context and Memory \u00b6 /forget [topic] Remove specific context from memory /summarize Get summary of conversation so far /tokens Show token usage statistics Advanced Commands \u00b6 /agent [name] Switch to a different agent /model [name] Switch to a different model /temperature [0-1] Adjust response creativity /skill [name] Load additional skill Examples \u00b6 # During a session You: Create a user authentication system AI: [creates authentication code] You: /compact # Output mode changed to compact You: /tools # Shows: bash, read_file, write_file, grep, etc. You: /skill security-best-practices # Loads security skill for additional guidance Tips and Best Practices \u00b6 Session Management \u00b6 Use descriptive prompts : Start sessions with clear, specific goals Resume frequently : Don't hesitate to continue previous sessions Export important sessions : Save key conversations for documentation Command Efficiency \u00b6 # Use aliases for common commands alias amp = 'amplifier' alias ampr = 'amplifier run' alias ampc = 'amplifier continue' # Chain commands amplifier run \"Setup project\" && amplifier continue \"Add tests\" Working with Multiple Projects \u00b6 # Use project-specific scripts cd ~/project-a && amplifier run \"Add feature X\" cd ~/project-b && amplifier run \"Fix bug Y\" # Or use --dir flag amplifier run --dir ~/project-a \"Add feature X\" Debugging Issues \u00b6 # Enable verbose logging amplifier run --debug \"Investigate this error\" # Check configuration amplifier config show # Verify installation amplifier version amplifier doctor Keyboard Shortcuts \u00b6 Shortcut Action Ctrl+D Exit session gracefully Ctrl+C Interrupt current operation Ctrl+L Clear screen (same as /clear) Up/Down Navigate command history Tab Auto-complete (if available) Next Steps \u00b6 Continue Learning \u00b6 First Conversation : Practice with your first Amplifier session Agent System : Understand specialized agents Bundles : Extend with custom capabilities Explore Tools \u00b6 Task Tool : Launch specialized sub-agents Recipe System : Automate multi-step workflows File Operations : Master file manipulation Advanced Usage \u00b6 Skills : Load domain expertise Advanced Topics : Custom bundles, recipes, and tools Concepts : Deep understanding of Amplifier architecture Quick Reference Card \u00b6 # Start new session amplifier run \"Your instruction here\" # Continue last session amplifier continue # Pick any session amplifier resume # List all sessions amplifier list # Get help amplifier --help amplifier run --help # During session /help # Show commands /tools # List tools /compact # Toggle output mode Ctrl+D # Exit Need Help? Run amplifier --help for command documentation or visit the documentation site for comprehensive guides.","title":"Key Commands"},{"location":"quickstart/key-commands.html#key-commands","text":"Essential commands for working with Amplifier CLI and managing your AI development sessions.","title":"Key Commands"},{"location":"quickstart/key-commands.html#command-overview","text":"Command Purpose When to Use amplifier run Start new session Beginning a new task or conversation amplifier continue Resume last session Pick up where you left off amplifier resume Pick specific session Return to any previous session amplifier list View all sessions See your session history amplifier export Export session Save conversation for sharing","title":"Command Overview"},{"location":"quickstart/key-commands.html#amplifier-run","text":"Start a new Amplifier session with an initial instruction.","title":"amplifier run"},{"location":"quickstart/key-commands.html#basic-usage","text":"# Start with a prompt amplifier run \"Create a REST API for user management\" # Start with empty prompt (interactive mode) amplifier run","title":"Basic Usage"},{"location":"quickstart/key-commands.html#common-options","text":"# Specify an agent amplifier run --agent foundation:explorer \"Analyze the codebase structure\" # Run with a specific model amplifier run --model claude-3-5-sonnet-20241022 \"Review code quality\" # Set working directory amplifier run --dir /path/to/project \"Add unit tests\" # Load a skill before starting amplifier run --skill python-standards \"Refactor this module\"","title":"Common Options"},{"location":"quickstart/key-commands.html#advanced-options","text":"# Run in non-interactive mode (CI/CD) amplifier run --non-interactive \"Run all tests\" # Set temperature for creativity amplifier run --temperature 0 .7 \"Generate creative variable names\" # Enable debug logging amplifier run --debug \"Investigate this bug\" # Use a specific configuration file amplifier run --config custom-config.yaml \"Deploy to production\"","title":"Advanced Options"},{"location":"quickstart/key-commands.html#environment-variables","text":"# Set API key export ANTHROPIC_API_KEY = your_key_here # Set custom config location export AMPLIFIER_CONFIG_PATH = ~/.config/amplifier/config.yaml # Enable verbose logging export AMPLIFIER_LOG_LEVEL = debug","title":"Environment Variables"},{"location":"quickstart/key-commands.html#examples","text":"# Web development task amplifier run \"Create a React component for user profile\" # Code review amplifier run --agent foundation:bug-hunter \"Find security issues\" # Documentation amplifier run \"Generate API documentation for all endpoints\" # Testing amplifier run --agent foundation:test-coverage \"Add tests for auth module\"","title":"Examples"},{"location":"quickstart/key-commands.html#amplifier-continue","text":"Resume your most recent Amplifier session, picking up exactly where you left off.","title":"amplifier continue"},{"location":"quickstart/key-commands.html#basic-usage_1","text":"# Continue the last session amplifier continue # Continue with a new instruction amplifier continue \"Now add authentication to the API\"","title":"Basic Usage"},{"location":"quickstart/key-commands.html#when-to-use","text":"Quick iterations : You just closed a session and want to continue Morning workflow : Resume yesterday's work without searching Active development : Rapidly iterate on the current task","title":"When to Use"},{"location":"quickstart/key-commands.html#options","text":"# Continue with different model amplifier continue --model claude-3-5-sonnet-20241022 # Continue with additional context amplifier continue --skill security-best-practices","title":"Options"},{"location":"quickstart/key-commands.html#workflow-example","text":"# Day 1: Start working on a feature amplifier run \"Create user authentication system\" # ... work session ... # Exit with Ctrl+D # Day 2: Continue where you left off amplifier continue \"Add password reset functionality\"","title":"Workflow Example"},{"location":"quickstart/key-commands.html#amplifier-resume","text":"Select and resume any previous session from your history.","title":"amplifier resume"},{"location":"quickstart/key-commands.html#basic-usage_2","text":"# Show list of sessions and pick one amplifier resume # Resume specific session by ID amplifier resume abc123def456","title":"Basic Usage"},{"location":"quickstart/key-commands.html#interactive-session-selection","text":"When you run amplifier resume without a session ID, you'll see: Recent Sessions: 1. [2 hours ago] \"Create REST API for user management\" 2. [1 day ago] \"Add unit tests for authentication\" 3. [2 days ago] \"Refactor database models\" 4. [1 week ago] \"Setup CI/CD pipeline\" Select a session (1-4) or enter session ID:","title":"Interactive Session Selection"},{"location":"quickstart/key-commands.html#advanced-usage","text":"# Resume with filters amplifier resume --agent foundation:bug-hunter amplifier resume --date 2024 -01-15 amplifier resume --grep \"authentication\" # Resume and immediately add instruction amplifier resume abc123 \"Continue with the OAuth integration\"","title":"Advanced Usage"},{"location":"quickstart/key-commands.html#use-cases","text":"Context switching : Return to a paused project Code archaeology : Review past decisions and conversations Learning : Revisit how you solved similar problems Collaboration : Resume a session started by a teammate","title":"Use Cases"},{"location":"quickstart/key-commands.html#amplifier-list","text":"View and manage your session history.","title":"amplifier list"},{"location":"quickstart/key-commands.html#basic-usage_3","text":"# List all sessions amplifier list # List with details amplifier list --verbose # List recent sessions only amplifier list --limit 10","title":"Basic Usage"},{"location":"quickstart/key-commands.html#filtering-options","text":"# Filter by date amplifier list --since \"2024-01-01\" amplifier list --until \"2024-01-31\" # Filter by agent amplifier list --agent foundation:explorer # Search by content amplifier list --grep \"authentication\" # Filter by status amplifier list --active amplifier list --completed","title":"Filtering Options"},{"location":"quickstart/key-commands.html#amplifier-export","text":"Export session transcripts for sharing, documentation, or archival.","title":"amplifier export"},{"location":"quickstart/key-commands.html#basic-usage_4","text":"# Export last session amplifier export # Export specific session amplifier export abc123def456 # Export to file amplifier export abc123 --output session-log.md","title":"Basic Usage"},{"location":"quickstart/key-commands.html#export-formats","text":"# Markdown (default) amplifier export --format markdown # JSON for processing amplifier export --format json # HTML for viewing amplifier export --format html","title":"Export Formats"},{"location":"quickstart/key-commands.html#slash-commands","text":"Special commands available during an active Amplifier session.","title":"Slash Commands"},{"location":"quickstart/key-commands.html#help-and-information","text":"/help Show available slash commands /tools List available tools and their capabilities /skills Show loaded skills /context Display current context information","title":"Help and Information"},{"location":"quickstart/key-commands.html#display-control","text":"/compact Toggle compact mode (less verbose output) /verbose Toggle verbose mode (more detailed output) /clear Clear the terminal screen","title":"Display Control"},{"location":"quickstart/key-commands.html#session-management","text":"/status Show current session status /save Save session checkpoint /export Export current session /quit Exit session (Ctrl+D also works)","title":"Session Management"},{"location":"quickstart/key-commands.html#context-and-memory","text":"/forget [topic] Remove specific context from memory /summarize Get summary of conversation so far /tokens Show token usage statistics","title":"Context and Memory"},{"location":"quickstart/key-commands.html#advanced-commands","text":"/agent [name] Switch to a different agent /model [name] Switch to a different model /temperature [0-1] Adjust response creativity /skill [name] Load additional skill","title":"Advanced Commands"},{"location":"quickstart/key-commands.html#examples_1","text":"# During a session You: Create a user authentication system AI: [creates authentication code] You: /compact # Output mode changed to compact You: /tools # Shows: bash, read_file, write_file, grep, etc. You: /skill security-best-practices # Loads security skill for additional guidance","title":"Examples"},{"location":"quickstart/key-commands.html#tips-and-best-practices","text":"","title":"Tips and Best Practices"},{"location":"quickstart/key-commands.html#session-management_1","text":"Use descriptive prompts : Start sessions with clear, specific goals Resume frequently : Don't hesitate to continue previous sessions Export important sessions : Save key conversations for documentation","title":"Session Management"},{"location":"quickstart/key-commands.html#command-efficiency","text":"# Use aliases for common commands alias amp = 'amplifier' alias ampr = 'amplifier run' alias ampc = 'amplifier continue' # Chain commands amplifier run \"Setup project\" && amplifier continue \"Add tests\"","title":"Command Efficiency"},{"location":"quickstart/key-commands.html#working-with-multiple-projects","text":"# Use project-specific scripts cd ~/project-a && amplifier run \"Add feature X\" cd ~/project-b && amplifier run \"Fix bug Y\" # Or use --dir flag amplifier run --dir ~/project-a \"Add feature X\"","title":"Working with Multiple Projects"},{"location":"quickstart/key-commands.html#debugging-issues","text":"# Enable verbose logging amplifier run --debug \"Investigate this error\" # Check configuration amplifier config show # Verify installation amplifier version amplifier doctor","title":"Debugging Issues"},{"location":"quickstart/key-commands.html#keyboard-shortcuts","text":"Shortcut Action Ctrl+D Exit session gracefully Ctrl+C Interrupt current operation Ctrl+L Clear screen (same as /clear) Up/Down Navigate command history Tab Auto-complete (if available)","title":"Keyboard Shortcuts"},{"location":"quickstart/key-commands.html#next-steps","text":"","title":"Next Steps"},{"location":"quickstart/key-commands.html#continue-learning","text":"First Conversation : Practice with your first Amplifier session Agent System : Understand specialized agents Bundles : Extend with custom capabilities","title":"Continue Learning"},{"location":"quickstart/key-commands.html#explore-tools","text":"Task Tool : Launch specialized sub-agents Recipe System : Automate multi-step workflows File Operations : Master file manipulation","title":"Explore Tools"},{"location":"quickstart/key-commands.html#advanced-usage_1","text":"Skills : Load domain expertise Advanced Topics : Custom bundles, recipes, and tools Concepts : Deep understanding of Amplifier architecture","title":"Advanced Usage"},{"location":"quickstart/key-commands.html#quick-reference-card","text":"# Start new session amplifier run \"Your instruction here\" # Continue last session amplifier continue # Pick any session amplifier resume # List all sessions amplifier list # Get help amplifier --help amplifier run --help # During session /help # Show commands /tools # List tools /compact # Toggle output mode Ctrl+D # Exit Need Help? Run amplifier --help for command documentation or visit the documentation site for comprehensive guides.","title":"Quick Reference Card"},{"location":"quickstart/what-is-amplifier.html","text":"What is Amplifier? \u00b6 Amplifier is a modular AI agent framework designed to build powerful, composable AI-powered applications with ruthless simplicity. It provides the building blocks for creating sophisticated AI agents while maintaining clean architecture and developer ergonomics. Overview \u00b6 At its core, Amplifier is a kernel-based architecture that orchestrates AI agents through a minimal, well-defined set of contracts. Rather than providing a monolithic framework, Amplifier offers a thin kernel surrounded by composable modules that can be mixed and matched to create exactly the capabilities you need. Think of it like building with construction bricks: the kernel provides the studs and sockets (the connection points), while modules snap together to form complete applications. Each piece is self-contained, testable, and replaceable without affecting the rest of the system. \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 Your Application \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 Bundles (Pre-composed Module Sets) \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 Providers \u2502 Tools \u2502 Hooks \u2502 Behaviors \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 Amplifier Kernel \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 Key Features \u00b6 Modular Architecture \u00b6 Amplifier's module system allows you to compose functionality from discrete, well-defined pieces: Providers : Connect to AI models (Anthropic, OpenAI, Azure, local models) Tools : Extend agent capabilities (file operations, web search, code execution) Hooks : Intercept and modify agent behavior at key lifecycle points Behaviors : Reusable patterns for common agent tasks Thin Bundles \u00b6 Bundles are pre-composed collections of modules that work well together. They follow the \"thin bundle\" pattern: minimal configuration that composes existing modules rather than implementing new functionality. This keeps complexity low while enabling powerful combinations. Session Management \u00b6 Amplifier provides robust session handling for multi-turn conversations: Automatic context persistence Resumable sessions across restarts Event-based history with JSONL storage Sub-session support for agent delegation Multi-Agent Patterns \u00b6 Build sophisticated multi-agent systems with built-in support for: Agent delegation (spawning sub-agents for specialized tasks) Parallel agent execution Hierarchical agent orchestration Shared context and memory Tool Ecosystem \u00b6 A rich ecosystem of tools ready to use: File system operations (read, write, edit, search) Web capabilities (search, fetch, scrape) Code intelligence (LSP integration, semantic navigation) Git and GitHub operations Shell command execution with safety guardrails Recipes \u00b6 Declarative YAML workflows for multi-step agent tasks: Sequential execution with state persistence Approval gates for human-in-the-loop workflows Automatic checkpointing and resumability Error handling and retry logic Philosophy \u00b6 Amplifier is built on a foundation of intentional simplicity and practical wisdom. Ruthless Simplicity \u00b6 Every line of code must justify its existence. Amplifier rejects complexity for its own sake: Start minimal : Begin with the simplest implementation that works Grow as needed : Add complexity only when requirements demand it Question everything : Regularly challenge assumptions and abstractions The Brick Philosophy \u00b6 Software is built from small, clear modules like interlocking bricks: Each module is self-contained with defined interfaces Modules can be regenerated independently without breaking the system External contracts (the \"studs and sockets\") remain stable Internal implementations can evolve freely Humans as Architects \u00b6 Amplifier elevates human involvement to where it's most valuable: Humans define the vision : Specifications, requirements, intended behavior AI handles construction : Code generation, implementation details Humans validate results : Testing behavior, not reading every line of code Present-Moment Focus \u00b6 Build for what's needed now, not hypothetical futures: Handle current requirements well Avoid premature optimization Trust that good architecture emerges from simplicity Who It's For \u00b6 AI Application Developers \u00b6 If you're building AI-powered applications, Amplifier provides: Clean abstractions for common patterns Provider-agnostic model integration Battle-tested tool implementations Extensible architecture for custom needs Framework Builders \u00b6 If you're creating AI frameworks or platforms: Study Amplifier's kernel architecture Understand module contracts and composition Learn from the \"thin bundle\" pattern Build compatible modules and extensions Power Users \u00b6 If you're using AI assistants and want more control: Configure bundles to match your workflow Create custom tools and behaviors Build specialized agents for your domain Integrate with your existing systems Teams Exploring AI \u00b6 If your team is evaluating AI development approaches: Amplifier demonstrates sustainable AI development patterns The modular architecture prevents vendor lock-in Clear contracts make testing and validation straightforward Philosophy documentation guides decision-making Core Concepts at a Glance \u00b6 Concept Description Kernel Minimal core that orchestrates modules and sessions Module Self-contained unit of functionality (provider, tool, hook, behavior) Bundle Pre-composed collection of modules for specific use cases Session A conversation context with history and state Agent An AI entity that can use tools and follow instructions Recipe Declarative workflow specification in YAML What Amplifier is NOT \u00b6 Understanding what Amplifier isn't helps set proper expectations: Not a chatbot UI : Amplifier is a framework, not an application Not a model trainer : It orchestrates models, doesn't train them Not opinionated about models : Works with any compatible provider Not a low-code platform : Designed for developers who code Not trying to solve everything : Focused on agent orchestration Next Steps \u00b6 Ready to get started? Here's your path forward: Installation : Set up Amplifier in your environment First Conversation : Start your first session Your First Bundle : Create custom behavior packages Concepts : Deeper dive into architecture Quick Links \u00b6 GitHub Repository - Source code and issues Tools Reference - Complete documentation of available tools Bundles - Pre-built capability packages Welcome to Amplifier. Build powerful AI agents with clarity and confidence.","title":"What is Amplifier?"},{"location":"quickstart/what-is-amplifier.html#what-is-amplifier","text":"Amplifier is a modular AI agent framework designed to build powerful, composable AI-powered applications with ruthless simplicity. It provides the building blocks for creating sophisticated AI agents while maintaining clean architecture and developer ergonomics.","title":"What is Amplifier?"},{"location":"quickstart/what-is-amplifier.html#overview","text":"At its core, Amplifier is a kernel-based architecture that orchestrates AI agents through a minimal, well-defined set of contracts. Rather than providing a monolithic framework, Amplifier offers a thin kernel surrounded by composable modules that can be mixed and matched to create exactly the capabilities you need. Think of it like building with construction bricks: the kernel provides the studs and sockets (the connection points), while modules snap together to form complete applications. Each piece is self-contained, testable, and replaceable without affecting the rest of the system. \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 Your Application \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 Bundles (Pre-composed Module Sets) \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 Providers \u2502 Tools \u2502 Hooks \u2502 Behaviors \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 Amplifier Kernel \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Overview"},{"location":"quickstart/what-is-amplifier.html#key-features","text":"","title":"Key Features"},{"location":"quickstart/what-is-amplifier.html#modular-architecture","text":"Amplifier's module system allows you to compose functionality from discrete, well-defined pieces: Providers : Connect to AI models (Anthropic, OpenAI, Azure, local models) Tools : Extend agent capabilities (file operations, web search, code execution) Hooks : Intercept and modify agent behavior at key lifecycle points Behaviors : Reusable patterns for common agent tasks","title":"Modular Architecture"},{"location":"quickstart/what-is-amplifier.html#thin-bundles","text":"Bundles are pre-composed collections of modules that work well together. They follow the \"thin bundle\" pattern: minimal configuration that composes existing modules rather than implementing new functionality. This keeps complexity low while enabling powerful combinations.","title":"Thin Bundles"},{"location":"quickstart/what-is-amplifier.html#session-management","text":"Amplifier provides robust session handling for multi-turn conversations: Automatic context persistence Resumable sessions across restarts Event-based history with JSONL storage Sub-session support for agent delegation","title":"Session Management"},{"location":"quickstart/what-is-amplifier.html#multi-agent-patterns","text":"Build sophisticated multi-agent systems with built-in support for: Agent delegation (spawning sub-agents for specialized tasks) Parallel agent execution Hierarchical agent orchestration Shared context and memory","title":"Multi-Agent Patterns"},{"location":"quickstart/what-is-amplifier.html#tool-ecosystem","text":"A rich ecosystem of tools ready to use: File system operations (read, write, edit, search) Web capabilities (search, fetch, scrape) Code intelligence (LSP integration, semantic navigation) Git and GitHub operations Shell command execution with safety guardrails","title":"Tool Ecosystem"},{"location":"quickstart/what-is-amplifier.html#recipes","text":"Declarative YAML workflows for multi-step agent tasks: Sequential execution with state persistence Approval gates for human-in-the-loop workflows Automatic checkpointing and resumability Error handling and retry logic","title":"Recipes"},{"location":"quickstart/what-is-amplifier.html#philosophy","text":"Amplifier is built on a foundation of intentional simplicity and practical wisdom.","title":"Philosophy"},{"location":"quickstart/what-is-amplifier.html#ruthless-simplicity","text":"Every line of code must justify its existence. Amplifier rejects complexity for its own sake: Start minimal : Begin with the simplest implementation that works Grow as needed : Add complexity only when requirements demand it Question everything : Regularly challenge assumptions and abstractions","title":"Ruthless Simplicity"},{"location":"quickstart/what-is-amplifier.html#the-brick-philosophy","text":"Software is built from small, clear modules like interlocking bricks: Each module is self-contained with defined interfaces Modules can be regenerated independently without breaking the system External contracts (the \"studs and sockets\") remain stable Internal implementations can evolve freely","title":"The Brick Philosophy"},{"location":"quickstart/what-is-amplifier.html#humans-as-architects","text":"Amplifier elevates human involvement to where it's most valuable: Humans define the vision : Specifications, requirements, intended behavior AI handles construction : Code generation, implementation details Humans validate results : Testing behavior, not reading every line of code","title":"Humans as Architects"},{"location":"quickstart/what-is-amplifier.html#present-moment-focus","text":"Build for what's needed now, not hypothetical futures: Handle current requirements well Avoid premature optimization Trust that good architecture emerges from simplicity","title":"Present-Moment Focus"},{"location":"quickstart/what-is-amplifier.html#who-its-for","text":"","title":"Who It's For"},{"location":"quickstart/what-is-amplifier.html#ai-application-developers","text":"If you're building AI-powered applications, Amplifier provides: Clean abstractions for common patterns Provider-agnostic model integration Battle-tested tool implementations Extensible architecture for custom needs","title":"AI Application Developers"},{"location":"quickstart/what-is-amplifier.html#framework-builders","text":"If you're creating AI frameworks or platforms: Study Amplifier's kernel architecture Understand module contracts and composition Learn from the \"thin bundle\" pattern Build compatible modules and extensions","title":"Framework Builders"},{"location":"quickstart/what-is-amplifier.html#power-users","text":"If you're using AI assistants and want more control: Configure bundles to match your workflow Create custom tools and behaviors Build specialized agents for your domain Integrate with your existing systems","title":"Power Users"},{"location":"quickstart/what-is-amplifier.html#teams-exploring-ai","text":"If your team is evaluating AI development approaches: Amplifier demonstrates sustainable AI development patterns The modular architecture prevents vendor lock-in Clear contracts make testing and validation straightforward Philosophy documentation guides decision-making","title":"Teams Exploring AI"},{"location":"quickstart/what-is-amplifier.html#core-concepts-at-a-glance","text":"Concept Description Kernel Minimal core that orchestrates modules and sessions Module Self-contained unit of functionality (provider, tool, hook, behavior) Bundle Pre-composed collection of modules for specific use cases Session A conversation context with history and state Agent An AI entity that can use tools and follow instructions Recipe Declarative workflow specification in YAML","title":"Core Concepts at a Glance"},{"location":"quickstart/what-is-amplifier.html#what-amplifier-is-not","text":"Understanding what Amplifier isn't helps set proper expectations: Not a chatbot UI : Amplifier is a framework, not an application Not a model trainer : It orchestrates models, doesn't train them Not opinionated about models : Works with any compatible provider Not a low-code platform : Designed for developers who code Not trying to solve everything : Focused on agent orchestration","title":"What Amplifier is NOT"},{"location":"quickstart/what-is-amplifier.html#next-steps","text":"Ready to get started? Here's your path forward: Installation : Set up Amplifier in your environment First Conversation : Start your first session Your First Bundle : Create custom behavior packages Concepts : Deeper dive into architecture","title":"Next Steps"},{"location":"quickstart/what-is-amplifier.html#quick-links","text":"GitHub Repository - Source code and issues Tools Reference - Complete documentation of available tools Bundles - Pre-built capability packages Welcome to Amplifier. Build powerful AI agents with clarity and confidence.","title":"Quick Links"},{"location":"skills/index.html","text":"Skills Guide \u00b6 Skills are loadable knowledge modules that provide domain expertise on demand. Unlike always-present context, skills are loaded when needed, keeping the base context lean. This section covers how to use existing skills, create custom ones, and integrate them into your workflows. Section Contents \u00b6 Page Description Curl HTTP requests and API interactions Image Vision Image understanding and analysis Playwright Browser automation and testing Quick Tips \u00b6 Load on demand - Only load skills when the domain knowledge is needed Check before loading - Use info operation to preview skill metadata Skills complement docs - They provide workflows, not just reference Workspace priority - Project skills override user skills Companion files - Skills can reference additional resources Skills vs Context \u00b6 Aspect Skills Context Loading On-demand Always present Scope Domain-specific General behavior Size Can be large Should be concise Location Discoverable directories Bundle-defined Where to Start \u00b6 Want HTTP capabilities? Start with Curl for HTTP requests and API interactions. Working with images? Jump to Image Vision for image understanding. Need browser automation? See Playwright for browser testing. Skill Operations \u00b6 # List all available skills load_skill ( list = True ) # Search for skills by topic load_skill ( search = \"python\" ) # Check skill metadata load_skill ( info = \"skill-name\" ) # Load full skill content load_skill ( skill_name = \"skill-name\" ) Skill Discovery Paths \u00b6 Skills are discovered from configured directories in priority order: Workspace skills - .amplifier/skills/ (project-specific) User skills - ~/.amplifier/skills/ (personal) Bundle skills - From active bundles Collection skills - From installed collections First match wins\u2014workspace skills override user skills. Next Steps \u00b6 After understanding skills, explore Advanced topics for complex patterns like recipes and multi-agent workflows.","title":"Overview"},{"location":"skills/index.html#skills-guide","text":"Skills are loadable knowledge modules that provide domain expertise on demand. Unlike always-present context, skills are loaded when needed, keeping the base context lean. This section covers how to use existing skills, create custom ones, and integrate them into your workflows.","title":"Skills Guide"},{"location":"skills/index.html#section-contents","text":"Page Description Curl HTTP requests and API interactions Image Vision Image understanding and analysis Playwright Browser automation and testing","title":"Section Contents"},{"location":"skills/index.html#quick-tips","text":"Load on demand - Only load skills when the domain knowledge is needed Check before loading - Use info operation to preview skill metadata Skills complement docs - They provide workflows, not just reference Workspace priority - Project skills override user skills Companion files - Skills can reference additional resources","title":"Quick Tips"},{"location":"skills/index.html#skills-vs-context","text":"Aspect Skills Context Loading On-demand Always present Scope Domain-specific General behavior Size Can be large Should be concise Location Discoverable directories Bundle-defined","title":"Skills vs Context"},{"location":"skills/index.html#where-to-start","text":"Want HTTP capabilities? Start with Curl for HTTP requests and API interactions. Working with images? Jump to Image Vision for image understanding. Need browser automation? See Playwright for browser testing.","title":"Where to Start"},{"location":"skills/index.html#skill-operations","text":"# List all available skills load_skill ( list = True ) # Search for skills by topic load_skill ( search = \"python\" ) # Check skill metadata load_skill ( info = \"skill-name\" ) # Load full skill content load_skill ( skill_name = \"skill-name\" )","title":"Skill Operations"},{"location":"skills/index.html#skill-discovery-paths","text":"Skills are discovered from configured directories in priority order: Workspace skills - .amplifier/skills/ (project-specific) User skills - ~/.amplifier/skills/ (personal) Bundle skills - From active bundles Collection skills - From installed collections First match wins\u2014workspace skills override user skills.","title":"Skill Discovery Paths"},{"location":"skills/index.html#next-steps","text":"After understanding skills, explore Advanced topics for complex patterns like recipes and multi-agent workflows.","title":"Next Steps"},{"location":"skills/curl.html","text":"Curl Skill \u00b6 HTTP client for API testing, validation, and debugging. Overview \u00b6 The curl skill teaches Amplifier how to: Test REST APIs Validate responses Debug HTTP requests Send webhooks Handle authentication Loading the Skill \u00b6 > Load the curl skill Once loaded, Amplifier knows HTTP best practices. When to Use \u00b6 Task Use Curl Test API endpoint \u2705 Send webhook \u2705 Debug HTTP issue \u2705 Validate JSON response \u2705 Navigate website \u274c Use playwright Fill web form \u274c Use playwright Core Patterns \u00b6 Basic GET \u00b6 curl https://api.example.com/users POST with JSON \u00b6 curl -X POST https://api.example.com/users \\ -H \"Content-Type: application/json\" \\ -d '{\"name\": \"Alice\", \"email\": \"alice@example.com\"}' With Authentication \u00b6 # Bearer token curl https://api.example.com/me \\ -H \"Authorization: Bearer $TOKEN \" # Basic auth curl -u username:password https://api.example.com/private Show Headers \u00b6 curl -I https://api.example.com/health # Headers only curl -i https://api.example.com/users # Headers + body Verbose Mode \u00b6 curl -v https://api.example.com/debug Response Validation \u00b6 Check Status Code \u00b6 # Get just the status code curl -o /dev/null -s -w \"%{http_code}\" https://api.example.com/health Validate JSON \u00b6 # Pretty print JSON curl https://api.example.com/users | jq . # Extract specific field curl https://api.example.com/users/1 | jq '.name' # Check array length curl https://api.example.com/users | jq 'length' Check Response Time \u00b6 curl -o /dev/null -s -w \"Time: %{time_total}s\\n\" https://api.example.com/ Common Methods \u00b6 GET \u00b6 curl https://api.example.com/resource curl \"https://api.example.com/search?q=term\" POST \u00b6 curl -X POST https://api.example.com/resource \\ -H \"Content-Type: application/json\" \\ -d '{\"key\": \"value\"}' PUT \u00b6 curl -X PUT https://api.example.com/resource/1 \\ -H \"Content-Type: application/json\" \\ -d '{\"name\": \"Updated\"}' DELETE \u00b6 curl -X DELETE https://api.example.com/resource/1 PATCH \u00b6 curl -X PATCH https://api.example.com/resource/1 \\ -H \"Content-Type: application/json\" \\ -d '{\"status\": \"active\"}' Headers \u00b6 Common Headers \u00b6 # Content-Type -H \"Content-Type: application/json\" -H \"Content-Type: application/x-www-form-urlencoded\" # Accept -H \"Accept: application/json\" # Authorization -H \"Authorization: Bearer TOKEN\" -H \"Authorization: Basic BASE64\" # Custom -H \"X-API-Key: your-key\" Multiple Headers \u00b6 curl https://api.example.com/ \\ -H \"Content-Type: application/json\" \\ -H \"Authorization: Bearer $TOKEN \" \\ -H \"Accept: application/json\" File Operations \u00b6 Upload File \u00b6 curl -X POST https://api.example.com/upload \\ -F \"file=@document.pdf\" Download File \u00b6 curl -o output.pdf https://example.com/document.pdf Error Handling \u00b6 Follow Redirects \u00b6 curl -L https://example.com/redirecting-url Retry on Failure \u00b6 curl --retry 3 https://api.example.com/flaky Timeout \u00b6 curl --connect-timeout 5 --max-time 10 https://api.example.com/slow Debugging \u00b6 Verbose Output \u00b6 curl -v https://api.example.com/debug Shows: - DNS resolution - TCP connection - TLS handshake - Request headers - Response headers Trace \u00b6 curl --trace - https://api.example.com/debug Full byte-level trace. Try It Yourself \u00b6 Exercise 1: Test an API \u00b6 > Load curl skill > Test the GitHub API: GET https://api.github.com/users/octocat Exercise 2: POST Request \u00b6 > Send a POST to httpbin.org/post with JSON body {\"test\": \"data\"} Exercise 3: Validate Response \u00b6 > Check if https://api.github.com is returning 200 OK Common Errors \u00b6 \"Connection refused\" \u00b6 Server not running Wrong port Firewall blocking \"SSL certificate problem\" \u00b6 # Skip verification (only for testing!) curl -k https://self-signed.example.com \"401 Unauthorized\" \u00b6 Check authentication header Verify token is valid Check token format Source \u00b6 robotdad/skills/curl/ \u251c\u2500\u2500 SKILL.md # Core patterns \u251c\u2500\u2500 patterns.md # Advanced usage \u2514\u2500\u2500 troubleshooting.md # Common issues","title":"Curl"},{"location":"skills/curl.html#curl-skill","text":"HTTP client for API testing, validation, and debugging.","title":"Curl Skill"},{"location":"skills/curl.html#overview","text":"The curl skill teaches Amplifier how to: Test REST APIs Validate responses Debug HTTP requests Send webhooks Handle authentication","title":"Overview"},{"location":"skills/curl.html#loading-the-skill","text":"> Load the curl skill Once loaded, Amplifier knows HTTP best practices.","title":"Loading the Skill"},{"location":"skills/curl.html#when-to-use","text":"Task Use Curl Test API endpoint \u2705 Send webhook \u2705 Debug HTTP issue \u2705 Validate JSON response \u2705 Navigate website \u274c Use playwright Fill web form \u274c Use playwright","title":"When to Use"},{"location":"skills/curl.html#core-patterns","text":"","title":"Core Patterns"},{"location":"skills/curl.html#basic-get","text":"curl https://api.example.com/users","title":"Basic GET"},{"location":"skills/curl.html#post-with-json","text":"curl -X POST https://api.example.com/users \\ -H \"Content-Type: application/json\" \\ -d '{\"name\": \"Alice\", \"email\": \"alice@example.com\"}'","title":"POST with JSON"},{"location":"skills/curl.html#with-authentication","text":"# Bearer token curl https://api.example.com/me \\ -H \"Authorization: Bearer $TOKEN \" # Basic auth curl -u username:password https://api.example.com/private","title":"With Authentication"},{"location":"skills/curl.html#show-headers","text":"curl -I https://api.example.com/health # Headers only curl -i https://api.example.com/users # Headers + body","title":"Show Headers"},{"location":"skills/curl.html#verbose-mode","text":"curl -v https://api.example.com/debug","title":"Verbose Mode"},{"location":"skills/curl.html#response-validation","text":"","title":"Response Validation"},{"location":"skills/curl.html#check-status-code","text":"# Get just the status code curl -o /dev/null -s -w \"%{http_code}\" https://api.example.com/health","title":"Check Status Code"},{"location":"skills/curl.html#validate-json","text":"# Pretty print JSON curl https://api.example.com/users | jq . # Extract specific field curl https://api.example.com/users/1 | jq '.name' # Check array length curl https://api.example.com/users | jq 'length'","title":"Validate JSON"},{"location":"skills/curl.html#check-response-time","text":"curl -o /dev/null -s -w \"Time: %{time_total}s\\n\" https://api.example.com/","title":"Check Response Time"},{"location":"skills/curl.html#common-methods","text":"","title":"Common Methods"},{"location":"skills/curl.html#get","text":"curl https://api.example.com/resource curl \"https://api.example.com/search?q=term\"","title":"GET"},{"location":"skills/curl.html#post","text":"curl -X POST https://api.example.com/resource \\ -H \"Content-Type: application/json\" \\ -d '{\"key\": \"value\"}'","title":"POST"},{"location":"skills/curl.html#put","text":"curl -X PUT https://api.example.com/resource/1 \\ -H \"Content-Type: application/json\" \\ -d '{\"name\": \"Updated\"}'","title":"PUT"},{"location":"skills/curl.html#delete","text":"curl -X DELETE https://api.example.com/resource/1","title":"DELETE"},{"location":"skills/curl.html#patch","text":"curl -X PATCH https://api.example.com/resource/1 \\ -H \"Content-Type: application/json\" \\ -d '{\"status\": \"active\"}'","title":"PATCH"},{"location":"skills/curl.html#headers","text":"","title":"Headers"},{"location":"skills/curl.html#common-headers","text":"# Content-Type -H \"Content-Type: application/json\" -H \"Content-Type: application/x-www-form-urlencoded\" # Accept -H \"Accept: application/json\" # Authorization -H \"Authorization: Bearer TOKEN\" -H \"Authorization: Basic BASE64\" # Custom -H \"X-API-Key: your-key\"","title":"Common Headers"},{"location":"skills/curl.html#multiple-headers","text":"curl https://api.example.com/ \\ -H \"Content-Type: application/json\" \\ -H \"Authorization: Bearer $TOKEN \" \\ -H \"Accept: application/json\"","title":"Multiple Headers"},{"location":"skills/curl.html#file-operations","text":"","title":"File Operations"},{"location":"skills/curl.html#upload-file","text":"curl -X POST https://api.example.com/upload \\ -F \"file=@document.pdf\"","title":"Upload File"},{"location":"skills/curl.html#download-file","text":"curl -o output.pdf https://example.com/document.pdf","title":"Download File"},{"location":"skills/curl.html#error-handling","text":"","title":"Error Handling"},{"location":"skills/curl.html#follow-redirects","text":"curl -L https://example.com/redirecting-url","title":"Follow Redirects"},{"location":"skills/curl.html#retry-on-failure","text":"curl --retry 3 https://api.example.com/flaky","title":"Retry on Failure"},{"location":"skills/curl.html#timeout","text":"curl --connect-timeout 5 --max-time 10 https://api.example.com/slow","title":"Timeout"},{"location":"skills/curl.html#debugging","text":"","title":"Debugging"},{"location":"skills/curl.html#verbose-output","text":"curl -v https://api.example.com/debug Shows: - DNS resolution - TCP connection - TLS handshake - Request headers - Response headers","title":"Verbose Output"},{"location":"skills/curl.html#trace","text":"curl --trace - https://api.example.com/debug Full byte-level trace.","title":"Trace"},{"location":"skills/curl.html#try-it-yourself","text":"","title":"Try It Yourself"},{"location":"skills/curl.html#exercise-1-test-an-api","text":"> Load curl skill > Test the GitHub API: GET https://api.github.com/users/octocat","title":"Exercise 1: Test an API"},{"location":"skills/curl.html#exercise-2-post-request","text":"> Send a POST to httpbin.org/post with JSON body {\"test\": \"data\"}","title":"Exercise 2: POST Request"},{"location":"skills/curl.html#exercise-3-validate-response","text":"> Check if https://api.github.com is returning 200 OK","title":"Exercise 3: Validate Response"},{"location":"skills/curl.html#common-errors","text":"","title":"Common Errors"},{"location":"skills/curl.html#connection-refused","text":"Server not running Wrong port Firewall blocking","title":"\"Connection refused\""},{"location":"skills/curl.html#ssl-certificate-problem","text":"# Skip verification (only for testing!) curl -k https://self-signed.example.com","title":"\"SSL certificate problem\""},{"location":"skills/curl.html#401-unauthorized","text":"Check authentication header Verify token is valid Check token format","title":"\"401 Unauthorized\""},{"location":"skills/curl.html#source","text":"robotdad/skills/curl/ \u251c\u2500\u2500 SKILL.md # Core patterns \u251c\u2500\u2500 patterns.md # Advanced usage \u2514\u2500\u2500 troubleshooting.md # Common issues","title":"Source"},{"location":"skills/image-vision.html","text":"Image Vision Skill \u00b6 Analyze images using LLM vision APIs. Overview \u00b6 The Image Vision skill teaches Amplifier how to: Understand image content Describe visual elements Answer questions about images Compare multiple images Extract text (OCR) Loading the Skill \u00b6 > Load the image-vision skill Once loaded, Amplifier knows how to work with images. When to Use \u00b6 Task Use Image Vision Describe what's in an image \u2705 Extract text from screenshot \u2705 Compare two images \u2705 Answer questions about image \u2705 Edit or modify images \u274c Different tools Generate images \u274c Different tools Supported Providers \u00b6 Provider Model Vision Capable Anthropic Claude 3+ \u2705 OpenAI GPT-4V, GPT-4o \u2705 Google Gemini Pro Vision \u2705 Azure OpenAI GPT-4V \u2705 Core Patterns \u00b6 Describe Image \u00b6 > What's in this image? [attach: screenshot.png] Extract Text (OCR) \u00b6 > Extract all text from this image [attach: document-scan.png] Answer Questions \u00b6 > How many people are in this photo? [attach: group-photo.jpg] Compare Images \u00b6 > What's different between these two screenshots? [attach: before.png] [attach: after.png] Image Sources \u00b6 Local Files \u00b6 > Analyze the image at ./screenshots/error.png URLs \u00b6 > Describe the image at https://example.com/photo.jpg Base64 \u00b6 For programmatic use: import base64 with open ( \"image.png\" , \"rb\" ) as f : image_data = base64 . b64encode ( f . read ()) . decode () # Include in prompt with data URI Best Practices \u00b6 Be Specific \u00b6 # Vague > What's this? # Specific > What error message is shown in this screenshot? Provide Context \u00b6 > This is a screenshot of our checkout page. > Is the \"Complete Purchase\" button visible? Ask Focused Questions \u00b6 # Too broad > Tell me everything about this image # Focused > What color is the submit button in this form? Common Tasks \u00b6 UI Validation \u00b6 > Does this screenshot show a successful login? > Is the error message displayed in red? > Are all form fields filled in? Content Understanding \u00b6 > What products are shown in this catalog image? > Summarize the key points from this infographic > What's the main headline on this webpage? Data Extraction \u00b6 > Extract the table data from this spreadsheet screenshot > What are the values in the pie chart? > Read the receipt amounts from this photo Comparison \u00b6 > Has the layout changed between these two versions? > What elements are missing in the second screenshot? > Which design looks more professional? Limitations \u00b6 Cannot Do \u00b6 Edit or modify images Generate new images Process video (frame by frame only) Guarantee 100% accurate OCR Image Size \u00b6 Large images may be resized. For text extraction: - Use highest resolution available - Ensure text is readable at smaller sizes Complex Documents \u00b6 For complex documents with many elements: - Ask about specific sections - Break into multiple queries Try It Yourself \u00b6 Exercise 1: Describe Image \u00b6 > Load image-vision skill > Describe what you see at https://picsum.photos/800/600 Exercise 2: Extract Text \u00b6 Take a screenshot of any webpage and ask: > Extract the main heading from this screenshot Exercise 3: Compare \u00b6 Take two screenshots and ask: > What changed between these two screenshots? Provider Configuration \u00b6 Ensure your provider supports vision: providers : - module : provider-anthropic config : model : claude-sonnet-4-20250514 # Supports vision Troubleshooting \u00b6 \"Vision not supported\" \u00b6 Check model supports vision Update to vision-capable model \"Image too large\" \u00b6 Reduce image resolution Crop to relevant area \"Cannot read text\" \u00b6 Improve image quality Increase contrast Try different angle/lighting Source \u00b6 robotdad/skills/image-vision/ \u251c\u2500\u2500 SKILL.md # Core workflow \u251c\u2500\u2500 patterns.md # Advanced patterns \u2514\u2500\u2500 setup.md # Provider setup","title":"Image Vision"},{"location":"skills/image-vision.html#image-vision-skill","text":"Analyze images using LLM vision APIs.","title":"Image Vision Skill"},{"location":"skills/image-vision.html#overview","text":"The Image Vision skill teaches Amplifier how to: Understand image content Describe visual elements Answer questions about images Compare multiple images Extract text (OCR)","title":"Overview"},{"location":"skills/image-vision.html#loading-the-skill","text":"> Load the image-vision skill Once loaded, Amplifier knows how to work with images.","title":"Loading the Skill"},{"location":"skills/image-vision.html#when-to-use","text":"Task Use Image Vision Describe what's in an image \u2705 Extract text from screenshot \u2705 Compare two images \u2705 Answer questions about image \u2705 Edit or modify images \u274c Different tools Generate images \u274c Different tools","title":"When to Use"},{"location":"skills/image-vision.html#supported-providers","text":"Provider Model Vision Capable Anthropic Claude 3+ \u2705 OpenAI GPT-4V, GPT-4o \u2705 Google Gemini Pro Vision \u2705 Azure OpenAI GPT-4V \u2705","title":"Supported Providers"},{"location":"skills/image-vision.html#core-patterns","text":"","title":"Core Patterns"},{"location":"skills/image-vision.html#describe-image","text":"> What's in this image? [attach: screenshot.png]","title":"Describe Image"},{"location":"skills/image-vision.html#extract-text-ocr","text":"> Extract all text from this image [attach: document-scan.png]","title":"Extract Text (OCR)"},{"location":"skills/image-vision.html#answer-questions","text":"> How many people are in this photo? [attach: group-photo.jpg]","title":"Answer Questions"},{"location":"skills/image-vision.html#compare-images","text":"> What's different between these two screenshots? [attach: before.png] [attach: after.png]","title":"Compare Images"},{"location":"skills/image-vision.html#image-sources","text":"","title":"Image Sources"},{"location":"skills/image-vision.html#local-files","text":"> Analyze the image at ./screenshots/error.png","title":"Local Files"},{"location":"skills/image-vision.html#urls","text":"> Describe the image at https://example.com/photo.jpg","title":"URLs"},{"location":"skills/image-vision.html#base64","text":"For programmatic use: import base64 with open ( \"image.png\" , \"rb\" ) as f : image_data = base64 . b64encode ( f . read ()) . decode () # Include in prompt with data URI","title":"Base64"},{"location":"skills/image-vision.html#best-practices","text":"","title":"Best Practices"},{"location":"skills/image-vision.html#be-specific","text":"# Vague > What's this? # Specific > What error message is shown in this screenshot?","title":"Be Specific"},{"location":"skills/image-vision.html#provide-context","text":"> This is a screenshot of our checkout page. > Is the \"Complete Purchase\" button visible?","title":"Provide Context"},{"location":"skills/image-vision.html#ask-focused-questions","text":"# Too broad > Tell me everything about this image # Focused > What color is the submit button in this form?","title":"Ask Focused Questions"},{"location":"skills/image-vision.html#common-tasks","text":"","title":"Common Tasks"},{"location":"skills/image-vision.html#ui-validation","text":"> Does this screenshot show a successful login? > Is the error message displayed in red? > Are all form fields filled in?","title":"UI Validation"},{"location":"skills/image-vision.html#content-understanding","text":"> What products are shown in this catalog image? > Summarize the key points from this infographic > What's the main headline on this webpage?","title":"Content Understanding"},{"location":"skills/image-vision.html#data-extraction","text":"> Extract the table data from this spreadsheet screenshot > What are the values in the pie chart? > Read the receipt amounts from this photo","title":"Data Extraction"},{"location":"skills/image-vision.html#comparison","text":"> Has the layout changed between these two versions? > What elements are missing in the second screenshot? > Which design looks more professional?","title":"Comparison"},{"location":"skills/image-vision.html#limitations","text":"","title":"Limitations"},{"location":"skills/image-vision.html#cannot-do","text":"Edit or modify images Generate new images Process video (frame by frame only) Guarantee 100% accurate OCR","title":"Cannot Do"},{"location":"skills/image-vision.html#image-size","text":"Large images may be resized. For text extraction: - Use highest resolution available - Ensure text is readable at smaller sizes","title":"Image Size"},{"location":"skills/image-vision.html#complex-documents","text":"For complex documents with many elements: - Ask about specific sections - Break into multiple queries","title":"Complex Documents"},{"location":"skills/image-vision.html#try-it-yourself","text":"","title":"Try It Yourself"},{"location":"skills/image-vision.html#exercise-1-describe-image","text":"> Load image-vision skill > Describe what you see at https://picsum.photos/800/600","title":"Exercise 1: Describe Image"},{"location":"skills/image-vision.html#exercise-2-extract-text","text":"Take a screenshot of any webpage and ask: > Extract the main heading from this screenshot","title":"Exercise 2: Extract Text"},{"location":"skills/image-vision.html#exercise-3-compare","text":"Take two screenshots and ask: > What changed between these two screenshots?","title":"Exercise 3: Compare"},{"location":"skills/image-vision.html#provider-configuration","text":"Ensure your provider supports vision: providers : - module : provider-anthropic config : model : claude-sonnet-4-20250514 # Supports vision","title":"Provider Configuration"},{"location":"skills/image-vision.html#troubleshooting","text":"","title":"Troubleshooting"},{"location":"skills/image-vision.html#vision-not-supported","text":"Check model supports vision Update to vision-capable model","title":"\"Vision not supported\""},{"location":"skills/image-vision.html#image-too-large","text":"Reduce image resolution Crop to relevant area","title":"\"Image too large\""},{"location":"skills/image-vision.html#cannot-read-text","text":"Improve image quality Increase contrast Try different angle/lighting","title":"\"Cannot read text\""},{"location":"skills/image-vision.html#source","text":"robotdad/skills/image-vision/ \u251c\u2500\u2500 SKILL.md # Core workflow \u251c\u2500\u2500 patterns.md # Advanced patterns \u2514\u2500\u2500 setup.md # Provider setup","title":"Source"},{"location":"skills/playwright.html","text":"Playwright Skill \u00b6 Browser automation for testing, validation, and web interaction. Overview \u00b6 The Playwright skill teaches Amplifier how to: Navigate websites Fill forms and click elements Extract data from pages Capture screenshots Run headless (no visible browser) Loading the Skill \u00b6 > Load the playwright skill Once loaded, Amplifier knows browser automation best practices. When to Use \u00b6 Task Use Playwright Test a login flow \u2705 Capture page screenshot \u2705 Fill and submit forms \u2705 Extract data from pages \u2705 Test REST API \u274c Use curl Fetch static content \u274c Use web_fetch Core Workflow \u00b6 The skill teaches this decision flow: START \u251c\u2500\u2500 Check if Playwright installed \u2502 \u2514\u2500\u2500 No \u2192 Run setup \u251c\u2500\u2500 Determine task type \u2502 \u251c\u2500\u2500 Screenshot \u2192 Capture flow \u2502 \u251c\u2500\u2500 Form fill \u2192 Interaction flow \u2502 \u251c\u2500\u2500 Scraping \u2192 Extraction flow \u2502 \u2514\u2500\u2500 Testing \u2192 Validation flow \u2514\u2500\u2500 Execute with best practices \u251c\u2500\u2500 Headless mode (default) \u251c\u2500\u2500 Role-based selectors \u251c\u2500\u2500 Explicit waits \u2514\u2500\u2500 Diagnostic capture Key Patterns \u00b6 Headless First \u00b6 Always run without visible browser: browser = playwright . chromium . launch ( headless = True ) This ensures: - No focus stealing - Works in CI/CD - Faster execution Role-Based Selectors \u00b6 Prefer accessibility selectors: # Good - role-based page . get_by_role ( \"button\" , name = \"Submit\" ) page . get_by_label ( \"Email\" ) page . get_by_placeholder ( \"Enter password\" ) # Avoid - fragile page . locator ( \".btn-primary\" ) page . locator ( \"#email-input\" ) Explicit Waits \u00b6 Wait for specific conditions: # Wait for element page . wait_for_selector ( \"[data-loaded='true']\" ) # Wait for navigation page . wait_for_url ( \"**/dashboard\" ) # Wait for network idle page . wait_for_load_state ( \"networkidle\" ) Diagnostic Capture \u00b6 On failure, capture context: try : # Test steps except Exception as e : page . screenshot ( path = \"failure.png\" ) print ( page . content ()) raise Examples \u00b6 Take Screenshot \u00b6 > Take a screenshot of https://example.com from playwright.sync_api import sync_playwright with sync_playwright () as p : browser = p . chromium . launch ( headless = True ) page = browser . new_page () page . goto ( \"https://example.com\" ) page . screenshot ( path = \"screenshot.png\" ) browser . close () Login Flow \u00b6 > Test logging into the admin panel from playwright.sync_api import sync_playwright with sync_playwright () as p : browser = p . chromium . launch ( headless = True ) page = browser . new_page () # Navigate page . goto ( \"https://example.com/login\" ) # Fill form page . get_by_label ( \"Email\" ) . fill ( \"admin@example.com\" ) page . get_by_label ( \"Password\" ) . fill ( \"password123\" ) # Submit page . get_by_role ( \"button\" , name = \"Sign in\" ) . click () # Verify success page . wait_for_url ( \"**/dashboard\" ) assert \"Dashboard\" in page . title () browser . close () Extract Data \u00b6 > Get all product prices from the catalog page from playwright.sync_api import sync_playwright with sync_playwright () as p : browser = p . chromium . launch ( headless = True ) page = browser . new_page () page . goto ( \"https://example.com/products\" ) # Extract prices prices = page . locator ( \".product-price\" ) . all_text_contents () for price in prices : print ( price ) browser . close () Setup \u00b6 If Playwright isn't installed: # Install package pip install playwright # Install browsers playwright install chromium Troubleshooting \u00b6 \"Browser not found\" \u00b6 playwright install chromium \"Element not found\" \u00b6 Check selector syntax Add explicit wait Verify element exists in page \"Timeout\" \u00b6 # Increase timeout page . wait_for_selector ( \".element\" , timeout = 10000 ) # 10 seconds Debugging \u00b6 Run with visible browser: browser = p . chromium . launch ( headless = False , slow_mo = 500 ) Anti-patterns \u00b6 The skill warns against: Visible browser mode - Use headless Arbitrary sleeps - Use explicit waits CSS selectors first - Use role-based No error capture - Always capture diagnostics Try It Yourself \u00b6 Exercise 1: Screenshot \u00b6 > Load playwright skill > Take a screenshot of https://github.com Exercise 2: Form Test \u00b6 > Test the search functionality on https://duckduckgo.com Exercise 3: Data Extraction \u00b6 > Extract all headlines from https://news.ycombinator.com Source \u00b6 robotdad/skills/playwright/ \u251c\u2500\u2500 SKILL.md # Core workflow \u251c\u2500\u2500 patterns.md # Advanced patterns \u251c\u2500\u2500 setup.md # Installation \u2514\u2500\u2500 troubleshooting.md # Common issues","title":"Playwright"},{"location":"skills/playwright.html#playwright-skill","text":"Browser automation for testing, validation, and web interaction.","title":"Playwright Skill"},{"location":"skills/playwright.html#overview","text":"The Playwright skill teaches Amplifier how to: Navigate websites Fill forms and click elements Extract data from pages Capture screenshots Run headless (no visible browser)","title":"Overview"},{"location":"skills/playwright.html#loading-the-skill","text":"> Load the playwright skill Once loaded, Amplifier knows browser automation best practices.","title":"Loading the Skill"},{"location":"skills/playwright.html#when-to-use","text":"Task Use Playwright Test a login flow \u2705 Capture page screenshot \u2705 Fill and submit forms \u2705 Extract data from pages \u2705 Test REST API \u274c Use curl Fetch static content \u274c Use web_fetch","title":"When to Use"},{"location":"skills/playwright.html#core-workflow","text":"The skill teaches this decision flow: START \u251c\u2500\u2500 Check if Playwright installed \u2502 \u2514\u2500\u2500 No \u2192 Run setup \u251c\u2500\u2500 Determine task type \u2502 \u251c\u2500\u2500 Screenshot \u2192 Capture flow \u2502 \u251c\u2500\u2500 Form fill \u2192 Interaction flow \u2502 \u251c\u2500\u2500 Scraping \u2192 Extraction flow \u2502 \u2514\u2500\u2500 Testing \u2192 Validation flow \u2514\u2500\u2500 Execute with best practices \u251c\u2500\u2500 Headless mode (default) \u251c\u2500\u2500 Role-based selectors \u251c\u2500\u2500 Explicit waits \u2514\u2500\u2500 Diagnostic capture","title":"Core Workflow"},{"location":"skills/playwright.html#key-patterns","text":"","title":"Key Patterns"},{"location":"skills/playwright.html#headless-first","text":"Always run without visible browser: browser = playwright . chromium . launch ( headless = True ) This ensures: - No focus stealing - Works in CI/CD - Faster execution","title":"Headless First"},{"location":"skills/playwright.html#role-based-selectors","text":"Prefer accessibility selectors: # Good - role-based page . get_by_role ( \"button\" , name = \"Submit\" ) page . get_by_label ( \"Email\" ) page . get_by_placeholder ( \"Enter password\" ) # Avoid - fragile page . locator ( \".btn-primary\" ) page . locator ( \"#email-input\" )","title":"Role-Based Selectors"},{"location":"skills/playwright.html#explicit-waits","text":"Wait for specific conditions: # Wait for element page . wait_for_selector ( \"[data-loaded='true']\" ) # Wait for navigation page . wait_for_url ( \"**/dashboard\" ) # Wait for network idle page . wait_for_load_state ( \"networkidle\" )","title":"Explicit Waits"},{"location":"skills/playwright.html#diagnostic-capture","text":"On failure, capture context: try : # Test steps except Exception as e : page . screenshot ( path = \"failure.png\" ) print ( page . content ()) raise","title":"Diagnostic Capture"},{"location":"skills/playwright.html#examples","text":"","title":"Examples"},{"location":"skills/playwright.html#take-screenshot","text":"> Take a screenshot of https://example.com from playwright.sync_api import sync_playwright with sync_playwright () as p : browser = p . chromium . launch ( headless = True ) page = browser . new_page () page . goto ( \"https://example.com\" ) page . screenshot ( path = \"screenshot.png\" ) browser . close ()","title":"Take Screenshot"},{"location":"skills/playwright.html#login-flow","text":"> Test logging into the admin panel from playwright.sync_api import sync_playwright with sync_playwright () as p : browser = p . chromium . launch ( headless = True ) page = browser . new_page () # Navigate page . goto ( \"https://example.com/login\" ) # Fill form page . get_by_label ( \"Email\" ) . fill ( \"admin@example.com\" ) page . get_by_label ( \"Password\" ) . fill ( \"password123\" ) # Submit page . get_by_role ( \"button\" , name = \"Sign in\" ) . click () # Verify success page . wait_for_url ( \"**/dashboard\" ) assert \"Dashboard\" in page . title () browser . close ()","title":"Login Flow"},{"location":"skills/playwright.html#extract-data","text":"> Get all product prices from the catalog page from playwright.sync_api import sync_playwright with sync_playwright () as p : browser = p . chromium . launch ( headless = True ) page = browser . new_page () page . goto ( \"https://example.com/products\" ) # Extract prices prices = page . locator ( \".product-price\" ) . all_text_contents () for price in prices : print ( price ) browser . close ()","title":"Extract Data"},{"location":"skills/playwright.html#setup","text":"If Playwright isn't installed: # Install package pip install playwright # Install browsers playwright install chromium","title":"Setup"},{"location":"skills/playwright.html#troubleshooting","text":"","title":"Troubleshooting"},{"location":"skills/playwright.html#browser-not-found","text":"playwright install chromium","title":"\"Browser not found\""},{"location":"skills/playwright.html#element-not-found","text":"Check selector syntax Add explicit wait Verify element exists in page","title":"\"Element not found\""},{"location":"skills/playwright.html#timeout","text":"# Increase timeout page . wait_for_selector ( \".element\" , timeout = 10000 ) # 10 seconds","title":"\"Timeout\""},{"location":"skills/playwright.html#debugging","text":"Run with visible browser: browser = p . chromium . launch ( headless = False , slow_mo = 500 )","title":"Debugging"},{"location":"skills/playwright.html#anti-patterns","text":"The skill warns against: Visible browser mode - Use headless Arbitrary sleeps - Use explicit waits CSS selectors first - Use role-based No error capture - Always capture diagnostics","title":"Anti-patterns"},{"location":"skills/playwright.html#try-it-yourself","text":"","title":"Try It Yourself"},{"location":"skills/playwright.html#exercise-1-screenshot","text":"> Load playwright skill > Take a screenshot of https://github.com","title":"Exercise 1: Screenshot"},{"location":"skills/playwright.html#exercise-2-form-test","text":"> Test the search functionality on https://duckduckgo.com","title":"Exercise 2: Form Test"},{"location":"skills/playwright.html#exercise-3-data-extraction","text":"> Extract all headlines from https://news.ycombinator.com","title":"Exercise 3: Data Extraction"},{"location":"skills/playwright.html#source","text":"robotdad/skills/playwright/ \u251c\u2500\u2500 SKILL.md # Core workflow \u251c\u2500\u2500 patterns.md # Advanced patterns \u251c\u2500\u2500 setup.md # Installation \u2514\u2500\u2500 troubleshooting.md # Common issues","title":"Source"},{"location":"tools/index.html","text":"Tools Reference \u00b6 Tools are the fundamental building blocks that give Amplifier its capabilities. Each tool provides a specific function\u2014from file operations to web searches\u2014that agents can invoke to accomplish tasks. This section covers all available tools, their parameters, and best practices for effective use. Section Contents \u00b6 Page Description Filesystem Read, write, and edit files with precision Search (grep & glob) Find content and files across your codebase Bash Run shell commands safely Web Tools Search and fetch content from the web LSP (Code Intelligence) Language Server Protocol for code understanding Task (Sub-Agents) Spawn agents for complex operations Recipes Tool Declarative multi-step workflows Quick Tips \u00b6 Prefer specialized tools over bash - Use read_file instead of cat , edit_file instead of sed Parallel execution - Independent tool calls can run simultaneously for speed Check before writing - Always read a file before editing to understand context Use glob for discovery - Find files by pattern before targeted operations Grep for content - Search inside files with regex patterns Tool Categories \u00b6 File System \u00b6 Core operations for interacting with the local filesystem. These are your most frequently used tools. Search & Discovery \u00b6 Find files and content across your codebase quickly and efficiently. External Resources \u00b6 Connect to the web, APIs, and external services when local context isn't enough. Code Intelligence \u00b6 Semantic understanding of code through LSP\u2014definitions, references, and type information. Orchestration \u00b6 Manage complex workflows with task delegation and progress tracking. Where to Start \u00b6 New to Amplifier? Begin with Filesystem to understand the most common tool patterns. Building agents? Jump to Task (Sub-Agents) to learn how agents spawn sub-agents. Searching code? See Search (grep & glob) for grep vs glob guidance. Common Patterns \u00b6 Read Before Edit \u00b6 read_file \u2192 understand content edit_file \u2192 make precise changes Find Then Act \u00b6 glob \u2192 locate files grep \u2192 find specific content read_file \u2192 examine matches Next Steps \u00b6 After mastering tools, explore Concepts to understand how tools fit into the larger architecture.","title":"Overview"},{"location":"tools/index.html#tools-reference","text":"Tools are the fundamental building blocks that give Amplifier its capabilities. Each tool provides a specific function\u2014from file operations to web searches\u2014that agents can invoke to accomplish tasks. This section covers all available tools, their parameters, and best practices for effective use.","title":"Tools Reference"},{"location":"tools/index.html#section-contents","text":"Page Description Filesystem Read, write, and edit files with precision Search (grep & glob) Find content and files across your codebase Bash Run shell commands safely Web Tools Search and fetch content from the web LSP (Code Intelligence) Language Server Protocol for code understanding Task (Sub-Agents) Spawn agents for complex operations Recipes Tool Declarative multi-step workflows","title":"Section Contents"},{"location":"tools/index.html#quick-tips","text":"Prefer specialized tools over bash - Use read_file instead of cat , edit_file instead of sed Parallel execution - Independent tool calls can run simultaneously for speed Check before writing - Always read a file before editing to understand context Use glob for discovery - Find files by pattern before targeted operations Grep for content - Search inside files with regex patterns","title":"Quick Tips"},{"location":"tools/index.html#tool-categories","text":"","title":"Tool Categories"},{"location":"tools/index.html#file-system","text":"Core operations for interacting with the local filesystem. These are your most frequently used tools.","title":"File System"},{"location":"tools/index.html#search-discovery","text":"Find files and content across your codebase quickly and efficiently.","title":"Search &amp; Discovery"},{"location":"tools/index.html#external-resources","text":"Connect to the web, APIs, and external services when local context isn't enough.","title":"External Resources"},{"location":"tools/index.html#code-intelligence","text":"Semantic understanding of code through LSP\u2014definitions, references, and type information.","title":"Code Intelligence"},{"location":"tools/index.html#orchestration","text":"Manage complex workflows with task delegation and progress tracking.","title":"Orchestration"},{"location":"tools/index.html#where-to-start","text":"New to Amplifier? Begin with Filesystem to understand the most common tool patterns. Building agents? Jump to Task (Sub-Agents) to learn how agents spawn sub-agents. Searching code? See Search (grep & glob) for grep vs glob guidance.","title":"Where to Start"},{"location":"tools/index.html#common-patterns","text":"","title":"Common Patterns"},{"location":"tools/index.html#read-before-edit","text":"read_file \u2192 understand content edit_file \u2192 make precise changes","title":"Read Before Edit"},{"location":"tools/index.html#find-then-act","text":"glob \u2192 locate files grep \u2192 find specific content read_file \u2192 examine matches","title":"Find Then Act"},{"location":"tools/index.html#next-steps","text":"After mastering tools, explore Concepts to understand how tools fit into the larger architecture.","title":"Next Steps"},{"location":"tools/bash.html","text":"Bash Tool \u00b6 The Bash Tool provides low-level shell command execution for build operations, testing, package management, version control, and system utilities. While specialized tools exist for many operations, bash serves as a powerful fallback for commands that don't have dedicated interfaces. Operations \u00b6 Operation Purpose Example Run command Execute shell command synchronously pytest tests/ Background Long-running process (returns immediately) npm run dev Basic Usage \u00b6 Conversation Format \u00b6 When you ask Amplifier to run commands, it uses the bash tool behind the scenes: > Run pytest tests/test_auth.py [Tool: bash] Command: pytest tests/test_auth.py Output: ===== test session starts ===== test_auth.py::test_login PASSED ===== 1 passed in 0.23s ===== Direct Syntax \u00b6 The tool accepts these parameters: { \"command\" : \"pytest tests/\" , \"run_in_background\" : false } Common Commands \u00b6 Build and Test \u00b6 Execute test runners and build tools: > Run the test suite pytest tests/ --verbose --cov cargo test --all npm test make test go test ./... mvn test Package Management \u00b6 Install and manage dependencies: > Install the requests package pip install requests npm install lodash cargo add serde gem install rails brew install ripgrep apt-get install curl Version Control \u00b6 Git operations for tracking changes: > Show git status git status git diff src/main.py git log --oneline -10 git branch -a git add . git commit -m \"feat: add authentication\" git push origin main Container Operations \u00b6 Work with Docker and Kubernetes: > Build the docker image docker build -t myapp:latest . docker ps docker logs container-name kubectl get pods kubectl logs pod-name podman run -d nginx GitHub CLI \u00b6 Interact with GitHub repositories: > Create a pull request gh pr create --title \"Fix bug\" --body \"Details\" gh issue list --label bug gh repo view gh workflow run tests.yml System Utilities \u00b6 File operations and system commands: > Find all Python files find . -name \"*.py\" ls -la src/ cat config.json wc -l src/*.py df -h ps aux | grep python Background Processes \u00b6 Use run_in_background: true for long-running processes that shouldn't block: > Start the development server [Tool: bash] { \"command\": \"npm run dev\", \"run_in_background\": true } Returns immediately with PID: 12345 When to Use Background Mode \u00b6 Use background mode for: - Development servers ( npm run dev , python manage.py runserver ) - File watchers ( npm run watch , cargo watch ) - Database servers ( mongod , redis-server ) - Any process that runs continuously Don't use background mode for: - Quick commands that finish in seconds - Commands where you need to see the full output - Build or test commands that should block Managing Background Processes \u00b6 Once started, background processes run independently: > Start the dev server npm run dev # Started in background as PID 12345 > Kill the process later kill 12345 # or pkill -f \"npm run dev\" Safety Features \u00b6 Blocked Commands \u00b6 Amplifier blocks destructive operations to protect your system: \u274c BLOCKED: rm -rf / sudo rm -rf / dd if=/dev/zero of=/dev/sda mkfs.ext4 /dev/sda1 :(){ :|:& };: # Fork bomb Interactive Commands Not Supported \u00b6 Commands requiring user input will fail: \u274c NOT SUPPORTED: vim file.txt nano config.ini python # Interactive REPL npm init # Without -y flag sudo apt install package # Without -y flag Workaround: Use non-interactive flags: \u2705 WORKS: npm init -y sudo apt install -y package python script.py # Non-interactive script Output Truncation \u00b6 Long outputs are automatically truncated to prevent context overflow: Command: find / -name \"*.log\" Output: /var/log/syslog /var/log/auth.log ... [truncated 1847 lines] ... /home/user/app.log [Truncated: 2000/5234 lines, 45KB shown, 180KB total] Workaround for large outputs: # Redirect to file instead find / -name \"*.log\" > results.txt # Then read the file in chunks head -n 100 results.txt tail -n 100 results.txt Structured Data Warning \u00b6 \u26a0\ufe0f JSON/XML truncation breaks parsing: # \u274c Bad: Large JSON may get truncated mid-structure curl https://api.example.com/large-dataset # \u2705 Good: Save to file first curl https://api.example.com/large-dataset > data.json # Then read specific parts Best Practices \u00b6 Path Handling \u00b6 Quote paths with spaces and prefer absolute paths: # \u2705 Good cd \"/path/with spaces/project\" pytest /home/user/project/tests/ # \u274c Problematic cd /path/with spaces/project # Breaks on spaces pytest ../tests/ # Relative paths lose context Command Chaining \u00b6 Chain dependent commands with && to stop on failure: # \u2705 Stops if mkdir fails mkdir build && cd build && cmake .. # \u274c Continues even if mkdir fails mkdir build ; cd build ; cmake .. Error Handling \u00b6 Check command exit codes for critical operations: # \u2705 Explicit error handling npm test || echo \"Tests failed with exit code $? \" # \u2705 Conditional execution if pytest tests/ ; then echo \"Tests passed, deploying...\" ./deploy.sh fi Working Directory Context \u00b6 Remember that each bash invocation maintains context: > Create directory and enter it mkdir myproject && cd myproject > Next command runs in myproject/ pwd # Shows: /home/user/myproject Prefer Specialized Tools \u00b6 Before using bash, check if a specialized tool exists: # \u274c Avoid: Manual file operations bash: cat file.py # \u2705 Better: Use read_file [Tool: read_file] # \u274c Avoid: Manual search bash: find . -name \"*.py\" | xargs grep \"class User\" # \u2705 Better: Use grep tool [Tool: grep] pattern: \"class User\" type: \"py\" Try It Yourself \u00b6 Practice these common scenarios: 1. Run Tests \u00b6 > Run my Python tests with coverage Result: Executes pytest with coverage report 2. Check Git Status \u00b6 > Show me what files have changed Result: Displays git status and diff 3. Install Dependencies \u00b6 > Install packages from requirements.txt Result: Runs pip install -r requirements.txt 4. Start Development Server \u00b6 > Start the Next.js dev server Result: Launches npm run dev in background 5. Build Project \u00b6 > Build the Rust project in release mode Result: Runs cargo build --release Errors and Troubleshooting \u00b6 Command Not Found \u00b6 Error: bash: pytest: command not found Solution: 1. Verify installation: which pytest 2. Install if missing: pip install pytest 3. Check PATH: echo $PATH 4. Use full path: /usr/local/bin/pytest Permission Denied \u00b6 Error: Permission denied: ./script.sh Solution: 1. Make executable: chmod +x script.sh 2. Or run with interpreter: bash script.sh Timeout Issues \u00b6 Error: Command timed out after 300s Solution: 1. Use background mode for long processes 2. Break into smaller commands 3. Add progress indicators to scripts Truncated Output \u00b6 Warning: Output truncated [showing 2000/8000 lines] Solution: 1. Redirect to file: command > output.txt 2. Filter output: command | grep \"ERROR\" 3. Use specialized tools for structured data Working Directory Confusion \u00b6 Error: tests/ directory not found Solution: 1. Check current directory: pwd 2. Use absolute paths: /home/user/project/tests/ 3. Chain cd command: cd project && pytest tests/ Interactive Command Hangs \u00b6 Error: Command appears to hang (waiting for input) Solution: 1. Add non-interactive flags: npm init -y 2. Use expect/heredoc for scripted input 3. Pre-create config files before running Environment Variables \u00b6 Error: Missing required environment variable Solution: 1. Set inline: API_KEY=abc123 python script.py 2. Export first: export API_KEY=abc123 && python script.py 3. Use .env file: source .env && python script.py Advanced Patterns \u00b6 Multi-line Commands \u00b6 # Use line continuation for readability docker run -d \\ --name myapp \\ -p 8080 :80 \\ -v $( pwd ) :/app \\ myimage:latest Conditional Logic \u00b6 # Run tests, deploy only if successful pytest tests/ && npm run build && ./deploy.sh Output Processing \u00b6 # Filter and transform output git log --oneline | head -n 10 | cut -d ' ' -f2- Variable Substitution \u00b6 # Use shell variables VERSION = $( cat VERSION ) docker build -t myapp: $VERSION . Next Steps: - Learn about Task (Sub-Agents) for specialized agent delegation - Explore Filesystem for file operations - See LSP (Code Intelligence) for code understanding","title":"Bash"},{"location":"tools/bash.html#bash-tool","text":"The Bash Tool provides low-level shell command execution for build operations, testing, package management, version control, and system utilities. While specialized tools exist for many operations, bash serves as a powerful fallback for commands that don't have dedicated interfaces.","title":"Bash Tool"},{"location":"tools/bash.html#operations","text":"Operation Purpose Example Run command Execute shell command synchronously pytest tests/ Background Long-running process (returns immediately) npm run dev","title":"Operations"},{"location":"tools/bash.html#basic-usage","text":"","title":"Basic Usage"},{"location":"tools/bash.html#conversation-format","text":"When you ask Amplifier to run commands, it uses the bash tool behind the scenes: > Run pytest tests/test_auth.py [Tool: bash] Command: pytest tests/test_auth.py Output: ===== test session starts ===== test_auth.py::test_login PASSED ===== 1 passed in 0.23s =====","title":"Conversation Format"},{"location":"tools/bash.html#direct-syntax","text":"The tool accepts these parameters: { \"command\" : \"pytest tests/\" , \"run_in_background\" : false }","title":"Direct Syntax"},{"location":"tools/bash.html#common-commands","text":"","title":"Common Commands"},{"location":"tools/bash.html#build-and-test","text":"Execute test runners and build tools: > Run the test suite pytest tests/ --verbose --cov cargo test --all npm test make test go test ./... mvn test","title":"Build and Test"},{"location":"tools/bash.html#package-management","text":"Install and manage dependencies: > Install the requests package pip install requests npm install lodash cargo add serde gem install rails brew install ripgrep apt-get install curl","title":"Package Management"},{"location":"tools/bash.html#version-control","text":"Git operations for tracking changes: > Show git status git status git diff src/main.py git log --oneline -10 git branch -a git add . git commit -m \"feat: add authentication\" git push origin main","title":"Version Control"},{"location":"tools/bash.html#container-operations","text":"Work with Docker and Kubernetes: > Build the docker image docker build -t myapp:latest . docker ps docker logs container-name kubectl get pods kubectl logs pod-name podman run -d nginx","title":"Container Operations"},{"location":"tools/bash.html#github-cli","text":"Interact with GitHub repositories: > Create a pull request gh pr create --title \"Fix bug\" --body \"Details\" gh issue list --label bug gh repo view gh workflow run tests.yml","title":"GitHub CLI"},{"location":"tools/bash.html#system-utilities","text":"File operations and system commands: > Find all Python files find . -name \"*.py\" ls -la src/ cat config.json wc -l src/*.py df -h ps aux | grep python","title":"System Utilities"},{"location":"tools/bash.html#background-processes","text":"Use run_in_background: true for long-running processes that shouldn't block: > Start the development server [Tool: bash] { \"command\": \"npm run dev\", \"run_in_background\": true } Returns immediately with PID: 12345","title":"Background Processes"},{"location":"tools/bash.html#when-to-use-background-mode","text":"Use background mode for: - Development servers ( npm run dev , python manage.py runserver ) - File watchers ( npm run watch , cargo watch ) - Database servers ( mongod , redis-server ) - Any process that runs continuously Don't use background mode for: - Quick commands that finish in seconds - Commands where you need to see the full output - Build or test commands that should block","title":"When to Use Background Mode"},{"location":"tools/bash.html#managing-background-processes","text":"Once started, background processes run independently: > Start the dev server npm run dev # Started in background as PID 12345 > Kill the process later kill 12345 # or pkill -f \"npm run dev\"","title":"Managing Background Processes"},{"location":"tools/bash.html#safety-features","text":"","title":"Safety Features"},{"location":"tools/bash.html#blocked-commands","text":"Amplifier blocks destructive operations to protect your system: \u274c BLOCKED: rm -rf / sudo rm -rf / dd if=/dev/zero of=/dev/sda mkfs.ext4 /dev/sda1 :(){ :|:& };: # Fork bomb","title":"Blocked Commands"},{"location":"tools/bash.html#interactive-commands-not-supported","text":"Commands requiring user input will fail: \u274c NOT SUPPORTED: vim file.txt nano config.ini python # Interactive REPL npm init # Without -y flag sudo apt install package # Without -y flag Workaround: Use non-interactive flags: \u2705 WORKS: npm init -y sudo apt install -y package python script.py # Non-interactive script","title":"Interactive Commands Not Supported"},{"location":"tools/bash.html#output-truncation","text":"Long outputs are automatically truncated to prevent context overflow: Command: find / -name \"*.log\" Output: /var/log/syslog /var/log/auth.log ... [truncated 1847 lines] ... /home/user/app.log [Truncated: 2000/5234 lines, 45KB shown, 180KB total] Workaround for large outputs: # Redirect to file instead find / -name \"*.log\" > results.txt # Then read the file in chunks head -n 100 results.txt tail -n 100 results.txt","title":"Output Truncation"},{"location":"tools/bash.html#structured-data-warning","text":"\u26a0\ufe0f JSON/XML truncation breaks parsing: # \u274c Bad: Large JSON may get truncated mid-structure curl https://api.example.com/large-dataset # \u2705 Good: Save to file first curl https://api.example.com/large-dataset > data.json # Then read specific parts","title":"Structured Data Warning"},{"location":"tools/bash.html#best-practices","text":"","title":"Best Practices"},{"location":"tools/bash.html#path-handling","text":"Quote paths with spaces and prefer absolute paths: # \u2705 Good cd \"/path/with spaces/project\" pytest /home/user/project/tests/ # \u274c Problematic cd /path/with spaces/project # Breaks on spaces pytest ../tests/ # Relative paths lose context","title":"Path Handling"},{"location":"tools/bash.html#command-chaining","text":"Chain dependent commands with && to stop on failure: # \u2705 Stops if mkdir fails mkdir build && cd build && cmake .. # \u274c Continues even if mkdir fails mkdir build ; cd build ; cmake ..","title":"Command Chaining"},{"location":"tools/bash.html#error-handling","text":"Check command exit codes for critical operations: # \u2705 Explicit error handling npm test || echo \"Tests failed with exit code $? \" # \u2705 Conditional execution if pytest tests/ ; then echo \"Tests passed, deploying...\" ./deploy.sh fi","title":"Error Handling"},{"location":"tools/bash.html#working-directory-context","text":"Remember that each bash invocation maintains context: > Create directory and enter it mkdir myproject && cd myproject > Next command runs in myproject/ pwd # Shows: /home/user/myproject","title":"Working Directory Context"},{"location":"tools/bash.html#prefer-specialized-tools","text":"Before using bash, check if a specialized tool exists: # \u274c Avoid: Manual file operations bash: cat file.py # \u2705 Better: Use read_file [Tool: read_file] # \u274c Avoid: Manual search bash: find . -name \"*.py\" | xargs grep \"class User\" # \u2705 Better: Use grep tool [Tool: grep] pattern: \"class User\" type: \"py\"","title":"Prefer Specialized Tools"},{"location":"tools/bash.html#try-it-yourself","text":"Practice these common scenarios:","title":"Try It Yourself"},{"location":"tools/bash.html#1-run-tests","text":"> Run my Python tests with coverage Result: Executes pytest with coverage report","title":"1. Run Tests"},{"location":"tools/bash.html#2-check-git-status","text":"> Show me what files have changed Result: Displays git status and diff","title":"2. Check Git Status"},{"location":"tools/bash.html#3-install-dependencies","text":"> Install packages from requirements.txt Result: Runs pip install -r requirements.txt","title":"3. Install Dependencies"},{"location":"tools/bash.html#4-start-development-server","text":"> Start the Next.js dev server Result: Launches npm run dev in background","title":"4. Start Development Server"},{"location":"tools/bash.html#5-build-project","text":"> Build the Rust project in release mode Result: Runs cargo build --release","title":"5. Build Project"},{"location":"tools/bash.html#errors-and-troubleshooting","text":"","title":"Errors and Troubleshooting"},{"location":"tools/bash.html#command-not-found","text":"Error: bash: pytest: command not found Solution: 1. Verify installation: which pytest 2. Install if missing: pip install pytest 3. Check PATH: echo $PATH 4. Use full path: /usr/local/bin/pytest","title":"Command Not Found"},{"location":"tools/bash.html#permission-denied","text":"Error: Permission denied: ./script.sh Solution: 1. Make executable: chmod +x script.sh 2. Or run with interpreter: bash script.sh","title":"Permission Denied"},{"location":"tools/bash.html#timeout-issues","text":"Error: Command timed out after 300s Solution: 1. Use background mode for long processes 2. Break into smaller commands 3. Add progress indicators to scripts","title":"Timeout Issues"},{"location":"tools/bash.html#truncated-output","text":"Warning: Output truncated [showing 2000/8000 lines] Solution: 1. Redirect to file: command > output.txt 2. Filter output: command | grep \"ERROR\" 3. Use specialized tools for structured data","title":"Truncated Output"},{"location":"tools/bash.html#working-directory-confusion","text":"Error: tests/ directory not found Solution: 1. Check current directory: pwd 2. Use absolute paths: /home/user/project/tests/ 3. Chain cd command: cd project && pytest tests/","title":"Working Directory Confusion"},{"location":"tools/bash.html#interactive-command-hangs","text":"Error: Command appears to hang (waiting for input) Solution: 1. Add non-interactive flags: npm init -y 2. Use expect/heredoc for scripted input 3. Pre-create config files before running","title":"Interactive Command Hangs"},{"location":"tools/bash.html#environment-variables","text":"Error: Missing required environment variable Solution: 1. Set inline: API_KEY=abc123 python script.py 2. Export first: export API_KEY=abc123 && python script.py 3. Use .env file: source .env && python script.py","title":"Environment Variables"},{"location":"tools/bash.html#advanced-patterns","text":"","title":"Advanced Patterns"},{"location":"tools/bash.html#multi-line-commands","text":"# Use line continuation for readability docker run -d \\ --name myapp \\ -p 8080 :80 \\ -v $( pwd ) :/app \\ myimage:latest","title":"Multi-line Commands"},{"location":"tools/bash.html#conditional-logic","text":"# Run tests, deploy only if successful pytest tests/ && npm run build && ./deploy.sh","title":"Conditional Logic"},{"location":"tools/bash.html#output-processing","text":"# Filter and transform output git log --oneline | head -n 10 | cut -d ' ' -f2-","title":"Output Processing"},{"location":"tools/bash.html#variable-substitution","text":"# Use shell variables VERSION = $( cat VERSION ) docker build -t myapp: $VERSION . Next Steps: - Learn about Task (Sub-Agents) for specialized agent delegation - Explore Filesystem for file operations - See LSP (Code Intelligence) for code understanding","title":"Variable Substitution"},{"location":"tools/filesystem.html","text":"Filesystem Tool \u00b6 The Filesystem Tool provides three essential operations for file manipulation: reading, writing, and editing files. These tools work with absolute paths, relative paths, and @mention paths for bundle resources. Operations \u00b6 Operation Tool Purpose Read read_file Read file contents or list directories Write write_file Create or overwrite entire files Edit edit_file Perform surgical string replacements Reading Files \u00b6 The read_file tool reads file contents or lists directory contents with line numbers. Basic File Reading \u00b6 { \"file_path\" : \"./src/main.py\" } Returns the file with line numbers in cat -n format: 1 import sys 2 3 def main(): 4 print(\"Hello, world!\") Reading Large Files \u00b6 For files with many lines, use offset and limit parameters: { \"file_path\" : \"./logs/app.log\" , \"offset\" : 100 , \"limit\" : 50 } This reads lines 100-150, useful for: - Inspecting specific sections of large logs - Paginating through long files - Reducing context consumption Default limits: - Maximum 2000 lines per read - Lines longer than 2000 characters are truncated - Line numbers start at 1 (not 0) Directory Listing \u00b6 When file_path points to a directory, read_file returns a formatted listing: { \"file_path\" : \"./src\" } Returns: DIR: components/ DIR: utils/ FILE: main.py FILE: config.py Path Formats Supported \u00b6 Absolute paths: { \"file_path\" : \"/home/user/project/file.md\" } Relative paths: { \"file_path\" : \"./docs/README.md\" } Bundle resources: { \"file_path\" : \"@mybundle:docs/guide.md\" } Bundle directories: { \"file_path\" : \"@mybundle:docs\" } Writing Files \u00b6 The write_file tool creates new files or overwrites existing ones completely. Basic Writing \u00b6 { \"file_path\" : \"./src/new_module.py\" , \"content\" : \"def calculate(x, y):\\n return x + y\\n\" } Important Rules \u00b6 \u26a0\ufe0f MUST read existing files first: // Step 1: Read first { \"file_path\" : \"./src/existing.py\" } // Step 2: Then write { \"file_path\" : \"./src/existing.py\" , \"content\" : \"new content\" } The tool will fail if you attempt to overwrite an existing file without reading it first. This safety mechanism prevents accidental overwrites. When to Use write_file \u00b6 \u2705 Good use cases: - Creating entirely new files - Generating configuration files - Writing output from code generation - Creating test fixtures \u274c Avoid for: - Modifying existing files (use edit_file instead) - Small changes to files (use edit_file instead) - Adding single functions to modules (use edit_file instead) Content Guidelines \u00b6 Avoid emoji unless explicitly requested by user Never proactively create documentation (*.md) files Always prefer editing existing files over creating new ones Editing Files \u00b6 The edit_file tool performs precise string replacements in existing files. Basic Editing \u00b6 { \"file_path\" : \"./src/main.py\" , \"old_string\" : \"def calculate(x):\\n return x * 2\" , \"new_string\" : \"def calculate(x, multiplier=2):\\n return x * multiplier\" } Preserving Indentation \u00b6 \u26a0\ufe0f Critical: Preserve exact indentation as shown in read_file output. The line number format is: spaces + number + tab + content Example from read_file: 42 def helper(): 43 return True Correct old_string (after the tab): \"def helper():\\n return True\" Incorrect (includes line numbers): \" 42 def helper():\\n 43 return True\" Ensuring Uniqueness \u00b6 The tool requires old_string to be unique in the file: \u274c Will fail (matches multiple locations): { \"old_string\" : \"return x\" } \u2705 Include context to make it unique: { \"old_string\" : \"def calculate(x):\\n return x\" } Replace All Occurrences \u00b6 Use replace_all: true for renaming variables or repeated patterns: { \"file_path\" : \"./src/user.py\" , \"old_string\" : \"userName\" , \"new_string\" : \"user_name\" , \"replace_all\" : true } Perfect for: - Variable renaming across a file - Updating repeated string literals - Changing function names - Updating import paths When to Use edit_file \u00b6 \u2705 Preferred for: - Modifying functions or classes - Adding imports - Changing variable names - Updating configuration values - Bug fixes in existing code \u2705 Benefits: - Preserves surrounding code - Safer than full file rewrites - More efficient for small changes - Less prone to losing unrelated changes Directory Listing \u00b6 List directory contents with read_file : { \"file_path\" : \"./src/components\" } Output shows: - DIR: prefix for subdirectories - FILE: prefix for files - Alphabetically sorted - Relative names only (not full paths) Use cases: - Exploring project structure - Finding configuration files - Discovering test files - Checking bundle contents Best Practices \u00b6 1. Always Read Before Editing \u00b6 // \u2705 Correct workflow read_ f ile( \"./src/app.py\" ) // ... review contents ... edi t _ f ile( \"./src/app.py\" , old_s tr i n g , ne w_s tr i n g) // \u274c Will fail edi t _ f ile( \"./src/app.py\" , old_s tr i n g , ne w_s tr i n g) 2. Prefer edit_file Over write_file \u00b6 For existing files, surgical edits are safer: // \u2705 Preferred - surgical edit edi t _ f ile( { \"old_string\" : \"version = \\\"1.0\\\"\" , \"new_string\" : \"version = \\\"2.0\\\"\" } ) // \u274c Risky - full rewrite wri te _ f ile( { \"content\" : \"... entire file contents ...\" } ) 3. Use Parallel Reads \u00b6 Read multiple files in one message: [ { \"file_path\" : \"./src/main.py\" }, { \"file_path\" : \"./src/utils.py\" }, { \"file_path\" : \"./tests/test_main.py\" } ] 4. Handle Large Files Efficiently \u00b6 // Check file size first read_ f ile( \"./data/large.json\" , 0 , 10 ) // Read in chunks if needed read_ f ile( \"./data/large.json\" , 0 , 100 ) read_ f ile( \"./data/large.json\" , 100 , 100 ) 5. Verify Bundle Paths \u00b6 For bundle resources, check directory listing first: // List available files read_ f ile( \"@recipes:examples\" ) // Then read specific file read_ f ile( \"@recipes:examples/workflow.yaml\" ) Try It Yourself \u00b6 Exercise 1: Read and Edit a File \u00b6 Create a test file: wri te _ f ile( { \"file_path\" : \"./test.py\" , \"content\" : \"def greet(name):\\n return f'Hello {name}'\" } ) Read it back: read_ f ile( { \"file_path\" : \"./test.py\" } ) Edit the function: edi t _ f ile( { \"file_path\" : \"./test.py\" , \"old_string\" : \"def greet(name):\\n return f'Hello {name}'\" , \"new_string\" : \"def greet(name, title='Friend'):\\n return f'Hello {title} {name}'\" } ) Exercise 2: Explore a Directory Structure \u00b6 read_ f ile( { \"file_path\" : \"./content\" } ) read_ f ile( { \"file_path\" : \"./content/tools\" } ) Exercise 3: Variable Renaming \u00b6 edi t _ f ile( { \"file_path\" : \"./src/config.py\" , \"old_string\" : \"max_retries\" , \"new_string\" : \"maximum_retry_count\" , \"replace_all\" : true } ) Errors and Troubleshooting \u00b6 Error: \"Must read file before editing\" \u00b6 Cause: Attempted to edit without reading first. Solution: read_ f ile( { \"file_path\" : \"./target.py\" } ) // Then edit Error: \"old_string not unique\" \u00b6 Cause: The string appears multiple times in the file. Solutions: 1. Add more context to make it unique: { \"old_string\" : \"return value // More context needed\" , \"new_string\" : \"function calculate() {\\n return value\\n}\" } Use replace_all: true if appropriate: { \"replace_all\" : true } Error: \"File not found\" \u00b6 Cause: Path doesn't exist or is incorrect. Solutions: - Verify path with directory listing - Check for typos in filename - Use absolute path if relative path is ambiguous - Confirm bundle name for @mention paths Warning: Empty File Contents \u00b6 If you read a file that exists but is empty, you'll receive a warning. This helps distinguish between: - File doesn't exist (error) - File exists but is empty (warning) - File has content (normal output) Indentation Mismatch \u00b6 Cause: Including line numbers or wrong whitespace in old_string . Solution: - Copy exact content after the line number tab - Preserve spaces/tabs exactly as shown - Don't include the line number prefix Line Truncation \u00b6 Lines longer than 2000 characters are truncated. For such files: - Use specialized tools for specific content types (JSON parsers, etc.) - Process in smaller chunks - Consider using bash tool for stream processing Advanced Patterns \u00b6 Conditional Edits \u00b6 Read first, decide, then edit based on content: # 1. Read file content = read_file ( \"./config.yaml\" ) # 2. Analyze content if \"debug: false\" in content : # 3. Edit accordingly edit_file ( old_string = \"debug: false\" , new_string = \"debug: true\" ) Multi-Step Refactoring \u00b6 # 1. Read original read_file ( \"./src/api.py\" ) # 2. First edit - rename function edit_file ( old_string = \"def old_name():\" , new_string = \"def new_name():\" ) # 3. Second edit - update callers edit_file ( old_string = \"old_name()\" , new_string = \"new_name()\" , replace_all = True ) Safe Templating \u00b6 # 1. Read template template = read_file ( \"@mybundle:templates/component.tsx\" ) # 2. Write new file with modifications write_file ( file_path = \"./src/components/MyComponent.tsx\" , content = template . replace ( \"{{NAME}}\" , \"MyComponent\" ) ) Summary \u00b6 The Filesystem Tool provides three complementary operations: read_file : View contents, paginate large files, list directories write_file : Create new files (read existing files first!) edit_file : Surgical replacements (prefer over write_file) Key principles: 1. Always read before editing 2. Prefer edit over write for existing files 3. Ensure old_string is unique or use replace_all 4. Preserve exact indentation from read_file output 5. Use parallel reads for efficiency These tools form the foundation of file manipulation in Amplifier, enabling precise control over your project's files.","title":"Filesystem"},{"location":"tools/filesystem.html#filesystem-tool","text":"The Filesystem Tool provides three essential operations for file manipulation: reading, writing, and editing files. These tools work with absolute paths, relative paths, and @mention paths for bundle resources.","title":"Filesystem Tool"},{"location":"tools/filesystem.html#operations","text":"Operation Tool Purpose Read read_file Read file contents or list directories Write write_file Create or overwrite entire files Edit edit_file Perform surgical string replacements","title":"Operations"},{"location":"tools/filesystem.html#reading-files","text":"The read_file tool reads file contents or lists directory contents with line numbers.","title":"Reading Files"},{"location":"tools/filesystem.html#basic-file-reading","text":"{ \"file_path\" : \"./src/main.py\" } Returns the file with line numbers in cat -n format: 1 import sys 2 3 def main(): 4 print(\"Hello, world!\")","title":"Basic File Reading"},{"location":"tools/filesystem.html#reading-large-files","text":"For files with many lines, use offset and limit parameters: { \"file_path\" : \"./logs/app.log\" , \"offset\" : 100 , \"limit\" : 50 } This reads lines 100-150, useful for: - Inspecting specific sections of large logs - Paginating through long files - Reducing context consumption Default limits: - Maximum 2000 lines per read - Lines longer than 2000 characters are truncated - Line numbers start at 1 (not 0)","title":"Reading Large Files"},{"location":"tools/filesystem.html#directory-listing","text":"When file_path points to a directory, read_file returns a formatted listing: { \"file_path\" : \"./src\" } Returns: DIR: components/ DIR: utils/ FILE: main.py FILE: config.py","title":"Directory Listing"},{"location":"tools/filesystem.html#path-formats-supported","text":"Absolute paths: { \"file_path\" : \"/home/user/project/file.md\" } Relative paths: { \"file_path\" : \"./docs/README.md\" } Bundle resources: { \"file_path\" : \"@mybundle:docs/guide.md\" } Bundle directories: { \"file_path\" : \"@mybundle:docs\" }","title":"Path Formats Supported"},{"location":"tools/filesystem.html#writing-files","text":"The write_file tool creates new files or overwrites existing ones completely.","title":"Writing Files"},{"location":"tools/filesystem.html#basic-writing","text":"{ \"file_path\" : \"./src/new_module.py\" , \"content\" : \"def calculate(x, y):\\n return x + y\\n\" }","title":"Basic Writing"},{"location":"tools/filesystem.html#important-rules","text":"\u26a0\ufe0f MUST read existing files first: // Step 1: Read first { \"file_path\" : \"./src/existing.py\" } // Step 2: Then write { \"file_path\" : \"./src/existing.py\" , \"content\" : \"new content\" } The tool will fail if you attempt to overwrite an existing file without reading it first. This safety mechanism prevents accidental overwrites.","title":"Important Rules"},{"location":"tools/filesystem.html#when-to-use-write_file","text":"\u2705 Good use cases: - Creating entirely new files - Generating configuration files - Writing output from code generation - Creating test fixtures \u274c Avoid for: - Modifying existing files (use edit_file instead) - Small changes to files (use edit_file instead) - Adding single functions to modules (use edit_file instead)","title":"When to Use write_file"},{"location":"tools/filesystem.html#content-guidelines","text":"Avoid emoji unless explicitly requested by user Never proactively create documentation (*.md) files Always prefer editing existing files over creating new ones","title":"Content Guidelines"},{"location":"tools/filesystem.html#editing-files","text":"The edit_file tool performs precise string replacements in existing files.","title":"Editing Files"},{"location":"tools/filesystem.html#basic-editing","text":"{ \"file_path\" : \"./src/main.py\" , \"old_string\" : \"def calculate(x):\\n return x * 2\" , \"new_string\" : \"def calculate(x, multiplier=2):\\n return x * multiplier\" }","title":"Basic Editing"},{"location":"tools/filesystem.html#preserving-indentation","text":"\u26a0\ufe0f Critical: Preserve exact indentation as shown in read_file output. The line number format is: spaces + number + tab + content Example from read_file: 42 def helper(): 43 return True Correct old_string (after the tab): \"def helper():\\n return True\" Incorrect (includes line numbers): \" 42 def helper():\\n 43 return True\"","title":"Preserving Indentation"},{"location":"tools/filesystem.html#ensuring-uniqueness","text":"The tool requires old_string to be unique in the file: \u274c Will fail (matches multiple locations): { \"old_string\" : \"return x\" } \u2705 Include context to make it unique: { \"old_string\" : \"def calculate(x):\\n return x\" }","title":"Ensuring Uniqueness"},{"location":"tools/filesystem.html#replace-all-occurrences","text":"Use replace_all: true for renaming variables or repeated patterns: { \"file_path\" : \"./src/user.py\" , \"old_string\" : \"userName\" , \"new_string\" : \"user_name\" , \"replace_all\" : true } Perfect for: - Variable renaming across a file - Updating repeated string literals - Changing function names - Updating import paths","title":"Replace All Occurrences"},{"location":"tools/filesystem.html#when-to-use-edit_file","text":"\u2705 Preferred for: - Modifying functions or classes - Adding imports - Changing variable names - Updating configuration values - Bug fixes in existing code \u2705 Benefits: - Preserves surrounding code - Safer than full file rewrites - More efficient for small changes - Less prone to losing unrelated changes","title":"When to Use edit_file"},{"location":"tools/filesystem.html#directory-listing_1","text":"List directory contents with read_file : { \"file_path\" : \"./src/components\" } Output shows: - DIR: prefix for subdirectories - FILE: prefix for files - Alphabetically sorted - Relative names only (not full paths) Use cases: - Exploring project structure - Finding configuration files - Discovering test files - Checking bundle contents","title":"Directory Listing"},{"location":"tools/filesystem.html#best-practices","text":"","title":"Best Practices"},{"location":"tools/filesystem.html#1-always-read-before-editing","text":"// \u2705 Correct workflow read_ f ile( \"./src/app.py\" ) // ... review contents ... edi t _ f ile( \"./src/app.py\" , old_s tr i n g , ne w_s tr i n g) // \u274c Will fail edi t _ f ile( \"./src/app.py\" , old_s tr i n g , ne w_s tr i n g)","title":"1. Always Read Before Editing"},{"location":"tools/filesystem.html#2-prefer-edit_file-over-write_file","text":"For existing files, surgical edits are safer: // \u2705 Preferred - surgical edit edi t _ f ile( { \"old_string\" : \"version = \\\"1.0\\\"\" , \"new_string\" : \"version = \\\"2.0\\\"\" } ) // \u274c Risky - full rewrite wri te _ f ile( { \"content\" : \"... entire file contents ...\" } )","title":"2. Prefer edit_file Over write_file"},{"location":"tools/filesystem.html#3-use-parallel-reads","text":"Read multiple files in one message: [ { \"file_path\" : \"./src/main.py\" }, { \"file_path\" : \"./src/utils.py\" }, { \"file_path\" : \"./tests/test_main.py\" } ]","title":"3. Use Parallel Reads"},{"location":"tools/filesystem.html#4-handle-large-files-efficiently","text":"// Check file size first read_ f ile( \"./data/large.json\" , 0 , 10 ) // Read in chunks if needed read_ f ile( \"./data/large.json\" , 0 , 100 ) read_ f ile( \"./data/large.json\" , 100 , 100 )","title":"4. Handle Large Files Efficiently"},{"location":"tools/filesystem.html#5-verify-bundle-paths","text":"For bundle resources, check directory listing first: // List available files read_ f ile( \"@recipes:examples\" ) // Then read specific file read_ f ile( \"@recipes:examples/workflow.yaml\" )","title":"5. Verify Bundle Paths"},{"location":"tools/filesystem.html#try-it-yourself","text":"","title":"Try It Yourself"},{"location":"tools/filesystem.html#exercise-1-read-and-edit-a-file","text":"Create a test file: wri te _ f ile( { \"file_path\" : \"./test.py\" , \"content\" : \"def greet(name):\\n return f'Hello {name}'\" } ) Read it back: read_ f ile( { \"file_path\" : \"./test.py\" } ) Edit the function: edi t _ f ile( { \"file_path\" : \"./test.py\" , \"old_string\" : \"def greet(name):\\n return f'Hello {name}'\" , \"new_string\" : \"def greet(name, title='Friend'):\\n return f'Hello {title} {name}'\" } )","title":"Exercise 1: Read and Edit a File"},{"location":"tools/filesystem.html#exercise-2-explore-a-directory-structure","text":"read_ f ile( { \"file_path\" : \"./content\" } ) read_ f ile( { \"file_path\" : \"./content/tools\" } )","title":"Exercise 2: Explore a Directory Structure"},{"location":"tools/filesystem.html#exercise-3-variable-renaming","text":"edi t _ f ile( { \"file_path\" : \"./src/config.py\" , \"old_string\" : \"max_retries\" , \"new_string\" : \"maximum_retry_count\" , \"replace_all\" : true } )","title":"Exercise 3: Variable Renaming"},{"location":"tools/filesystem.html#errors-and-troubleshooting","text":"","title":"Errors and Troubleshooting"},{"location":"tools/filesystem.html#error-must-read-file-before-editing","text":"Cause: Attempted to edit without reading first. Solution: read_ f ile( { \"file_path\" : \"./target.py\" } ) // Then edit","title":"Error: \"Must read file before editing\""},{"location":"tools/filesystem.html#error-old_string-not-unique","text":"Cause: The string appears multiple times in the file. Solutions: 1. Add more context to make it unique: { \"old_string\" : \"return value // More context needed\" , \"new_string\" : \"function calculate() {\\n return value\\n}\" } Use replace_all: true if appropriate: { \"replace_all\" : true }","title":"Error: \"old_string not unique\""},{"location":"tools/filesystem.html#error-file-not-found","text":"Cause: Path doesn't exist or is incorrect. Solutions: - Verify path with directory listing - Check for typos in filename - Use absolute path if relative path is ambiguous - Confirm bundle name for @mention paths","title":"Error: \"File not found\""},{"location":"tools/filesystem.html#warning-empty-file-contents","text":"If you read a file that exists but is empty, you'll receive a warning. This helps distinguish between: - File doesn't exist (error) - File exists but is empty (warning) - File has content (normal output)","title":"Warning: Empty File Contents"},{"location":"tools/filesystem.html#indentation-mismatch","text":"Cause: Including line numbers or wrong whitespace in old_string . Solution: - Copy exact content after the line number tab - Preserve spaces/tabs exactly as shown - Don't include the line number prefix","title":"Indentation Mismatch"},{"location":"tools/filesystem.html#line-truncation","text":"Lines longer than 2000 characters are truncated. For such files: - Use specialized tools for specific content types (JSON parsers, etc.) - Process in smaller chunks - Consider using bash tool for stream processing","title":"Line Truncation"},{"location":"tools/filesystem.html#advanced-patterns","text":"","title":"Advanced Patterns"},{"location":"tools/filesystem.html#conditional-edits","text":"Read first, decide, then edit based on content: # 1. Read file content = read_file ( \"./config.yaml\" ) # 2. Analyze content if \"debug: false\" in content : # 3. Edit accordingly edit_file ( old_string = \"debug: false\" , new_string = \"debug: true\" )","title":"Conditional Edits"},{"location":"tools/filesystem.html#multi-step-refactoring","text":"# 1. Read original read_file ( \"./src/api.py\" ) # 2. First edit - rename function edit_file ( old_string = \"def old_name():\" , new_string = \"def new_name():\" ) # 3. Second edit - update callers edit_file ( old_string = \"old_name()\" , new_string = \"new_name()\" , replace_all = True )","title":"Multi-Step Refactoring"},{"location":"tools/filesystem.html#safe-templating","text":"# 1. Read template template = read_file ( \"@mybundle:templates/component.tsx\" ) # 2. Write new file with modifications write_file ( file_path = \"./src/components/MyComponent.tsx\" , content = template . replace ( \"{{NAME}}\" , \"MyComponent\" ) )","title":"Safe Templating"},{"location":"tools/filesystem.html#summary","text":"The Filesystem Tool provides three complementary operations: read_file : View contents, paginate large files, list directories write_file : Create new files (read existing files first!) edit_file : Surgical replacements (prefer over write_file) Key principles: 1. Always read before editing 2. Prefer edit over write for existing files 3. Ensure old_string is unique or use replace_all 4. Preserve exact indentation from read_file output 5. Use parallel reads for efficiency These tools form the foundation of file manipulation in Amplifier, enabling precise control over your project's files.","title":"Summary"},{"location":"tools/lsp.html","text":"LSP Tool (Code Intelligence) \u00b6 What is LSP? \u00b6 The Language Server Protocol (LSP) is a standardized protocol that provides semantic code understanding capabilities to editors and development tools. Unlike text-based search tools like grep , LSP understands the actual structure and meaning of your code. LSP enables powerful code intelligence features by: Understanding syntax and semantics : LSP knows what identifiers are functions, classes, variables, etc. Tracking relationships : It understands how code elements relate to each other (calls, references, inheritance) Type awareness : It knows the types of variables and function signatures Cross-file analysis : It can trace definitions and references across your entire codebase The LSP tool in Amplifier connects to language servers (like Pyright for Python, TypeScript language server, etc.) to provide semantic code analysis that goes far beyond pattern matching. LSP vs Grep \u00b6 Understanding when to use LSP versus grep is crucial for efficient code navigation: Task Use LSP Use Grep Find where function is called incomingCalls - finds actual call sites Matches any string occurrence, including comments Find function definition goToDefinition - goes to exact definition Returns multiple matches including false positives Get type information hover - shows type, signature, docs Not possible with text search Find all references findReferences - semantic references only Matches variable names in unrelated contexts Understand code structure outgoingCalls - shows call hierarchy Can't distinguish between different scopes Search across languages Limited language support Works on any text file Search in comments/strings Not designed for this Perfect for text content Quick pattern matching Slower, needs language server Extremely fast for simple patterns Rule of thumb : Use LSP for semantic code queries, grep for text pattern matching. Operations \u00b6 The LSP tool provides several powerful operations for code intelligence: goToDefinition \u00b6 Jump to where a symbol is defined: lsp(operation=\"goToDefinition\", path=\"src/main.py\", line=10, character=5) Use cases: - Find where a function is implemented - Locate class definitions - Jump to variable declarations - Trace imports to their source Returns: File path, line number, and character position of the definition. findReferences \u00b6 Find all places where a symbol is used: lsp(operation=\"findReferences\", path=\"src/utils.py\", line=15, character=8) Use cases: - Understand how widely a function is used - Assess impact before refactoring - Find all usages of a class or variable - Trace data flow through the codebase Returns: List of all locations where the symbol is referenced, including file, line, and character positions. hover \u00b6 Get detailed information about a symbol at a specific location: lsp(operation=\"hover\", path=\"src/api.py\", line=20, character=12) Use cases: - Check function signatures and parameter types - View documentation strings - Understand variable types - See return type information Returns: Type information, documentation, and signature details for the symbol. incomingCalls \u00b6 Find all functions that call a specific function: lsp(operation=\"incomingCalls\", path=\"src/service.py\", line=50, character=4) Use cases: - Understand the call hierarchy - Find who depends on your function - Trace execution flow backwards - Impact analysis for changes Returns: List of functions that call the target function, with their locations. outgoingCalls \u00b6 Find all functions that a specific function calls: lsp(operation=\"outgoingCalls\", path=\"src/handler.py\", line=30, character=4) Use cases: - Understand what a function depends on - Trace execution flow forwards - Map out component dependencies - Analyze function complexity Returns: List of functions called by the target function, with their locations. Python-Specific \u00b6 The LSP tool uses Pyright as the language server for Python code, providing robust type checking and code intelligence. Pyright Integration \u00b6 Pyright offers excellent Python support including: Type inference : Understands types even without annotations Stub file support : Uses .pyi stubs for better type information Configuration : Respects pyproject.toml and pyrightconfig.json Virtual environment detection : Automatically finds your venv/virtualenv Type Checking Levels \u00b6 Pyright supports different type checking modes: - Basic : Minimal type checking (default for LSP queries) - Standard : Moderate type checking - Strict : Comprehensive type checking Common Python LSP Queries \u00b6 Finding method implementations in class hierarchies: # Use goToDefinition on a method call to find which implementation is actually used result = obj . process () # goToDefinition here shows the actual implementation Tracing decorators: # hover over @decorator to see what it does @cache @validate_input def expensive_function (): pass Understanding complex types: # hover over variables to see inferred types data = process_items ( items ) # hover shows: data: Dict[str, List[Item]] Python-Specific Tips \u00b6 Virtual environments : Ensure your language server can find your venv for accurate import resolution Type hints : Add type hints for better LSP results Docstrings : LSP shows docstrings in hover information Imports : Use absolute imports for better cross-file navigation Best Practices \u00b6 When to Use LSP \u00b6 \u2705 DO use LSP for: - Finding function definitions and implementations - Understanding call hierarchies - Checking types and signatures - Refactoring impact analysis - Semantic code navigation - Cross-referencing symbols \u274c DON'T use LSP for: - Searching in comments or documentation - Finding string literals or patterns - Searching across non-code files - Quick text-based searches - Files without language server support Efficient LSP Workflows \u00b6 1. Start broad, then narrow: 1. Use findReferences to see all usages 2. Use incomingCalls to understand the call chain 3. Use goToDefinition to examine specific implementations 2. Combine with grep: 1. Use grep to find candidate files/patterns 2. Use LSP to understand semantic relationships 3. Use grep again to verify string patterns if needed 3. Leverage hover for quick insights: - Before diving into definitions, use hover to get a quick overview - Check function signatures before tracing calls - Understand types before following references Performance Considerations \u00b6 Large codebases : LSP may take time to index initially Language server startup : First query may be slower Multiple files : Batch queries when possible Fallback strategy : If LSP is slow, use grep for initial exploration Error Handling \u00b6 LSP operations may fail if: - Language server is not available for the file type - File has syntax errors preventing analysis - Position is invalid or in a comment - Symbol cannot be resolved (e.g., dynamic imports) In these cases, fall back to text-based tools like grep. Try It Yourself \u00b6 Exercise 1: Navigate a Function Call \u00b6 Find a function definition in your codebase Use findReferences to see all its usages Use incomingCalls to see what functions call it Use goToDefinition on one of the call sites to jump back Exercise 2: Understand Type Flow \u00b6 Pick a variable assignment in your code Use hover to see its type Use findReferences to see where it's used Use hover on each usage to see how the type flows Exercise 3: Analyze a Refactoring \u00b6 Choose a function you want to rename Use findReferences to find all usages Use incomingCalls to find all callers Check if any usage is in a critical path Assess the refactoring impact Exercise 4: Trace Execution Flow \u00b6 Start with an entry point function Use outgoingCalls to see what it calls For each called function, repeat step 2 Build a mental map of the execution flow Use goToDefinition to examine key functions Errors and Troubleshooting \u00b6 Common Errors \u00b6 Error: \"Language server not available\" - Cause : No LSP server configured for this file type - Solution : Ensure the appropriate language server is installed, or use grep instead Error: \"Symbol not found\" - Cause : Position doesn't point to a valid symbol, or symbol can't be resolved - Solution : Check line/character position, ensure code is valid, try hover first Error: \"Timeout waiting for language server\" - Cause : Language server is slow or unresponsive - Solution : Wait for indexing to complete, restart session, or use alternative tools Error: \"Invalid position\" - Cause : Line or character number is out of bounds - Solution : Verify the file content and ensure position is within valid range Debugging LSP Issues \u00b6 1. Verify file syntax: - Ensure the file has no syntax errors - Language servers can't analyze invalid code 2. Check position carefully: - Line numbers are typically 0-indexed or 1-indexed (check your tool) - Character position must point to a symbol, not whitespace 3. Confirm language server status: - Check if the language server is running - Look for initialization errors in logs 4. Test with hover first: - hover is the simplest operation - If hover works, other operations should too When LSP Isn't Working \u00b6 If LSP operations consistently fail: Fall back to grep : Use text-based search as a reliable alternative Check configuration : Verify language server settings Use glob : Find files by pattern, then read them Manual inspection : Sometimes reading the code directly is fastest Performance Issues \u00b6 If LSP is too slow: Use grep for initial filtering : Narrow down candidate files first Avoid repeated queries : Cache results when possible Target specific files : Don't query the entire codebase unnecessarily Consider alternatives : For large codebases, specialized tools may be faster Summary \u00b6 The LSP tool provides semantic code intelligence that goes far beyond text search. Use it for: Precise navigation : goToDefinition, findReferences Type understanding : hover for signatures and types Call analysis : incomingCalls and outgoingCalls for dependencies Refactoring support : Impact analysis before changes Remember: LSP is semantic, grep is textual. Choose the right tool for your task, and combine them for maximum efficiency. Next Steps: - Try the exercises above on your own codebase - Compare LSP results with grep to understand the difference - Explore language-specific features for your primary language - Learn your language server's configuration options for better results","title":"LSP (Code Intelligence)"},{"location":"tools/lsp.html#lsp-tool-code-intelligence","text":"","title":"LSP Tool (Code Intelligence)"},{"location":"tools/lsp.html#what-is-lsp","text":"The Language Server Protocol (LSP) is a standardized protocol that provides semantic code understanding capabilities to editors and development tools. Unlike text-based search tools like grep , LSP understands the actual structure and meaning of your code. LSP enables powerful code intelligence features by: Understanding syntax and semantics : LSP knows what identifiers are functions, classes, variables, etc. Tracking relationships : It understands how code elements relate to each other (calls, references, inheritance) Type awareness : It knows the types of variables and function signatures Cross-file analysis : It can trace definitions and references across your entire codebase The LSP tool in Amplifier connects to language servers (like Pyright for Python, TypeScript language server, etc.) to provide semantic code analysis that goes far beyond pattern matching.","title":"What is LSP?"},{"location":"tools/lsp.html#lsp-vs-grep","text":"Understanding when to use LSP versus grep is crucial for efficient code navigation: Task Use LSP Use Grep Find where function is called incomingCalls - finds actual call sites Matches any string occurrence, including comments Find function definition goToDefinition - goes to exact definition Returns multiple matches including false positives Get type information hover - shows type, signature, docs Not possible with text search Find all references findReferences - semantic references only Matches variable names in unrelated contexts Understand code structure outgoingCalls - shows call hierarchy Can't distinguish between different scopes Search across languages Limited language support Works on any text file Search in comments/strings Not designed for this Perfect for text content Quick pattern matching Slower, needs language server Extremely fast for simple patterns Rule of thumb : Use LSP for semantic code queries, grep for text pattern matching.","title":"LSP vs Grep"},{"location":"tools/lsp.html#operations","text":"The LSP tool provides several powerful operations for code intelligence:","title":"Operations"},{"location":"tools/lsp.html#gotodefinition","text":"Jump to where a symbol is defined: lsp(operation=\"goToDefinition\", path=\"src/main.py\", line=10, character=5) Use cases: - Find where a function is implemented - Locate class definitions - Jump to variable declarations - Trace imports to their source Returns: File path, line number, and character position of the definition.","title":"goToDefinition"},{"location":"tools/lsp.html#findreferences","text":"Find all places where a symbol is used: lsp(operation=\"findReferences\", path=\"src/utils.py\", line=15, character=8) Use cases: - Understand how widely a function is used - Assess impact before refactoring - Find all usages of a class or variable - Trace data flow through the codebase Returns: List of all locations where the symbol is referenced, including file, line, and character positions.","title":"findReferences"},{"location":"tools/lsp.html#hover","text":"Get detailed information about a symbol at a specific location: lsp(operation=\"hover\", path=\"src/api.py\", line=20, character=12) Use cases: - Check function signatures and parameter types - View documentation strings - Understand variable types - See return type information Returns: Type information, documentation, and signature details for the symbol.","title":"hover"},{"location":"tools/lsp.html#incomingcalls","text":"Find all functions that call a specific function: lsp(operation=\"incomingCalls\", path=\"src/service.py\", line=50, character=4) Use cases: - Understand the call hierarchy - Find who depends on your function - Trace execution flow backwards - Impact analysis for changes Returns: List of functions that call the target function, with their locations.","title":"incomingCalls"},{"location":"tools/lsp.html#outgoingcalls","text":"Find all functions that a specific function calls: lsp(operation=\"outgoingCalls\", path=\"src/handler.py\", line=30, character=4) Use cases: - Understand what a function depends on - Trace execution flow forwards - Map out component dependencies - Analyze function complexity Returns: List of functions called by the target function, with their locations.","title":"outgoingCalls"},{"location":"tools/lsp.html#python-specific","text":"The LSP tool uses Pyright as the language server for Python code, providing robust type checking and code intelligence.","title":"Python-Specific"},{"location":"tools/lsp.html#pyright-integration","text":"Pyright offers excellent Python support including: Type inference : Understands types even without annotations Stub file support : Uses .pyi stubs for better type information Configuration : Respects pyproject.toml and pyrightconfig.json Virtual environment detection : Automatically finds your venv/virtualenv","title":"Pyright Integration"},{"location":"tools/lsp.html#type-checking-levels","text":"Pyright supports different type checking modes: - Basic : Minimal type checking (default for LSP queries) - Standard : Moderate type checking - Strict : Comprehensive type checking","title":"Type Checking Levels"},{"location":"tools/lsp.html#common-python-lsp-queries","text":"Finding method implementations in class hierarchies: # Use goToDefinition on a method call to find which implementation is actually used result = obj . process () # goToDefinition here shows the actual implementation Tracing decorators: # hover over @decorator to see what it does @cache @validate_input def expensive_function (): pass Understanding complex types: # hover over variables to see inferred types data = process_items ( items ) # hover shows: data: Dict[str, List[Item]]","title":"Common Python LSP Queries"},{"location":"tools/lsp.html#python-specific-tips","text":"Virtual environments : Ensure your language server can find your venv for accurate import resolution Type hints : Add type hints for better LSP results Docstrings : LSP shows docstrings in hover information Imports : Use absolute imports for better cross-file navigation","title":"Python-Specific Tips"},{"location":"tools/lsp.html#best-practices","text":"","title":"Best Practices"},{"location":"tools/lsp.html#when-to-use-lsp","text":"\u2705 DO use LSP for: - Finding function definitions and implementations - Understanding call hierarchies - Checking types and signatures - Refactoring impact analysis - Semantic code navigation - Cross-referencing symbols \u274c DON'T use LSP for: - Searching in comments or documentation - Finding string literals or patterns - Searching across non-code files - Quick text-based searches - Files without language server support","title":"When to Use LSP"},{"location":"tools/lsp.html#efficient-lsp-workflows","text":"1. Start broad, then narrow: 1. Use findReferences to see all usages 2. Use incomingCalls to understand the call chain 3. Use goToDefinition to examine specific implementations 2. Combine with grep: 1. Use grep to find candidate files/patterns 2. Use LSP to understand semantic relationships 3. Use grep again to verify string patterns if needed 3. Leverage hover for quick insights: - Before diving into definitions, use hover to get a quick overview - Check function signatures before tracing calls - Understand types before following references","title":"Efficient LSP Workflows"},{"location":"tools/lsp.html#performance-considerations","text":"Large codebases : LSP may take time to index initially Language server startup : First query may be slower Multiple files : Batch queries when possible Fallback strategy : If LSP is slow, use grep for initial exploration","title":"Performance Considerations"},{"location":"tools/lsp.html#error-handling","text":"LSP operations may fail if: - Language server is not available for the file type - File has syntax errors preventing analysis - Position is invalid or in a comment - Symbol cannot be resolved (e.g., dynamic imports) In these cases, fall back to text-based tools like grep.","title":"Error Handling"},{"location":"tools/lsp.html#try-it-yourself","text":"","title":"Try It Yourself"},{"location":"tools/lsp.html#exercise-1-navigate-a-function-call","text":"Find a function definition in your codebase Use findReferences to see all its usages Use incomingCalls to see what functions call it Use goToDefinition on one of the call sites to jump back","title":"Exercise 1: Navigate a Function Call"},{"location":"tools/lsp.html#exercise-2-understand-type-flow","text":"Pick a variable assignment in your code Use hover to see its type Use findReferences to see where it's used Use hover on each usage to see how the type flows","title":"Exercise 2: Understand Type Flow"},{"location":"tools/lsp.html#exercise-3-analyze-a-refactoring","text":"Choose a function you want to rename Use findReferences to find all usages Use incomingCalls to find all callers Check if any usage is in a critical path Assess the refactoring impact","title":"Exercise 3: Analyze a Refactoring"},{"location":"tools/lsp.html#exercise-4-trace-execution-flow","text":"Start with an entry point function Use outgoingCalls to see what it calls For each called function, repeat step 2 Build a mental map of the execution flow Use goToDefinition to examine key functions","title":"Exercise 4: Trace Execution Flow"},{"location":"tools/lsp.html#errors-and-troubleshooting","text":"","title":"Errors and Troubleshooting"},{"location":"tools/lsp.html#common-errors","text":"Error: \"Language server not available\" - Cause : No LSP server configured for this file type - Solution : Ensure the appropriate language server is installed, or use grep instead Error: \"Symbol not found\" - Cause : Position doesn't point to a valid symbol, or symbol can't be resolved - Solution : Check line/character position, ensure code is valid, try hover first Error: \"Timeout waiting for language server\" - Cause : Language server is slow or unresponsive - Solution : Wait for indexing to complete, restart session, or use alternative tools Error: \"Invalid position\" - Cause : Line or character number is out of bounds - Solution : Verify the file content and ensure position is within valid range","title":"Common Errors"},{"location":"tools/lsp.html#debugging-lsp-issues","text":"1. Verify file syntax: - Ensure the file has no syntax errors - Language servers can't analyze invalid code 2. Check position carefully: - Line numbers are typically 0-indexed or 1-indexed (check your tool) - Character position must point to a symbol, not whitespace 3. Confirm language server status: - Check if the language server is running - Look for initialization errors in logs 4. Test with hover first: - hover is the simplest operation - If hover works, other operations should too","title":"Debugging LSP Issues"},{"location":"tools/lsp.html#when-lsp-isnt-working","text":"If LSP operations consistently fail: Fall back to grep : Use text-based search as a reliable alternative Check configuration : Verify language server settings Use glob : Find files by pattern, then read them Manual inspection : Sometimes reading the code directly is fastest","title":"When LSP Isn't Working"},{"location":"tools/lsp.html#performance-issues","text":"If LSP is too slow: Use grep for initial filtering : Narrow down candidate files first Avoid repeated queries : Cache results when possible Target specific files : Don't query the entire codebase unnecessarily Consider alternatives : For large codebases, specialized tools may be faster","title":"Performance Issues"},{"location":"tools/lsp.html#summary","text":"The LSP tool provides semantic code intelligence that goes far beyond text search. Use it for: Precise navigation : goToDefinition, findReferences Type understanding : hover for signatures and types Call analysis : incomingCalls and outgoingCalls for dependencies Refactoring support : Impact analysis before changes Remember: LSP is semantic, grep is textual. Choose the right tool for your task, and combine them for maximum efficiency. Next Steps: - Try the exercises above on your own codebase - Compare LSP results with grep to understand the difference - Explore language-specific features for your primary language - Learn your language server's configuration options for better results","title":"Summary"},{"location":"tools/recipes-tool.html","text":"Recipes Tool \u00b6 The Recipes Tool enables declarative, multi-step AI agent workflows through YAML specifications. Instead of manually orchestrating complex tasks, you define what needs to happen and let Amplifier handle the execution, state management, and error recovery. What are Recipes? \u00b6 Recipes are declarative YAML workflows that define multi-step agent tasks. They bring structure and repeatability to complex operations that would otherwise require multiple manual prompts. Key characteristics: Declarative : You specify what to do, not how to do it Sequential execution : Steps run in order with state persistence Agent delegation : Each step can use different specialized agents Context accumulation : Results from earlier steps flow to later ones Automatic checkpointing : Sessions can be resumed if interrupted Error handling : Built-in retry logic and failure recovery Think of recipes as \"saved workflows\" - instead of repeating the same multi-step process manually, you encode it once and run it whenever needed. Basic Recipe Structure \u00b6 A minimal recipe looks like this: name : code-review description : Review code changes and suggest improvements steps : - id : analyze agent : foundation:zen-architect prompt : | Analyze the code in {{ file_path }} for: - Code quality issues - Potential bugs - Performance concerns - id : suggest agent : foundation:modular-builder prompt : | Based on this analysis: {{ steps.analyze.result }} Suggest specific improvements with code examples. Executing Recipes \u00b6 Basic Execution \u00b6 Run a recipe from the command line: amplifier run \"execute recipe.yaml\" Or use the recipes tool directly in a session: Execute the code-review recipe at ./recipes/code-review.yaml Passing Context \u00b6 Recipes often need input parameters. Pass context variables when executing: amplifier run \"execute recipe.yaml with file_path=src/auth.py\" Multiple context values: amplifier run \"execute recipe.yaml with file_path=src/auth.py, depth=detailed\" Context variables are available in prompts using {{ variable_name }} syntax. From Within Amplifier \u00b6 You can also execute recipes programmatically: Use the recipes tool to execute ./my-recipe.yaml with context: - project_name: my-app - environment: staging Operations Reference \u00b6 Operation Purpose Required Parameters execute Run a recipe from YAML file recipe_path , optional context resume Continue an interrupted session session_id list List all active recipe sessions None validate Check recipe YAML structure recipe_path approvals List pending approval gates None approve Approve a stage to continue session_id , stage_name deny Deny a stage and stop execution session_id , stage_name Operation Examples \u00b6 Validate before running: Validate the recipe at ./recipes/deploy.yaml List active sessions: List all active recipe sessions Resume an interrupted session: Resume recipe session recipe_20260111_143022_a3f2 Approval Gates \u00b6 For workflows requiring human oversight, recipes support staged execution with approval gates. The recipe pauses at designated points and waits for explicit approval before continuing. Defining Stages \u00b6 name : production-deploy description : Deploy to production with safety gates stages : - name : planning steps : - id : plan agent : foundation:zen-architect prompt : Create deployment plan for {{ service_name }} - name : execution requires_approval : true steps : - id : deploy agent : foundation:modular-builder prompt : | Execute deployment based on: {{ stages.planning.steps.plan.result }} Managing Approvals \u00b6 List pending approvals: Show all pending recipe approvals Approve a stage: Approve the 'execution' stage for session recipe_20260111_143022_a3f2 Deny with reason: Deny the 'execution' stage for session recipe_20260111_143022_a3f2 because the deployment plan needs revision Advanced Features \u00b6 Conditional Execution \u00b6 Steps can include conditions: steps : - id : run-tests agent : foundation:test-coverage prompt : Run the test suite - id : deploy agent : foundation:modular-builder condition : \"{{ steps.run-tests.success }}\" prompt : Deploy the application Error Handling \u00b6 Configure retry behavior and error strategies: steps : - id : api-call agent : foundation:integration-specialist prompt : Call the external API on_error : retry max_retries : 3 retry_delay : 5s Foreach Loops \u00b6 Process multiple items: steps : - id : review-files foreach : \"{{ files }}\" as : file agent : foundation:zen-architect prompt : Review {{ file }} for issues Timeouts \u00b6 Set execution limits: steps : - id : long-task agent : foundation:modular-builder prompt : Process the large dataset timeout : 30m Best Practices \u00b6 1. Keep Steps Focused \u00b6 Each step should have a single, clear purpose: # Good: Focused steps steps : - id : analyze prompt : Analyze the codebase structure - id : identify-issues prompt : Identify potential issues from analysis - id : suggest-fixes prompt : Suggest fixes for identified issues # Avoid: Overloaded steps steps : - id : do-everything prompt : Analyze code, find issues, and fix them all at once 2. Use Descriptive IDs \u00b6 Step IDs should clearly indicate their purpose: # Good - id : validate-input - id : generate-report - id : notify-team # Avoid - id : step1 - id : process - id : final 3. Leverage Context Accumulation \u00b6 Reference previous step results to build context: steps : - id : gather-requirements prompt : List all requirements from {{ spec_file }} - id : design-solution prompt : | Design a solution for these requirements: {{ steps.gather-requirements.result }} 4. Add Approval Gates for Critical Operations \u00b6 Any step that modifies production systems should have an approval gate: stages : - name : prepare steps : [ ... ] - name : deploy-production requires_approval : true steps : - id : deploy prompt : Deploy to production 5. Validate Before Executing \u00b6 Always validate new or modified recipes: amplifier run \"validate my-recipe.yaml\" 6. Use Appropriate Agents \u00b6 Match agents to tasks: foundation:zen-architect - Planning and analysis foundation:modular-builder - Implementation foundation:test-coverage - Testing foundation:security-guardian - Security reviews Try It Yourself \u00b6 Exercise 1: Create a Simple Recipe \u00b6 Create hello-recipe.yaml : name : hello-world description : A simple introduction to recipes steps : - id : greet agent : foundation:explorer prompt : | List the files in the current directory and describe what this project appears to be about. Run it: amplifier run \"execute hello-recipe.yaml\" Exercise 2: Recipe with Context \u00b6 Create file-analyzer.yaml : name : file-analyzer description : Analyze a specific file steps : - id : read-file agent : foundation:file-ops prompt : Read and summarize {{ target_file }} - id : suggest-improvements agent : foundation:zen-architect prompt : | Based on this file content: {{ steps.read-file.result }} Suggest three improvements. Run with context: amplifier run \"execute file-analyzer.yaml with target_file=README.md\" Exercise 3: Multi-Stage with Approval \u00b6 Create safe-refactor.yaml : name : safe-refactor description : Refactor with human approval stages : - name : analysis steps : - id : analyze agent : foundation:zen-architect prompt : Analyze {{ file_path }} and propose refactoring - name : implementation requires_approval : true steps : - id : refactor agent : foundation:modular-builder prompt : | Implement the refactoring plan: {{ stages.analysis.steps.analyze.result }} This recipe will pause after analysis, letting you review the plan before any changes are made. Summary \u00b6 The Recipes Tool transforms complex, multi-step workflows into repeatable, reliable automation: Define once, run many times - Encode workflows as YAML Built-in safety - Approval gates for critical operations Resilient execution - Automatic checkpointing and resume Context-aware - Steps build on previous results Start with simple recipes and gradually add complexity as you become comfortable with the patterns.","title":"Recipes Tool"},{"location":"tools/recipes-tool.html#recipes-tool","text":"The Recipes Tool enables declarative, multi-step AI agent workflows through YAML specifications. Instead of manually orchestrating complex tasks, you define what needs to happen and let Amplifier handle the execution, state management, and error recovery.","title":"Recipes Tool"},{"location":"tools/recipes-tool.html#what-are-recipes","text":"Recipes are declarative YAML workflows that define multi-step agent tasks. They bring structure and repeatability to complex operations that would otherwise require multiple manual prompts. Key characteristics: Declarative : You specify what to do, not how to do it Sequential execution : Steps run in order with state persistence Agent delegation : Each step can use different specialized agents Context accumulation : Results from earlier steps flow to later ones Automatic checkpointing : Sessions can be resumed if interrupted Error handling : Built-in retry logic and failure recovery Think of recipes as \"saved workflows\" - instead of repeating the same multi-step process manually, you encode it once and run it whenever needed.","title":"What are Recipes?"},{"location":"tools/recipes-tool.html#basic-recipe-structure","text":"A minimal recipe looks like this: name : code-review description : Review code changes and suggest improvements steps : - id : analyze agent : foundation:zen-architect prompt : | Analyze the code in {{ file_path }} for: - Code quality issues - Potential bugs - Performance concerns - id : suggest agent : foundation:modular-builder prompt : | Based on this analysis: {{ steps.analyze.result }} Suggest specific improvements with code examples.","title":"Basic Recipe Structure"},{"location":"tools/recipes-tool.html#executing-recipes","text":"","title":"Executing Recipes"},{"location":"tools/recipes-tool.html#basic-execution","text":"Run a recipe from the command line: amplifier run \"execute recipe.yaml\" Or use the recipes tool directly in a session: Execute the code-review recipe at ./recipes/code-review.yaml","title":"Basic Execution"},{"location":"tools/recipes-tool.html#passing-context","text":"Recipes often need input parameters. Pass context variables when executing: amplifier run \"execute recipe.yaml with file_path=src/auth.py\" Multiple context values: amplifier run \"execute recipe.yaml with file_path=src/auth.py, depth=detailed\" Context variables are available in prompts using {{ variable_name }} syntax.","title":"Passing Context"},{"location":"tools/recipes-tool.html#from-within-amplifier","text":"You can also execute recipes programmatically: Use the recipes tool to execute ./my-recipe.yaml with context: - project_name: my-app - environment: staging","title":"From Within Amplifier"},{"location":"tools/recipes-tool.html#operations-reference","text":"Operation Purpose Required Parameters execute Run a recipe from YAML file recipe_path , optional context resume Continue an interrupted session session_id list List all active recipe sessions None validate Check recipe YAML structure recipe_path approvals List pending approval gates None approve Approve a stage to continue session_id , stage_name deny Deny a stage and stop execution session_id , stage_name","title":"Operations Reference"},{"location":"tools/recipes-tool.html#operation-examples","text":"Validate before running: Validate the recipe at ./recipes/deploy.yaml List active sessions: List all active recipe sessions Resume an interrupted session: Resume recipe session recipe_20260111_143022_a3f2","title":"Operation Examples"},{"location":"tools/recipes-tool.html#approval-gates","text":"For workflows requiring human oversight, recipes support staged execution with approval gates. The recipe pauses at designated points and waits for explicit approval before continuing.","title":"Approval Gates"},{"location":"tools/recipes-tool.html#defining-stages","text":"name : production-deploy description : Deploy to production with safety gates stages : - name : planning steps : - id : plan agent : foundation:zen-architect prompt : Create deployment plan for {{ service_name }} - name : execution requires_approval : true steps : - id : deploy agent : foundation:modular-builder prompt : | Execute deployment based on: {{ stages.planning.steps.plan.result }}","title":"Defining Stages"},{"location":"tools/recipes-tool.html#managing-approvals","text":"List pending approvals: Show all pending recipe approvals Approve a stage: Approve the 'execution' stage for session recipe_20260111_143022_a3f2 Deny with reason: Deny the 'execution' stage for session recipe_20260111_143022_a3f2 because the deployment plan needs revision","title":"Managing Approvals"},{"location":"tools/recipes-tool.html#advanced-features","text":"","title":"Advanced Features"},{"location":"tools/recipes-tool.html#conditional-execution","text":"Steps can include conditions: steps : - id : run-tests agent : foundation:test-coverage prompt : Run the test suite - id : deploy agent : foundation:modular-builder condition : \"{{ steps.run-tests.success }}\" prompt : Deploy the application","title":"Conditional Execution"},{"location":"tools/recipes-tool.html#error-handling","text":"Configure retry behavior and error strategies: steps : - id : api-call agent : foundation:integration-specialist prompt : Call the external API on_error : retry max_retries : 3 retry_delay : 5s","title":"Error Handling"},{"location":"tools/recipes-tool.html#foreach-loops","text":"Process multiple items: steps : - id : review-files foreach : \"{{ files }}\" as : file agent : foundation:zen-architect prompt : Review {{ file }} for issues","title":"Foreach Loops"},{"location":"tools/recipes-tool.html#timeouts","text":"Set execution limits: steps : - id : long-task agent : foundation:modular-builder prompt : Process the large dataset timeout : 30m","title":"Timeouts"},{"location":"tools/recipes-tool.html#best-practices","text":"","title":"Best Practices"},{"location":"tools/recipes-tool.html#1-keep-steps-focused","text":"Each step should have a single, clear purpose: # Good: Focused steps steps : - id : analyze prompt : Analyze the codebase structure - id : identify-issues prompt : Identify potential issues from analysis - id : suggest-fixes prompt : Suggest fixes for identified issues # Avoid: Overloaded steps steps : - id : do-everything prompt : Analyze code, find issues, and fix them all at once","title":"1. Keep Steps Focused"},{"location":"tools/recipes-tool.html#2-use-descriptive-ids","text":"Step IDs should clearly indicate their purpose: # Good - id : validate-input - id : generate-report - id : notify-team # Avoid - id : step1 - id : process - id : final","title":"2. Use Descriptive IDs"},{"location":"tools/recipes-tool.html#3-leverage-context-accumulation","text":"Reference previous step results to build context: steps : - id : gather-requirements prompt : List all requirements from {{ spec_file }} - id : design-solution prompt : | Design a solution for these requirements: {{ steps.gather-requirements.result }}","title":"3. Leverage Context Accumulation"},{"location":"tools/recipes-tool.html#4-add-approval-gates-for-critical-operations","text":"Any step that modifies production systems should have an approval gate: stages : - name : prepare steps : [ ... ] - name : deploy-production requires_approval : true steps : - id : deploy prompt : Deploy to production","title":"4. Add Approval Gates for Critical Operations"},{"location":"tools/recipes-tool.html#5-validate-before-executing","text":"Always validate new or modified recipes: amplifier run \"validate my-recipe.yaml\"","title":"5. Validate Before Executing"},{"location":"tools/recipes-tool.html#6-use-appropriate-agents","text":"Match agents to tasks: foundation:zen-architect - Planning and analysis foundation:modular-builder - Implementation foundation:test-coverage - Testing foundation:security-guardian - Security reviews","title":"6. Use Appropriate Agents"},{"location":"tools/recipes-tool.html#try-it-yourself","text":"","title":"Try It Yourself"},{"location":"tools/recipes-tool.html#exercise-1-create-a-simple-recipe","text":"Create hello-recipe.yaml : name : hello-world description : A simple introduction to recipes steps : - id : greet agent : foundation:explorer prompt : | List the files in the current directory and describe what this project appears to be about. Run it: amplifier run \"execute hello-recipe.yaml\"","title":"Exercise 1: Create a Simple Recipe"},{"location":"tools/recipes-tool.html#exercise-2-recipe-with-context","text":"Create file-analyzer.yaml : name : file-analyzer description : Analyze a specific file steps : - id : read-file agent : foundation:file-ops prompt : Read and summarize {{ target_file }} - id : suggest-improvements agent : foundation:zen-architect prompt : | Based on this file content: {{ steps.read-file.result }} Suggest three improvements. Run with context: amplifier run \"execute file-analyzer.yaml with target_file=README.md\"","title":"Exercise 2: Recipe with Context"},{"location":"tools/recipes-tool.html#exercise-3-multi-stage-with-approval","text":"Create safe-refactor.yaml : name : safe-refactor description : Refactor with human approval stages : - name : analysis steps : - id : analyze agent : foundation:zen-architect prompt : Analyze {{ file_path }} and propose refactoring - name : implementation requires_approval : true steps : - id : refactor agent : foundation:modular-builder prompt : | Implement the refactoring plan: {{ stages.analysis.steps.analyze.result }} This recipe will pause after analysis, letting you review the plan before any changes are made.","title":"Exercise 3: Multi-Stage with Approval"},{"location":"tools/recipes-tool.html#summary","text":"The Recipes Tool transforms complex, multi-step workflows into repeatable, reliable automation: Define once, run many times - Encode workflows as YAML Built-in safety - Approval gates for critical operations Resilient execution - Automatic checkpointing and resume Context-aware - Steps build on previous results Start with simple recipes and gradually add complexity as you become comfortable with the patterns.","title":"Summary"},{"location":"tools/search.html","text":"Search Tools (grep & glob) \u00b6 Master the art of finding files and searching content across your codebase. The grep and glob tools are your primary search capabilities for navigating projects of any size. When to Use Each \u00b6 Task Tool Why Find files by name/extension glob Fast pattern matching on file paths Search inside file contents grep Regex-based content search Find all Python files glob Use **/*.py pattern Find TODO comments grep Search for TODO: in code List all test files glob Match **/test_*.py or *.test.js Find function definitions grep Regex like function\\s+\\w+ Locate config files glob Match **/*.{json,yaml,toml} Find import statements grep Search for import.*Module Quick Decision Guide: - Know the filename? \u2192 Use glob - Know what's inside the file? \u2192 Use grep - Need both? \u2192 Combine them! Glob Patterns \u00b6 Glob finds files by matching path patterns. Think of it as a smart file finder. Basic Patterns \u00b6 # Find all Python files in current directory *.py # Find all Python files recursively **/*.py # Find all JavaScript and TypeScript files **/*. { js,ts } # Find all test files **/test_*.py **/*_test.go **/*.test.js Pattern Syntax \u00b6 Pattern Matches Example * Any characters (except / ) *.md \u2192 README.md ** Any directories recursively **/src/*.js ? Single character test?.py \u2192 test1.py [abc] Any character in brackets file[123].txt {a,b} Either a or b *.{js,ts} Common Use Cases \u00b6 Find all source files: # Python project **/*.py # JavaScript/TypeScript project **/*. { js,ts,jsx,tsx } # Rust project **/*.rs Find configuration files: **/*. { json,yaml,yml,toml,ini } Find documentation: **/*.md **/docs/**/*.md Find specific directories: # Find all __init__.py files (Python packages) **/__init__.py # Find all package.json files (Node modules) **/package.json Glob Parameters \u00b6 pattern : \"**/*.py\" # Required: glob pattern path : \"./src\" # Optional: base directory (default: current) type : \"file\" # Optional: file, dir, or any (default: file) include_ignored : false # Optional: search in node_modules, .venv, etc. exclude : [ \"**/test_*.py\" ] # Optional: patterns to exclude Glob Output \u00b6 Results are sorted by modification time (newest first) and limited to 500 files: Files matched (250 of 500+ total): src/main.py src/utils.py tests/test_main.py ... Note: Results limited to 500 files. 234 additional files not shown. Grep Patterns \u00b6 Grep searches inside files using regular expressions. It's your content detective. Basic Patterns \u00b6 # Find TODO comments TODO # Find function definitions (JavaScript) function \\s + \\w + # Find class definitions (Python) class \\s + \\w + # Find import statements import.*requests # Find error handling except \\s + \\w +Error # Case insensitive search -i: true pattern: \"error\" Regex Syntax \u00b6 Grep uses ripgrep regex (Rust flavor): Pattern Matches Example . Any character log. \u2192 log1 , logA \\d Any digit user\\d+ \u2192 user123 \\w Word character \\w+ \u2192 hello \\s Whitespace if\\s+ \u2192 if * 0 or more error.* \u2192 error: failed + 1 or more \\d+ \u2192 123 ? 0 or 1 colou?r \u2192 color , colour ^ Start of line ^import \u2192 import at start $ End of line ;$ \u2192 semicolon at end [abc] Character class [Ee]rror \u2192 Error, error (a\\|b) Alternation (get\\|set) \u2192 get or set Important: Ripgrep requires escaping braces: interface\\{ to find interface{ Output Modes \u00b6 Grep has three output modes for different needs: 1. files_with_matches (Default) \u00b6 Lists files containing matches (fastest): pattern : \"TODO\" output_mode : \"files_with_matches\" Output: src/main.py src/utils.py tests/test_main.py Use when: You just need to know which files contain something. 2. content \u00b6 Shows matching lines with content: pattern : \"def \\ s+ \\ w+\" output_mode : \"content\" Output: src/main.py: 15: def process_data(input): 42: def validate_input(data): src/utils.py: 8: def helper_function(): Use when: You need to see the actual matches. 3. count \u00b6 Shows count of matches per file: pattern : \"import\" output_mode : \"count\" Output: src/main.py: 15 matches src/utils.py: 8 matches tests/test_main.py: 12 matches Use when: You need statistics or metrics. Content Mode Features \u00b6 When using output_mode: \"content\" , you get extra options: Line numbers (default: true): -n : true # Show line numbers Context lines: -A : 2 # Show 2 lines AFTER match -B : 2 # Show 2 lines BEFORE match -C : 2 # Show 2 lines before AND after (context) Example with context: pattern : \"raise ValueError\" output_mode : \"content\" -C : 2 Output: src/main.py: 28: if not valid: 29: logger.error(\"Invalid input\") 30: raise ValueError(\"Input validation failed\") 31: return None 32: process(data) File Filtering \u00b6 By file type: pattern : \"TODO\" type : \"py\" # Search only Python files Supported types: py , js , ts , go , rust , java , c , cpp , rb , sh , md , json , yaml , html , css , xml , php , sql , swift , lua , toml , txt By glob pattern: pattern : \"TODO\" glob : \"**/*.{js,ts}\" # Search only JS/TS files By path: pattern : \"test\" path : \"./tests\" # Search only in tests directory Include ignored directories: pattern : \"config\" include_ignored : true # Search in node_modules, .venv, etc. By default, grep excludes: node_modules , .venv , .git , __pycache__ , build , dist , .next , target Multiline Patterns \u00b6 Search across multiple lines: pattern : \"function.*\\\\{.*\\\\}\" multiline : true This allows . to match newlines and patterns to span multiple lines. Pagination \u00b6 Handle large result sets: pattern : \"import\" head_limit : 100 # Show first 100 results offset : 0 # Start from beginning # For next page: head_limit : 100 offset : 100 # Skip first 100 The response includes total_matches so you know how many exist. Combining Tools \u00b6 The real power comes from using both tools together! Pattern 1: Narrow Down Files First \u00b6 Use glob to find candidate files Use grep to search within those files # Step 1: Find all TypeScript files glob : \"**/*.ts\" # Step 2: Search for React hooks in those files pattern : \"use[A-Z]\\\\w+\" glob : \"**/*.ts\" Pattern 2: Search Then Explore \u00b6 Use grep to find files with matches Read those files to see context # Step 1: Find files with TODO comments pattern : \"TODO\" output_mode : \"files_with_matches\" # Step 2: Read specific files # (Use read_file tool on results) Pattern 3: Iterative Refinement \u00b6 Start broad, narrow down: # Round 1: Find all error handling pattern : \"except\" type : \"py\" # Round 2: Find specific exception types pattern : \"except\\\\s+(ValueError|TypeError)\" output_mode : \"content\" # Round 3: Add context to see full try/except blocks pattern : \"except\\\\s+(ValueError|TypeError)\" output_mode : \"content\" -C : 5 Best Practices \u00b6 Performance Tips \u00b6 Use file type filters : type: \"py\" is faster than searching all files Specify paths : Searching ./src is faster than entire project Start with files_with_matches : Cheapest output mode Use head_limit : Limit results to prevent overwhelming context Search Strategy \u00b6 For unknown codebases: 1. glob \u2192 Find what files exist 2. grep (files_with_matches) \u2192 Find relevant files 3. grep (content) \u2192 See actual code 4. read_file \u2192 Read full context For specific searches: 1. Combine grep with type/glob filters immediately 2. Use content mode with context (-C) 3. Read promising files Common Patterns \u00b6 Find API endpoints: pattern : \"@(app|router)\\\\.(get|post|put|delete)\" type : \"py\" output_mode : \"content\" Find environment variables: pattern : \"os\\\\.environ|process\\\\.env\" output_mode : \"content\" Find security issues: pattern : \"(eval|exec|system|shell_exec)\\\\(\" output_mode : \"content\" -C : 3 Find deprecated code: pattern : \"@deprecated|DEPRECATED|FIXME\" output_mode : \"content\" Try It Yourself \u00b6 Exercise 1: Find All Tests \u00b6 Find all test files in your project: # Glob approach: pattern : \"**/test_*.py\" Exercise 2: Find Unused Imports \u00b6 Search for imports that might be unused: pattern : \"^import\\\\s+\\\\w+\" type : \"py\" output_mode : \"content\" Exercise 3: Configuration Audit \u00b6 Find all configuration values: # Find config files pattern : \"**/*.{json,yaml,yml,toml}\" # Then search for secrets/credentials pattern : \"(password|secret|api_key|token)\" -i : true output_mode : \"content\" Exercise 4: Code Complexity \u00b6 Find long functions (might need refactoring): # Find function definitions pattern : \"^(def|function)\\\\s+\\\\w+\" output_mode : \"content\" -A : 50 # Show next 50 lines to see function size Common Errors \u00b6 Glob Errors \u00b6 \"No files matched pattern\" - Check your pattern syntax - Try simpler patterns first: *.py before **/*.py - Verify you're in the right directory - Use include_ignored: true if searching excluded dirs \"Too many results (>500)\" - Be more specific with your pattern - Search in a subdirectory: path: \"./src\" - Use exclude patterns: exclude: [\"**/node_modules/**\"] Grep Errors \u00b6 \"Pattern not found\" - Verify regex syntax (ripgrep flavor) - Try case insensitive: -i: true - Check file type filter: type: \"py\" - Use simpler pattern first, then refine \"Results truncated\" - This is normal! Results are limited for performance - Use head_limit and offset for pagination - Consider narrowing search with path or type \"Regex syntax error\" - Escape special characters: \\{ , \\( , \\. - Use raw strings in your mind: \\\\ for backslash - Test simpler patterns first \"Multiline not working\" - Set multiline: true explicitly - Remember . now matches newlines - Patterns can span lines: function.*\\\\{.*\\\\} Pro Tips \u00b6 Test patterns incrementally : Start simple, add complexity Use files_with_matches first : See what files match before getting content Combine with read_file : Grep finds it, read_file shows full context Watch output limits : Default limits prevent context overflow Case sensitivity matters : Use -i: true when unsure Escape ripgrep regex : \\{ \\} \\( \\) need escaping Next Steps: - Practice with your own codebase - Combine with other tools like read_file and bash - Learn advanced regex patterns - Build search workflows for common tasks Related Tools: - read_file - Read full file content after finding matches - bash - Use shell commands like find or ag if needed - task:explorer - For complex multi-step searches","title":"Search (grep & glob)"},{"location":"tools/search.html#search-tools-grep-glob","text":"Master the art of finding files and searching content across your codebase. The grep and glob tools are your primary search capabilities for navigating projects of any size.","title":"Search Tools (grep &amp; glob)"},{"location":"tools/search.html#when-to-use-each","text":"Task Tool Why Find files by name/extension glob Fast pattern matching on file paths Search inside file contents grep Regex-based content search Find all Python files glob Use **/*.py pattern Find TODO comments grep Search for TODO: in code List all test files glob Match **/test_*.py or *.test.js Find function definitions grep Regex like function\\s+\\w+ Locate config files glob Match **/*.{json,yaml,toml} Find import statements grep Search for import.*Module Quick Decision Guide: - Know the filename? \u2192 Use glob - Know what's inside the file? \u2192 Use grep - Need both? \u2192 Combine them!","title":"When to Use Each"},{"location":"tools/search.html#glob-patterns","text":"Glob finds files by matching path patterns. Think of it as a smart file finder.","title":"Glob Patterns"},{"location":"tools/search.html#basic-patterns","text":"# Find all Python files in current directory *.py # Find all Python files recursively **/*.py # Find all JavaScript and TypeScript files **/*. { js,ts } # Find all test files **/test_*.py **/*_test.go **/*.test.js","title":"Basic Patterns"},{"location":"tools/search.html#pattern-syntax","text":"Pattern Matches Example * Any characters (except / ) *.md \u2192 README.md ** Any directories recursively **/src/*.js ? Single character test?.py \u2192 test1.py [abc] Any character in brackets file[123].txt {a,b} Either a or b *.{js,ts}","title":"Pattern Syntax"},{"location":"tools/search.html#common-use-cases","text":"Find all source files: # Python project **/*.py # JavaScript/TypeScript project **/*. { js,ts,jsx,tsx } # Rust project **/*.rs Find configuration files: **/*. { json,yaml,yml,toml,ini } Find documentation: **/*.md **/docs/**/*.md Find specific directories: # Find all __init__.py files (Python packages) **/__init__.py # Find all package.json files (Node modules) **/package.json","title":"Common Use Cases"},{"location":"tools/search.html#glob-parameters","text":"pattern : \"**/*.py\" # Required: glob pattern path : \"./src\" # Optional: base directory (default: current) type : \"file\" # Optional: file, dir, or any (default: file) include_ignored : false # Optional: search in node_modules, .venv, etc. exclude : [ \"**/test_*.py\" ] # Optional: patterns to exclude","title":"Glob Parameters"},{"location":"tools/search.html#glob-output","text":"Results are sorted by modification time (newest first) and limited to 500 files: Files matched (250 of 500+ total): src/main.py src/utils.py tests/test_main.py ... Note: Results limited to 500 files. 234 additional files not shown.","title":"Glob Output"},{"location":"tools/search.html#grep-patterns","text":"Grep searches inside files using regular expressions. It's your content detective.","title":"Grep Patterns"},{"location":"tools/search.html#basic-patterns_1","text":"# Find TODO comments TODO # Find function definitions (JavaScript) function \\s + \\w + # Find class definitions (Python) class \\s + \\w + # Find import statements import.*requests # Find error handling except \\s + \\w +Error # Case insensitive search -i: true pattern: \"error\"","title":"Basic Patterns"},{"location":"tools/search.html#regex-syntax","text":"Grep uses ripgrep regex (Rust flavor): Pattern Matches Example . Any character log. \u2192 log1 , logA \\d Any digit user\\d+ \u2192 user123 \\w Word character \\w+ \u2192 hello \\s Whitespace if\\s+ \u2192 if * 0 or more error.* \u2192 error: failed + 1 or more \\d+ \u2192 123 ? 0 or 1 colou?r \u2192 color , colour ^ Start of line ^import \u2192 import at start $ End of line ;$ \u2192 semicolon at end [abc] Character class [Ee]rror \u2192 Error, error (a\\|b) Alternation (get\\|set) \u2192 get or set Important: Ripgrep requires escaping braces: interface\\{ to find interface{","title":"Regex Syntax"},{"location":"tools/search.html#output-modes","text":"Grep has three output modes for different needs:","title":"Output Modes"},{"location":"tools/search.html#1-files_with_matches-default","text":"Lists files containing matches (fastest): pattern : \"TODO\" output_mode : \"files_with_matches\" Output: src/main.py src/utils.py tests/test_main.py Use when: You just need to know which files contain something.","title":"1. files_with_matches (Default)"},{"location":"tools/search.html#2-content","text":"Shows matching lines with content: pattern : \"def \\ s+ \\ w+\" output_mode : \"content\" Output: src/main.py: 15: def process_data(input): 42: def validate_input(data): src/utils.py: 8: def helper_function(): Use when: You need to see the actual matches.","title":"2. content"},{"location":"tools/search.html#3-count","text":"Shows count of matches per file: pattern : \"import\" output_mode : \"count\" Output: src/main.py: 15 matches src/utils.py: 8 matches tests/test_main.py: 12 matches Use when: You need statistics or metrics.","title":"3. count"},{"location":"tools/search.html#content-mode-features","text":"When using output_mode: \"content\" , you get extra options: Line numbers (default: true): -n : true # Show line numbers Context lines: -A : 2 # Show 2 lines AFTER match -B : 2 # Show 2 lines BEFORE match -C : 2 # Show 2 lines before AND after (context) Example with context: pattern : \"raise ValueError\" output_mode : \"content\" -C : 2 Output: src/main.py: 28: if not valid: 29: logger.error(\"Invalid input\") 30: raise ValueError(\"Input validation failed\") 31: return None 32: process(data)","title":"Content Mode Features"},{"location":"tools/search.html#file-filtering","text":"By file type: pattern : \"TODO\" type : \"py\" # Search only Python files Supported types: py , js , ts , go , rust , java , c , cpp , rb , sh , md , json , yaml , html , css , xml , php , sql , swift , lua , toml , txt By glob pattern: pattern : \"TODO\" glob : \"**/*.{js,ts}\" # Search only JS/TS files By path: pattern : \"test\" path : \"./tests\" # Search only in tests directory Include ignored directories: pattern : \"config\" include_ignored : true # Search in node_modules, .venv, etc. By default, grep excludes: node_modules , .venv , .git , __pycache__ , build , dist , .next , target","title":"File Filtering"},{"location":"tools/search.html#multiline-patterns","text":"Search across multiple lines: pattern : \"function.*\\\\{.*\\\\}\" multiline : true This allows . to match newlines and patterns to span multiple lines.","title":"Multiline Patterns"},{"location":"tools/search.html#pagination","text":"Handle large result sets: pattern : \"import\" head_limit : 100 # Show first 100 results offset : 0 # Start from beginning # For next page: head_limit : 100 offset : 100 # Skip first 100 The response includes total_matches so you know how many exist.","title":"Pagination"},{"location":"tools/search.html#combining-tools","text":"The real power comes from using both tools together!","title":"Combining Tools"},{"location":"tools/search.html#pattern-1-narrow-down-files-first","text":"Use glob to find candidate files Use grep to search within those files # Step 1: Find all TypeScript files glob : \"**/*.ts\" # Step 2: Search for React hooks in those files pattern : \"use[A-Z]\\\\w+\" glob : \"**/*.ts\"","title":"Pattern 1: Narrow Down Files First"},{"location":"tools/search.html#pattern-2-search-then-explore","text":"Use grep to find files with matches Read those files to see context # Step 1: Find files with TODO comments pattern : \"TODO\" output_mode : \"files_with_matches\" # Step 2: Read specific files # (Use read_file tool on results)","title":"Pattern 2: Search Then Explore"},{"location":"tools/search.html#pattern-3-iterative-refinement","text":"Start broad, narrow down: # Round 1: Find all error handling pattern : \"except\" type : \"py\" # Round 2: Find specific exception types pattern : \"except\\\\s+(ValueError|TypeError)\" output_mode : \"content\" # Round 3: Add context to see full try/except blocks pattern : \"except\\\\s+(ValueError|TypeError)\" output_mode : \"content\" -C : 5","title":"Pattern 3: Iterative Refinement"},{"location":"tools/search.html#best-practices","text":"","title":"Best Practices"},{"location":"tools/search.html#performance-tips","text":"Use file type filters : type: \"py\" is faster than searching all files Specify paths : Searching ./src is faster than entire project Start with files_with_matches : Cheapest output mode Use head_limit : Limit results to prevent overwhelming context","title":"Performance Tips"},{"location":"tools/search.html#search-strategy","text":"For unknown codebases: 1. glob \u2192 Find what files exist 2. grep (files_with_matches) \u2192 Find relevant files 3. grep (content) \u2192 See actual code 4. read_file \u2192 Read full context For specific searches: 1. Combine grep with type/glob filters immediately 2. Use content mode with context (-C) 3. Read promising files","title":"Search Strategy"},{"location":"tools/search.html#common-patterns","text":"Find API endpoints: pattern : \"@(app|router)\\\\.(get|post|put|delete)\" type : \"py\" output_mode : \"content\" Find environment variables: pattern : \"os\\\\.environ|process\\\\.env\" output_mode : \"content\" Find security issues: pattern : \"(eval|exec|system|shell_exec)\\\\(\" output_mode : \"content\" -C : 3 Find deprecated code: pattern : \"@deprecated|DEPRECATED|FIXME\" output_mode : \"content\"","title":"Common Patterns"},{"location":"tools/search.html#try-it-yourself","text":"","title":"Try It Yourself"},{"location":"tools/search.html#exercise-1-find-all-tests","text":"Find all test files in your project: # Glob approach: pattern : \"**/test_*.py\"","title":"Exercise 1: Find All Tests"},{"location":"tools/search.html#exercise-2-find-unused-imports","text":"Search for imports that might be unused: pattern : \"^import\\\\s+\\\\w+\" type : \"py\" output_mode : \"content\"","title":"Exercise 2: Find Unused Imports"},{"location":"tools/search.html#exercise-3-configuration-audit","text":"Find all configuration values: # Find config files pattern : \"**/*.{json,yaml,yml,toml}\" # Then search for secrets/credentials pattern : \"(password|secret|api_key|token)\" -i : true output_mode : \"content\"","title":"Exercise 3: Configuration Audit"},{"location":"tools/search.html#exercise-4-code-complexity","text":"Find long functions (might need refactoring): # Find function definitions pattern : \"^(def|function)\\\\s+\\\\w+\" output_mode : \"content\" -A : 50 # Show next 50 lines to see function size","title":"Exercise 4: Code Complexity"},{"location":"tools/search.html#common-errors","text":"","title":"Common Errors"},{"location":"tools/search.html#glob-errors","text":"\"No files matched pattern\" - Check your pattern syntax - Try simpler patterns first: *.py before **/*.py - Verify you're in the right directory - Use include_ignored: true if searching excluded dirs \"Too many results (>500)\" - Be more specific with your pattern - Search in a subdirectory: path: \"./src\" - Use exclude patterns: exclude: [\"**/node_modules/**\"]","title":"Glob Errors"},{"location":"tools/search.html#grep-errors","text":"\"Pattern not found\" - Verify regex syntax (ripgrep flavor) - Try case insensitive: -i: true - Check file type filter: type: \"py\" - Use simpler pattern first, then refine \"Results truncated\" - This is normal! Results are limited for performance - Use head_limit and offset for pagination - Consider narrowing search with path or type \"Regex syntax error\" - Escape special characters: \\{ , \\( , \\. - Use raw strings in your mind: \\\\ for backslash - Test simpler patterns first \"Multiline not working\" - Set multiline: true explicitly - Remember . now matches newlines - Patterns can span lines: function.*\\\\{.*\\\\}","title":"Grep Errors"},{"location":"tools/search.html#pro-tips","text":"Test patterns incrementally : Start simple, add complexity Use files_with_matches first : See what files match before getting content Combine with read_file : Grep finds it, read_file shows full context Watch output limits : Default limits prevent context overflow Case sensitivity matters : Use -i: true when unsure Escape ripgrep regex : \\{ \\} \\( \\) need escaping Next Steps: - Practice with your own codebase - Combine with other tools like read_file and bash - Learn advanced regex patterns - Build search workflows for common tasks Related Tools: - read_file - Read full file content after finding matches - bash - Use shell commands like find or ag if needed - task:explorer - For complex multi-step searches","title":"Pro Tips"},{"location":"tools/task.html","text":"Task Tool (Sub-Agents) \u00b6 The Task Tool is Amplifier's delegation system that allows the main agent to spawn specialized sub-agents to handle complex, multi-step tasks autonomously. Each sub-agent operates independently with its own set of tools and expertise. What is Delegation? \u00b6 Delegation in Amplifier means launching a specialized agent to handle a specific task. Instead of doing everything itself, the main agent can: Spawn a sub-agent with a specific instruction Wait for the sub-agent to complete its work autonomously Receive a final report with the results Continue with the next steps based on those results Think of it like assigning work to a specialist colleague who will handle the task independently and report back when done. Key Characteristics: - Sub-agents are stateless - they run once and return results - Sub-agents work autonomously - no back-and-forth during execution - Sub-agents have specialized tools - each type has different capabilities - Multiple sub-agents can run in parallel for faster completion When to Delegate \u00b6 Delegation is powerful but not always necessary. Use the task tool when: \u2705 ALWAYS Delegate \u00b6 Git Operations - ALWAYS use foundation:git-ops : - Creating branches - Committing changes - Creating pull requests - Checking git status/history - Merging branches - Resolving conflicts Large Codebase Exploration - Use foundation:explorer : - Understanding unfamiliar codebases - Finding architectural patterns - Mapping dependencies - Locating specific functionality across many files Complex Debugging - Use foundation:bug-hunter : - Investigating error messages - Tracing execution flows - Finding root causes of failures - Analyzing test failures \u2705 Often Beneficial \u00b6 Design & Review - Use foundation:zen-architect : - Reviewing code architecture - Suggesting improvements - Design pattern recommendations - Code quality assessments Modular Implementation - Use foundation:modular-builder : - Building new features from scratch - Creating multiple related files - Implementing complex components Testing - Use foundation:test-coverage : - Writing comprehensive test suites - Achieving high coverage - Test strategy planning Security - Use foundation:security-guardian : - Security vulnerability scans - Dependency audits - Best practice checks \u274c DON'T Delegate \u00b6 Simple File Operations: - Reading 1-2 specific files \u2192 Use read_file directly - Writing a single file \u2192 Use write_file directly - Quick edits \u2192 Use edit_file directly Quick Searches: - Finding a specific class \u2192 Use grep directly - Searching known file paths \u2192 Use glob directly Simple Commands: - Running tests \u2192 Use bash directly - Installing packages \u2192 Use bash directly Available Agents \u00b6 Agent Purpose When to Use foundation:explorer Codebase reconnaissance Understanding unfamiliar code, finding patterns, mapping architecture foundation:git-ops Git operations ALWAYS for commits, branches, PRs, merges, git history foundation:bug-hunter Debugging & investigation Tracing errors, finding bugs, analyzing failures foundation:zen-architect Design & code review Architecture review, design patterns, quality assessment foundation:modular-builder Feature implementation Building new features, creating multiple files foundation:test-coverage Testing Writing tests, improving coverage, test strategy foundation:security-guardian Security checks Vulnerability scans, security audits foundation:file-ops Complex file operations Batch file operations, directory restructuring foundation:web-research External research Fetching docs, researching libraries, finding examples foundation:integration-specialist Integration tasks Connecting systems, API integration foundation:ecosystem-expert Ecosystem knowledge Tool recommendations, best practices Parallel Execution \u00b6 One of the most powerful features is running multiple agents simultaneously. This dramatically speeds up complex workflows. How to Run in Parallel \u00b6 Send a single message with multiple task tool calls : User: \"Analyze the auth module - check architecture, tests, and security\" Agent: I'll launch three agents in parallel to analyze different aspects: - foundation:explorer for architecture - foundation:test-coverage for tests - foundation:security-guardian for security [Makes 3 task tool calls in one message] Benefits \u00b6 Speed : 3 tasks that take 2 minutes each = 2 minutes total (not 6) Efficiency : Better resource utilization Independence : Each agent works autonomously without blocking others Example Scenarios \u00b6 Feature Development: 1. foundation:explorer - Understand existing code 2. foundation:modular-builder - Implement feature 3. foundation:test-coverage - Write tests All three can run in parallel! Code Quality Check: 1. foundation:zen-architect - Review architecture 2. foundation:security-guardian - Security audit 3. foundation:bug-hunter - Find potential bugs Launch all simultaneously for fast assessment! Session Resumption \u00b6 Sub-agents typically run once and complete. However, if you need to continue working with a previous agent session: Using session_id \u00b6 When an agent finishes, it returns a session_id : { \"session_id\" : \"recipe_20251118_143022_a3f2\" , \"result\" : \"Analysis complete...\" } To resume this session: <invoke name= \"task\" > <parameter name= \"agent\" > foundation:explorer </parameter> <parameter name= \"session_id\" > recipe_20251118_143022_a3f2 </parameter> <parameter name= \"instruction\" > Now explore the payment module as well </parameter> </invoke> When to Resume \u00b6 Iterative exploration : Continue exploring related areas Follow-up questions : Ask for more details about previous findings Extending work : Build on what was already discovered Note \u00b6 Most workflows don't need resumption - launching a fresh agent with comprehensive instructions is usually simpler and more reliable. Best Practices \u00b6 1. Write Detailed Instructions \u00b6 \u274c Bad : \"Check the auth code\" \u2705 Good : \"Explore the authentication module in src/auth/. Document the authentication flow, identify all user-facing endpoints, check for security best practices (password hashing, token management), and list any technical debt or improvement opportunities. Return a structured report with findings.\" 2. Specify What to Return \u00b6 Always tell the agent exactly what information you need back: \"Return a JSON structure with: - List of security vulnerabilities found - Severity rating for each - Recommended fixes - Files affected\" 3. Clarify Intent (Code vs Research) \u00b6 Tell the agent if you want: - Research only : \"Investigate and report findings\" - Code changes : \"Implement the feature and write tests\" - Both : \"Research the best approach, then implement it\" 4. Use Parallel Execution Aggressively \u00b6 Don't serialize tasks that could run in parallel: \u274c Bad : Launch explorer, wait, then launch test-coverage, wait, then launch security \u2705 Good : Launch all three in one message 5. Git Operations = Always Delegate \u00b6 Never use bash for git commands. Always use foundation:git-ops : \u274c bash(\"git commit -m 'Update'\") \u2705 task(agent=\"foundation:git-ops\", instruction=\"Commit changes with message 'Update'\") 6. Trust Agent Results \u00b6 Agent outputs should generally be trusted. They have specialized tools and expertise for their domain. 7. Provide Context \u00b6 Include relevant information in your instruction: \"The user wants to add OAuth2 authentication. Current auth uses simple JWT tokens in src/auth/. Target: Add Google and GitHub OAuth providers. Check existing OAuth libraries we're already using.\" Try It Yourself \u00b6 Exercise 1: Simple Delegation \u00b6 Try delegating a git status check: Agent: Can you check what git status shows? You: [Use task tool with foundation:git-ops] Exercise 2: Parallel Exploration \u00b6 Explore both frontend and backend architecture simultaneously: Agent: I need to understand both our React frontend and Python backend You: [Launch two explorer agents in parallel] Exercise 3: Full Workflow \u00b6 Implement a new feature end-to-end: 1. Explorer - Understand existing code 2. Zen-architect - Design the feature 3. Modular-builder - Implement it 4. Test-coverage - Write tests 5. Git-ops - Commit changes Try running some of these in parallel! Common Errors \u00b6 \"Session spawning not available\" \u00b6 Cause : The task tool requires session spawning capability which isn't available in all environments. Solution : This is an environment limitation. Sub-agents work in the main Amplifier interface. \"Agent not found\" \u00b6 Cause : Invalid agent name or typo. Solution : Use exact agent names from the Available Agents table (e.g., foundation:git-ops , not git-ops ). \"Task timeout\" \u00b6 Cause : Agent task took too long or got stuck. Solution : - Break down into smaller tasks - Provide more specific instructions - Check if the agent has access to required resources Agent Returns Empty Result \u00b6 Cause : Instruction was too vague or agent couldn't find what was requested. Solution : - Be more specific about what to look for - Provide file paths or starting points - Check if the target code/files actually exist Summary \u00b6 The Task Tool enables: \u2705 Specialization - Right agent for each job \u2705 Autonomy - Agents work independently \u2705 Parallelism - Multiple tasks simultaneously \u2705 Efficiency - Complex workflows completed faster Remember : Delegate complex multi-step tasks, handle simple operations directly. Golden Rule : Git operations ALWAYS use foundation:git-ops !","title":"Task (Sub-Agents)"},{"location":"tools/task.html#task-tool-sub-agents","text":"The Task Tool is Amplifier's delegation system that allows the main agent to spawn specialized sub-agents to handle complex, multi-step tasks autonomously. Each sub-agent operates independently with its own set of tools and expertise.","title":"Task Tool (Sub-Agents)"},{"location":"tools/task.html#what-is-delegation","text":"Delegation in Amplifier means launching a specialized agent to handle a specific task. Instead of doing everything itself, the main agent can: Spawn a sub-agent with a specific instruction Wait for the sub-agent to complete its work autonomously Receive a final report with the results Continue with the next steps based on those results Think of it like assigning work to a specialist colleague who will handle the task independently and report back when done. Key Characteristics: - Sub-agents are stateless - they run once and return results - Sub-agents work autonomously - no back-and-forth during execution - Sub-agents have specialized tools - each type has different capabilities - Multiple sub-agents can run in parallel for faster completion","title":"What is Delegation?"},{"location":"tools/task.html#when-to-delegate","text":"Delegation is powerful but not always necessary. Use the task tool when:","title":"When to Delegate"},{"location":"tools/task.html#always-delegate","text":"Git Operations - ALWAYS use foundation:git-ops : - Creating branches - Committing changes - Creating pull requests - Checking git status/history - Merging branches - Resolving conflicts Large Codebase Exploration - Use foundation:explorer : - Understanding unfamiliar codebases - Finding architectural patterns - Mapping dependencies - Locating specific functionality across many files Complex Debugging - Use foundation:bug-hunter : - Investigating error messages - Tracing execution flows - Finding root causes of failures - Analyzing test failures","title":"\u2705 ALWAYS Delegate"},{"location":"tools/task.html#often-beneficial","text":"Design & Review - Use foundation:zen-architect : - Reviewing code architecture - Suggesting improvements - Design pattern recommendations - Code quality assessments Modular Implementation - Use foundation:modular-builder : - Building new features from scratch - Creating multiple related files - Implementing complex components Testing - Use foundation:test-coverage : - Writing comprehensive test suites - Achieving high coverage - Test strategy planning Security - Use foundation:security-guardian : - Security vulnerability scans - Dependency audits - Best practice checks","title":"\u2705 Often Beneficial"},{"location":"tools/task.html#dont-delegate","text":"Simple File Operations: - Reading 1-2 specific files \u2192 Use read_file directly - Writing a single file \u2192 Use write_file directly - Quick edits \u2192 Use edit_file directly Quick Searches: - Finding a specific class \u2192 Use grep directly - Searching known file paths \u2192 Use glob directly Simple Commands: - Running tests \u2192 Use bash directly - Installing packages \u2192 Use bash directly","title":"\u274c DON'T Delegate"},{"location":"tools/task.html#available-agents","text":"Agent Purpose When to Use foundation:explorer Codebase reconnaissance Understanding unfamiliar code, finding patterns, mapping architecture foundation:git-ops Git operations ALWAYS for commits, branches, PRs, merges, git history foundation:bug-hunter Debugging & investigation Tracing errors, finding bugs, analyzing failures foundation:zen-architect Design & code review Architecture review, design patterns, quality assessment foundation:modular-builder Feature implementation Building new features, creating multiple files foundation:test-coverage Testing Writing tests, improving coverage, test strategy foundation:security-guardian Security checks Vulnerability scans, security audits foundation:file-ops Complex file operations Batch file operations, directory restructuring foundation:web-research External research Fetching docs, researching libraries, finding examples foundation:integration-specialist Integration tasks Connecting systems, API integration foundation:ecosystem-expert Ecosystem knowledge Tool recommendations, best practices","title":"Available Agents"},{"location":"tools/task.html#parallel-execution","text":"One of the most powerful features is running multiple agents simultaneously. This dramatically speeds up complex workflows.","title":"Parallel Execution"},{"location":"tools/task.html#how-to-run-in-parallel","text":"Send a single message with multiple task tool calls : User: \"Analyze the auth module - check architecture, tests, and security\" Agent: I'll launch three agents in parallel to analyze different aspects: - foundation:explorer for architecture - foundation:test-coverage for tests - foundation:security-guardian for security [Makes 3 task tool calls in one message]","title":"How to Run in Parallel"},{"location":"tools/task.html#benefits","text":"Speed : 3 tasks that take 2 minutes each = 2 minutes total (not 6) Efficiency : Better resource utilization Independence : Each agent works autonomously without blocking others","title":"Benefits"},{"location":"tools/task.html#example-scenarios","text":"Feature Development: 1. foundation:explorer - Understand existing code 2. foundation:modular-builder - Implement feature 3. foundation:test-coverage - Write tests All three can run in parallel! Code Quality Check: 1. foundation:zen-architect - Review architecture 2. foundation:security-guardian - Security audit 3. foundation:bug-hunter - Find potential bugs Launch all simultaneously for fast assessment!","title":"Example Scenarios"},{"location":"tools/task.html#session-resumption","text":"Sub-agents typically run once and complete. However, if you need to continue working with a previous agent session:","title":"Session Resumption"},{"location":"tools/task.html#using-session_id","text":"When an agent finishes, it returns a session_id : { \"session_id\" : \"recipe_20251118_143022_a3f2\" , \"result\" : \"Analysis complete...\" } To resume this session: <invoke name= \"task\" > <parameter name= \"agent\" > foundation:explorer </parameter> <parameter name= \"session_id\" > recipe_20251118_143022_a3f2 </parameter> <parameter name= \"instruction\" > Now explore the payment module as well </parameter> </invoke>","title":"Using session_id"},{"location":"tools/task.html#when-to-resume","text":"Iterative exploration : Continue exploring related areas Follow-up questions : Ask for more details about previous findings Extending work : Build on what was already discovered","title":"When to Resume"},{"location":"tools/task.html#note","text":"Most workflows don't need resumption - launching a fresh agent with comprehensive instructions is usually simpler and more reliable.","title":"Note"},{"location":"tools/task.html#best-practices","text":"","title":"Best Practices"},{"location":"tools/task.html#1-write-detailed-instructions","text":"\u274c Bad : \"Check the auth code\" \u2705 Good : \"Explore the authentication module in src/auth/. Document the authentication flow, identify all user-facing endpoints, check for security best practices (password hashing, token management), and list any technical debt or improvement opportunities. Return a structured report with findings.\"","title":"1. Write Detailed Instructions"},{"location":"tools/task.html#2-specify-what-to-return","text":"Always tell the agent exactly what information you need back: \"Return a JSON structure with: - List of security vulnerabilities found - Severity rating for each - Recommended fixes - Files affected\"","title":"2. Specify What to Return"},{"location":"tools/task.html#3-clarify-intent-code-vs-research","text":"Tell the agent if you want: - Research only : \"Investigate and report findings\" - Code changes : \"Implement the feature and write tests\" - Both : \"Research the best approach, then implement it\"","title":"3. Clarify Intent (Code vs Research)"},{"location":"tools/task.html#4-use-parallel-execution-aggressively","text":"Don't serialize tasks that could run in parallel: \u274c Bad : Launch explorer, wait, then launch test-coverage, wait, then launch security \u2705 Good : Launch all three in one message","title":"4. Use Parallel Execution Aggressively"},{"location":"tools/task.html#5-git-operations-always-delegate","text":"Never use bash for git commands. Always use foundation:git-ops : \u274c bash(\"git commit -m 'Update'\") \u2705 task(agent=\"foundation:git-ops\", instruction=\"Commit changes with message 'Update'\")","title":"5. Git Operations = Always Delegate"},{"location":"tools/task.html#6-trust-agent-results","text":"Agent outputs should generally be trusted. They have specialized tools and expertise for their domain.","title":"6. Trust Agent Results"},{"location":"tools/task.html#7-provide-context","text":"Include relevant information in your instruction: \"The user wants to add OAuth2 authentication. Current auth uses simple JWT tokens in src/auth/. Target: Add Google and GitHub OAuth providers. Check existing OAuth libraries we're already using.\"","title":"7. Provide Context"},{"location":"tools/task.html#try-it-yourself","text":"","title":"Try It Yourself"},{"location":"tools/task.html#exercise-1-simple-delegation","text":"Try delegating a git status check: Agent: Can you check what git status shows? You: [Use task tool with foundation:git-ops]","title":"Exercise 1: Simple Delegation"},{"location":"tools/task.html#exercise-2-parallel-exploration","text":"Explore both frontend and backend architecture simultaneously: Agent: I need to understand both our React frontend and Python backend You: [Launch two explorer agents in parallel]","title":"Exercise 2: Parallel Exploration"},{"location":"tools/task.html#exercise-3-full-workflow","text":"Implement a new feature end-to-end: 1. Explorer - Understand existing code 2. Zen-architect - Design the feature 3. Modular-builder - Implement it 4. Test-coverage - Write tests 5. Git-ops - Commit changes Try running some of these in parallel!","title":"Exercise 3: Full Workflow"},{"location":"tools/task.html#common-errors","text":"","title":"Common Errors"},{"location":"tools/task.html#session-spawning-not-available","text":"Cause : The task tool requires session spawning capability which isn't available in all environments. Solution : This is an environment limitation. Sub-agents work in the main Amplifier interface.","title":"\"Session spawning not available\""},{"location":"tools/task.html#agent-not-found","text":"Cause : Invalid agent name or typo. Solution : Use exact agent names from the Available Agents table (e.g., foundation:git-ops , not git-ops ).","title":"\"Agent not found\""},{"location":"tools/task.html#task-timeout","text":"Cause : Agent task took too long or got stuck. Solution : - Break down into smaller tasks - Provide more specific instructions - Check if the agent has access to required resources","title":"\"Task timeout\""},{"location":"tools/task.html#agent-returns-empty-result","text":"Cause : Instruction was too vague or agent couldn't find what was requested. Solution : - Be more specific about what to look for - Provide file paths or starting points - Check if the target code/files actually exist","title":"Agent Returns Empty Result"},{"location":"tools/task.html#summary","text":"The Task Tool enables: \u2705 Specialization - Right agent for each job \u2705 Autonomy - Agents work independently \u2705 Parallelism - Multiple tasks simultaneously \u2705 Efficiency - Complex workflows completed faster Remember : Delegate complex multi-step tasks, handle simple operations directly. Golden Rule : Git operations ALWAYS use foundation:git-ops !","title":"Summary"},{"location":"tools/web.html","text":"Web Tools \u00b6 Web tools enable agents to access and retrieve information from the internet. These tools are essential for gathering real-time data, documentation, and external resources that aren't available in the local context. Operations \u00b6 Tool Purpose web_search Search the internet using a search engine web_fetch Fetch and read content from a specific URL Web Search \u00b6 The web_search tool allows agents to search the internet and retrieve relevant results based on a query. Basic Search \u00b6 web_search ( query = \"Python asyncio tutorial\" ) This returns: - Snippets : Text excerpts from matching pages - URLs : Direct links to the sources - Titles : Page titles for context - Metadata : Relevance scores and timestamps Search Parameters \u00b6 web_search ( query = \"FastAPI best practices\" , max_results = 10 , # Limit number of results (default: 5) search_depth = \"advanced\" # Search depth: \"basic\" or \"advanced\" ) Search Depth Options: - basic : Quick search with top results (faster) - advanced : Deeper search with more comprehensive results (slower) Use Cases \u00b6 Documentation Lookup: web_search ( query = \"Django 4.2 ORM query optimization\" ) API Research: web_search ( query = \"OpenAI API rate limits 2024\" ) Error Troubleshooting: web_search ( query = \"Python ModuleNotFoundError importlib.metadata\" ) Version-Specific Information: web_search ( query = \"Node.js 20 breaking changes\" ) Search Query Tips \u00b6 Be Specific : Include version numbers, library names, or exact error messages Use Quotes : For exact phrase matching: \"cannot import name\" Include Year : For time-sensitive information: \"React hooks 2024\" Filter by Site : Use site: operator: \"site:stackoverflow.com python async\" Fetching URLs \u00b6 The web_fetch tool retrieves the full content of a specific web page. Basic Fetch \u00b6 web_fetch ( url = \"https://docs.python.org/3/library/asyncio.html\" ) Returns the page content in a readable text format, stripped of HTML tags and formatting. Size Limits \u00b6 Web pages can be very large. The tool has built-in protections: Default Limit : ~200KB of text content Truncation : Large pages are automatically truncated Warning : You'll be notified when content is truncated Handling Truncated Content: # For large pages, save to file instead web_fetch ( url = \"https://example.com/long-article\" , save_to_file = \"/tmp/article.txt\" ) Save to File \u00b6 For large documents, API responses, or content you need to process: web_fetch ( url = \"https://api.github.com/repos/python/cpython\" , save_to_file = \"/tmp/github_response.json\" ) Benefits: - No content truncation - Can process file in chunks - Preserves exact formatting - Efficient memory usage Fetching Different Content Types \u00b6 HTML Pages: web_fetch ( url = \"https://developer.mozilla.org/en-US/docs/Web/JavaScript\" ) # Returns cleaned text content API Endpoints: web_fetch ( url = \"https://api.example.com/data\" , save_to_file = \"/tmp/api_response.json\" ) Raw Files: web_fetch ( url = \"https://raw.githubusercontent.com/user/repo/main/README.md\" , save_to_file = \"/tmp/readme.md\" ) Documentation: web_fetch ( url = \"https://fastapi.tiangolo.com/tutorial/\" ) Handling Large Pages \u00b6 When dealing with large web pages, use a strategic approach: Strategy 1: Search First, Fetch Later \u00b6 # 1. Search for the topic results = web_search ( query = \"Python decorator patterns\" ) # 2. Review snippets to find most relevant # 3. Fetch only the most promising URL web_fetch ( url = results [ 0 ][ 'url' ], save_to_file = \"/tmp/decorators.txt\" ) # 4. Read specific sections of the saved file read_file ( \"/tmp/decorators.txt\" , offset = 1 , limit = 100 ) Strategy 2: Fetch to File \u00b6 # Fetch large content to file web_fetch ( url = \"https://docs.djangoproject.com/en/5.0/\" , save_to_file = \"/tmp/django_docs.html\" ) # Read relevant sections read_file ( \"/tmp/django_docs.html\" , offset = 100 , limit = 50 ) Strategy 3: Multiple Targeted Fetches \u00b6 Instead of fetching one large page: # Fetch specific sub-pages web_fetch ( url = \"https://example.com/docs/intro\" ) web_fetch ( url = \"https://example.com/docs/api-reference\" ) web_fetch ( url = \"https://example.com/docs/examples\" ) Best Practices \u00b6 1. Search Before Fetching \u00b6 Don't fetch URLs blindly. Use search to find the right content first: # Good: Search first to find relevant content results = web_search ( query = \"FastAPI middleware authentication\" ) web_fetch ( url = results [ 0 ][ 'url' ]) # Avoid: Fetching without knowing if it's relevant web_fetch ( url = \"https://example.com/docs/\" ) # Might be huge and irrelevant 2. Use Appropriate Tools \u00b6 Use web_search when: - You need to find information but don't have a URL - You want multiple perspectives or sources - You're researching current events or trends - You need to verify information across sources Use web_fetch when: - You have a specific URL to retrieve - You need the complete content of a page - You're accessing API endpoints - You need to download files or raw content 3. Handle Failures Gracefully \u00b6 # Web operations can fail due to network issues, timeouts, etc. # Always have a fallback strategy # Try fetching documentation try : web_fetch ( url = \"https://docs.example.com/api\" ) except : # Fall back to search if fetch fails web_search ( query = \"example.com API documentation\" ) 4. Be Respectful \u00b6 Don't fetch the same URL repeatedly in a short time Use search when possible to minimize direct fetches Save large content to files to avoid re-fetching 5. Verify Information \u00b6 Web content can be outdated or incorrect: - Check publication dates in search results - Cross-reference information from multiple sources - Prefer official documentation over third-party sources Try It Yourself \u00b6 Exercise 1: Research a Library \u00b6 Search for information about a Python library and fetch its documentation: # 1. Search for the library web_search ( query = \"httpx Python async client tutorial\" ) # 2. Fetch the official documentation web_fetch ( url = \"https://www.python-httpx.org/\" ) # 3. Search for specific examples web_search ( query = \"httpx async examples GitHub\" ) Exercise 2: API Investigation \u00b6 Research an API and fetch example responses: # 1. Search for API documentation web_search ( query = \"GitHub REST API repositories endpoint\" ) # 2. Fetch the API documentation web_fetch ( url = \"https://docs.github.com/en/rest/repos/repos\" ) # 3. Fetch example data and save it web_fetch ( url = \"https://api.github.com/repos/python/cpython\" , save_to_file = \"/tmp/github_api_example.json\" ) Exercise 3: Troubleshooting \u00b6 Find solutions to a specific error: # 1. Search for the error message web_search ( query = \"Python 'RuntimeError: Event loop is closed' asyncio\" ) # 2. Fetch the most relevant Stack Overflow answer web_fetch ( url = \"<most_relevant_stackoverflow_url>\" ) # 3. Search for related issues web_search ( query = \"asyncio event loop best practices\" ) Common Errors \u00b6 \"Failed to fetch URL\" \u00b6 Cause : Network issues, invalid URL, or server unavailable Solution : - Verify the URL is correct and accessible - Check if the website is online - Try searching for the content instead - Wait and retry if it's a temporary issue \"Content truncated due to size\" \u00b6 Cause : Web page exceeds size limits Solution : # Save to file instead web_fetch ( url = \"<large_url>\" , save_to_file = \"/tmp/content.txt\" ) \"Rate limit exceeded\" \u00b6 Cause : Too many requests in a short time Solution : - Space out your requests - Use search results without fetching every URL - Cache previously fetched content \"Search returned no results\" \u00b6 Cause : Query too specific or obscure topic Solution : - Broaden your search terms - Remove version numbers or very specific details - Try alternative phrasings - Check spelling Summary \u00b6 Web tools are powerful for: - Research : Finding current information and best practices - Documentation : Accessing official docs and API references - Troubleshooting : Finding solutions to errors and issues - Data Collection : Retrieving content from web sources Key Points: - Use web_search to find information, web_fetch to retrieve specific content - Save large content to files to avoid truncation - Search first, then fetch to be efficient - Handle failures gracefully and verify information - Be respectful with request frequency Web tools bridge the gap between local knowledge and the vast resources available online, enabling agents to access the most current and comprehensive information available.","title":"Web Tools"},{"location":"tools/web.html#web-tools","text":"Web tools enable agents to access and retrieve information from the internet. These tools are essential for gathering real-time data, documentation, and external resources that aren't available in the local context.","title":"Web Tools"},{"location":"tools/web.html#operations","text":"Tool Purpose web_search Search the internet using a search engine web_fetch Fetch and read content from a specific URL","title":"Operations"},{"location":"tools/web.html#web-search","text":"The web_search tool allows agents to search the internet and retrieve relevant results based on a query.","title":"Web Search"},{"location":"tools/web.html#basic-search","text":"web_search ( query = \"Python asyncio tutorial\" ) This returns: - Snippets : Text excerpts from matching pages - URLs : Direct links to the sources - Titles : Page titles for context - Metadata : Relevance scores and timestamps","title":"Basic Search"},{"location":"tools/web.html#search-parameters","text":"web_search ( query = \"FastAPI best practices\" , max_results = 10 , # Limit number of results (default: 5) search_depth = \"advanced\" # Search depth: \"basic\" or \"advanced\" ) Search Depth Options: - basic : Quick search with top results (faster) - advanced : Deeper search with more comprehensive results (slower)","title":"Search Parameters"},{"location":"tools/web.html#use-cases","text":"Documentation Lookup: web_search ( query = \"Django 4.2 ORM query optimization\" ) API Research: web_search ( query = \"OpenAI API rate limits 2024\" ) Error Troubleshooting: web_search ( query = \"Python ModuleNotFoundError importlib.metadata\" ) Version-Specific Information: web_search ( query = \"Node.js 20 breaking changes\" )","title":"Use Cases"},{"location":"tools/web.html#search-query-tips","text":"Be Specific : Include version numbers, library names, or exact error messages Use Quotes : For exact phrase matching: \"cannot import name\" Include Year : For time-sensitive information: \"React hooks 2024\" Filter by Site : Use site: operator: \"site:stackoverflow.com python async\"","title":"Search Query Tips"},{"location":"tools/web.html#fetching-urls","text":"The web_fetch tool retrieves the full content of a specific web page.","title":"Fetching URLs"},{"location":"tools/web.html#basic-fetch","text":"web_fetch ( url = \"https://docs.python.org/3/library/asyncio.html\" ) Returns the page content in a readable text format, stripped of HTML tags and formatting.","title":"Basic Fetch"},{"location":"tools/web.html#size-limits","text":"Web pages can be very large. The tool has built-in protections: Default Limit : ~200KB of text content Truncation : Large pages are automatically truncated Warning : You'll be notified when content is truncated Handling Truncated Content: # For large pages, save to file instead web_fetch ( url = \"https://example.com/long-article\" , save_to_file = \"/tmp/article.txt\" )","title":"Size Limits"},{"location":"tools/web.html#save-to-file","text":"For large documents, API responses, or content you need to process: web_fetch ( url = \"https://api.github.com/repos/python/cpython\" , save_to_file = \"/tmp/github_response.json\" ) Benefits: - No content truncation - Can process file in chunks - Preserves exact formatting - Efficient memory usage","title":"Save to File"},{"location":"tools/web.html#fetching-different-content-types","text":"HTML Pages: web_fetch ( url = \"https://developer.mozilla.org/en-US/docs/Web/JavaScript\" ) # Returns cleaned text content API Endpoints: web_fetch ( url = \"https://api.example.com/data\" , save_to_file = \"/tmp/api_response.json\" ) Raw Files: web_fetch ( url = \"https://raw.githubusercontent.com/user/repo/main/README.md\" , save_to_file = \"/tmp/readme.md\" ) Documentation: web_fetch ( url = \"https://fastapi.tiangolo.com/tutorial/\" )","title":"Fetching Different Content Types"},{"location":"tools/web.html#handling-large-pages","text":"When dealing with large web pages, use a strategic approach:","title":"Handling Large Pages"},{"location":"tools/web.html#strategy-1-search-first-fetch-later","text":"# 1. Search for the topic results = web_search ( query = \"Python decorator patterns\" ) # 2. Review snippets to find most relevant # 3. Fetch only the most promising URL web_fetch ( url = results [ 0 ][ 'url' ], save_to_file = \"/tmp/decorators.txt\" ) # 4. Read specific sections of the saved file read_file ( \"/tmp/decorators.txt\" , offset = 1 , limit = 100 )","title":"Strategy 1: Search First, Fetch Later"},{"location":"tools/web.html#strategy-2-fetch-to-file","text":"# Fetch large content to file web_fetch ( url = \"https://docs.djangoproject.com/en/5.0/\" , save_to_file = \"/tmp/django_docs.html\" ) # Read relevant sections read_file ( \"/tmp/django_docs.html\" , offset = 100 , limit = 50 )","title":"Strategy 2: Fetch to File"},{"location":"tools/web.html#strategy-3-multiple-targeted-fetches","text":"Instead of fetching one large page: # Fetch specific sub-pages web_fetch ( url = \"https://example.com/docs/intro\" ) web_fetch ( url = \"https://example.com/docs/api-reference\" ) web_fetch ( url = \"https://example.com/docs/examples\" )","title":"Strategy 3: Multiple Targeted Fetches"},{"location":"tools/web.html#best-practices","text":"","title":"Best Practices"},{"location":"tools/web.html#1-search-before-fetching","text":"Don't fetch URLs blindly. Use search to find the right content first: # Good: Search first to find relevant content results = web_search ( query = \"FastAPI middleware authentication\" ) web_fetch ( url = results [ 0 ][ 'url' ]) # Avoid: Fetching without knowing if it's relevant web_fetch ( url = \"https://example.com/docs/\" ) # Might be huge and irrelevant","title":"1. Search Before Fetching"},{"location":"tools/web.html#2-use-appropriate-tools","text":"Use web_search when: - You need to find information but don't have a URL - You want multiple perspectives or sources - You're researching current events or trends - You need to verify information across sources Use web_fetch when: - You have a specific URL to retrieve - You need the complete content of a page - You're accessing API endpoints - You need to download files or raw content","title":"2. Use Appropriate Tools"},{"location":"tools/web.html#3-handle-failures-gracefully","text":"# Web operations can fail due to network issues, timeouts, etc. # Always have a fallback strategy # Try fetching documentation try : web_fetch ( url = \"https://docs.example.com/api\" ) except : # Fall back to search if fetch fails web_search ( query = \"example.com API documentation\" )","title":"3. Handle Failures Gracefully"},{"location":"tools/web.html#4-be-respectful","text":"Don't fetch the same URL repeatedly in a short time Use search when possible to minimize direct fetches Save large content to files to avoid re-fetching","title":"4. Be Respectful"},{"location":"tools/web.html#5-verify-information","text":"Web content can be outdated or incorrect: - Check publication dates in search results - Cross-reference information from multiple sources - Prefer official documentation over third-party sources","title":"5. Verify Information"},{"location":"tools/web.html#try-it-yourself","text":"","title":"Try It Yourself"},{"location":"tools/web.html#exercise-1-research-a-library","text":"Search for information about a Python library and fetch its documentation: # 1. Search for the library web_search ( query = \"httpx Python async client tutorial\" ) # 2. Fetch the official documentation web_fetch ( url = \"https://www.python-httpx.org/\" ) # 3. Search for specific examples web_search ( query = \"httpx async examples GitHub\" )","title":"Exercise 1: Research a Library"},{"location":"tools/web.html#exercise-2-api-investigation","text":"Research an API and fetch example responses: # 1. Search for API documentation web_search ( query = \"GitHub REST API repositories endpoint\" ) # 2. Fetch the API documentation web_fetch ( url = \"https://docs.github.com/en/rest/repos/repos\" ) # 3. Fetch example data and save it web_fetch ( url = \"https://api.github.com/repos/python/cpython\" , save_to_file = \"/tmp/github_api_example.json\" )","title":"Exercise 2: API Investigation"},{"location":"tools/web.html#exercise-3-troubleshooting","text":"Find solutions to a specific error: # 1. Search for the error message web_search ( query = \"Python 'RuntimeError: Event loop is closed' asyncio\" ) # 2. Fetch the most relevant Stack Overflow answer web_fetch ( url = \"<most_relevant_stackoverflow_url>\" ) # 3. Search for related issues web_search ( query = \"asyncio event loop best practices\" )","title":"Exercise 3: Troubleshooting"},{"location":"tools/web.html#common-errors","text":"","title":"Common Errors"},{"location":"tools/web.html#failed-to-fetch-url","text":"Cause : Network issues, invalid URL, or server unavailable Solution : - Verify the URL is correct and accessible - Check if the website is online - Try searching for the content instead - Wait and retry if it's a temporary issue","title":"\"Failed to fetch URL\""},{"location":"tools/web.html#content-truncated-due-to-size","text":"Cause : Web page exceeds size limits Solution : # Save to file instead web_fetch ( url = \"<large_url>\" , save_to_file = \"/tmp/content.txt\" )","title":"\"Content truncated due to size\""},{"location":"tools/web.html#rate-limit-exceeded","text":"Cause : Too many requests in a short time Solution : - Space out your requests - Use search results without fetching every URL - Cache previously fetched content","title":"\"Rate limit exceeded\""},{"location":"tools/web.html#search-returned-no-results","text":"Cause : Query too specific or obscure topic Solution : - Broaden your search terms - Remove version numbers or very specific details - Try alternative phrasings - Check spelling","title":"\"Search returned no results\""},{"location":"tools/web.html#summary","text":"Web tools are powerful for: - Research : Finding current information and best practices - Documentation : Accessing official docs and API references - Troubleshooting : Finding solutions to errors and issues - Data Collection : Retrieving content from web sources Key Points: - Use web_search to find information, web_fetch to retrieve specific content - Save large content to files to avoid truncation - Search first, then fetch to be efficient - Handle failures gracefully and verify information - Be respectful with request frequency Web tools bridge the gap between local knowledge and the vast resources available online, enabling agents to access the most current and comprehensive information available.","title":"Summary"}]}